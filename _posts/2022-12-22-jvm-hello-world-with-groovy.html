---
layout: post
status: PUBLISHED
published: true
title: JVM Hello World with Groovy
author:
  display_name: Paul King
  login: paulk
  email: paulk@apache.org
author_login: paulk
author_email: paulk@apache.org
id: ecf7da45-fe19-4c10-953f-8f607c40e528
date: '2022-12-22 14:24:07 -0500'
categories:
- Technology
tags:
- groovy
- bytecode
comments: []
permalink: groovy/entry/jvm-hello-world-with-groovy
---
<p>For those that haven't seen it yet, the <a href="https://www.javaadvent.com/" target="_blank">JVM Advent</a> <a href="https://twitter.com/JavaAdvent" target="_blank">folks</a> posted a great <a href="https://www.javaadvent.com/2022/12/groovy-and-data-science.html" target="_blank">Groovy and Data Science blog post</a> several days ago as part of the 2022 JVM Advent series. If you have an interest in Data Science, we recommend you check that out before continuing with this post.</p>
<p><a href="https://www.javaadvent.com/2022/12/jvm-hello-world.html" target="_blank">Today's post</a> in the JVM Advent series is looking at the world of bytecode libraries on the JVM. Let's look at creating the same hello world example from that post using <a href="http://groovy-lang.org/index.html" target="_blank">Groovy</a> with the <a href="https://github.com/Guardsquare/proguard-core" target="_blank">ProGuardCORE</a>, <a href="https://asm.ow2.io/" target="_blank">ASM</a>, and <a href="https://bytebuddy.net/" target="_blank">Byte Buddy</a> libraries.</p>
<p>First, we highly recommend you read the previously mentioned <a href="https://www.javaadvent.com/2022/12/jvm-hello-world.html" target="_blank">JVM Advent post</a> first for more background. After all, it's easy to create a simple hello world class file example directly as a Java source file (as that post shows) or as a Groovy source file like this:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">println <span style="color:#6a8759;">'Hello world'<br></span></pre>
<p>The examples shown in this blog post illustrate how you could create the equivalent class file using libraries which let you manipulate the generated bytecode directly. It's a bit of a deep dive if you want to know more about JVM internals and can also be handy for numerous use cases like building tools or&nbsp;modifying Java classes on the fly. I suggest you read the web sites for those libraries if you want further details or additional motivation.</p>
<h3>ProGuardCORE</h3>
<p>The ProGuardCORE library lets you&nbsp;read, analyze, modify, and write Java class files. Here's how we could use it to write a hello world class file:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>name = <span style="color:#6a8759;">'HelloProGuardCORE'<br></span><span style="color:#cc7832;">var </span>superclass = <span style="color:#6a8759;">'java/lang/Object'<br></span><span style="color:#cc7832;">var </span>classBuilder = <span style="color:#cc7832;">new </span>ClassBuilder(<span style="color:#9876aa;font-style:italic;">CLASS_VERSION_1_8</span>, <span style="color:#9876aa;font-style:italic;">PUBLIC</span>, name, superclass).tap <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>addMethod(<span style="color:#9876aa;font-style:italic;">PUBLIC </span>| <span style="color:#9876aa;font-style:italic;">STATIC</span>, <span style="color:#6a8759;">'main'</span>, <span style="color:#6a8759;">'([Ljava/lang/String;)V'</span>, <span style="color:#6897bb;">100</span>, builder -><br>        builder<br>            .getstatic(<span style="color:#6a8759;">'java/lang/System'</span>, <span style="color:#6a8759;">'out'</span>, <span style="color:#6a8759;">'Ljava/io/PrintStream;'</span>)<br>            .ldc(<span style="color:#6a8759;">"Hello from </span>$name<span style="color:#6a8759;">"</span>)<br>            .invokevirtual(<span style="color:#6a8759;">'java/io/PrintStream'</span>, <span style="color:#6a8759;">'println'</span>, <span style="color:#6a8759;">'(Ljava/lang/String;)V'</span>)<br>            .return_()<br>    )<br><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="color:#cc7832;">new </span>File(<span style="color:#6a8759;">"</span>$<span style="font-weight:bold;">{</span>name<span style="font-weight:bold;">}</span><span style="color:#6a8759;">.class"</span>).withDataOutputStream <span style="font-weight:bold;">{ </span>dos <span style="font-weight:bold;">-><br></span><span style="font-weight:bold;">    </span>classBuilder.<span style="color:#9876aa;">programClass</span>.accept(<span style="color:#cc7832;">new </span>ProgramClassWriter(dos))<br><span style="font-weight:bold;">}<br></span></pre>
<p>This is essentially the "<i>Groovified</i>" version of the example in the JVM Advent blog post. We are using the libraries <code>ClassBuilder</code> class, adding a method, then adding four bytecode statements as the body of the method. If you haven't seen method and type descriptor syntax before, a few parts might seem a little strange but you possibly won't be surprised that it seems to be referencing a <code>System.out.println</code> call and passing it a constant String.</p>
<p>When we run this script, a <code>HelloProGuardCORE</code> class file is produced. We can invoke that class file in the normal way:</p>
<pre>$ java HelloProGuardCORE
Hello from HelloProGuardCORE
</pre>
<p>We encourage you to read the JVM Advent post or the library documentation if you want more details.</p>
<h3>ASM</h3>
<p><a href="https://asm.ow2.io/" target="_blank">ASM</a> is an all purpose Java bytecode manipulation and analysis framework. In fact, it's the one that Groovy uses in its parser and some of its tools. Here is how to use it to generate more or less the same class as previously:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>name = <span style="color:#6a8759;">'HelloASM'<br></span><span style="color:#cc7832;">var </span>superclass = <span style="color:#6a8759;">'java/lang/Object'<br></span><span style="color:#cc7832;">var </span>cw = <span style="color:#cc7832;">new </span>ClassWriter(<span style="color:#6897bb;">0</span>)<br>cw.visit(<span style="color:#9876aa;font-style:italic;">V1_8</span>, <span style="color:#9876aa;font-style:italic;">ACC_PUBLIC </span>+ <span style="color:#9876aa;font-style:italic;">ACC_SUPER</span>, name, <span style="color:#cc7832;">null</span>, superclass, <span style="color:#cc7832;">null</span>)<br>cw.visitMethod(<span style="color:#9876aa;font-style:italic;">ACC_PUBLIC </span>+ <span style="color:#9876aa;font-style:italic;">ACC_STATIC</span>, <span style="color:#6a8759;">'main'</span>, <span style="color:#6a8759;">'([Ljava/lang/String;)V'</span>, <span style="color:#cc7832;">null</span>, <span style="color:#cc7832;">null</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>visitCode()<br>    visitFieldInsn(<span style="color:#9876aa;font-style:italic;">GETSTATIC</span>, <span style="color:#6a8759;">'java/lang/System'</span>, <span style="color:#6a8759;">'out'</span>, <span style="color:#6a8759;">'Ljava/io/PrintStream;'</span>)<br>    visitLdcInsn(<span style="color:#6a8759;">'Hello from ' </span>+ name)<br>    visitMethodInsn(<span style="color:#9876aa;font-style:italic;">INVOKEVIRTUAL</span>, <span style="color:#6a8759;">'java/io/PrintStream'</span>, <span style="color:#6a8759;">'println'</span>, <span style="color:#6a8759;">'(Ljava/lang/String;)V'</span>, <span style="color:#cc7832;">false</span>)<br>    visitInsn(<span style="color:#9876aa;font-style:italic;">RETURN</span>)<br>    visitMaxs(<span style="color:#6897bb;">3</span>, <span style="color:#6897bb;">3</span>)<br>    visitEnd()<br><span style="font-weight:bold;">}<br></span>cw.visitEnd()<br><br><span style="color:#cc7832;">new </span>File(<span style="color:#6a8759;">"</span>$<span style="font-weight:bold;">{</span>name<span style="font-weight:bold;">}</span><span style="color:#6a8759;">.class"</span>).withDataOutputStream <span style="font-weight:bold;">{ </span>dos <span style="font-weight:bold;">-><br></span><span style="font-weight:bold;">    </span>dos.write(cw.toByteArray())<br><span style="font-weight:bold;">}<br></span></pre>
<p>After running this script, a <code>HelloASM</code> class file is produced, and here is the output when running that class file:</p>
<pre>$ java HelloASM
Hello from HelloASM
</pre>
<p>Parts of the code should look familiar to the previous example.</p>
<h3>Byte Buddy</h3>
<p><a href="https://bytebuddy.net/" target="_blank">Byte Buddy</a> is a code generation and manipulation library for creating and modifying Java classes. It's strengths lie in its ability to create and modify classes dynamically. So, its power is perhaps not needed for our simple example. A nice aspect of this library however, is that it hides some of the low-level details like type and method descriptors behind its fluent API. Here is our example:<br></p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>name = <span style="color:#6a8759;">'HelloByteBuddy'<br></span><span style="color:#cc7832;">new </span>ByteBuddy()<br>    .subclass(Object)<br>    .name(name)<br>    .defineMethod(<span style="color:#6a8759;">'main'</span>, Void.<span style="color:#9876aa;font-style:italic;">TYPE</span>, <span style="color:#9876aa;font-style:italic;">PUBLIC </span>| <span style="color:#9876aa;font-style:italic;">STATIC</span>)<br>    .withParameter(String[])<br>    .intercept(MethodCall.<span style="color:#9876aa;font-style:italic;">invoke</span>(<br>        PrintStream.getMethod(<span style="color:#6a8759;">'println'</span>, String))<br>        .onField(System.getField(<span style="color:#6a8759;">'out'</span>))<br>        .with(<span style="color:#6a8759;">'Hello from ' </span>+ name))<br>    .make()<br>    .saveIn(<span style="color:#6a8759;">'.' </span><span style="color:#cc7832;">as </span>File)<br></pre>
<p>Like the other scripts, this also produces a class file which we can invoke as shown here:</p>
<pre>$ java HelloByteBuddy
Hello from HelloByteBuddy
</pre>
<p>That wraps up our examples using the three libraries, but we have one more fun<br />
alternative to cover!</p>
<h3>Using Groovy ASTs</h3>
<p>Groovy is a very extensible language. It provides among other things, a compile-time<br />
metaprogramming mechanism called AST Transforms (Abstract Syntax Tree Transformations). This mechanism uses annotations to indicate to the compiler that special processing is required during compilation. A now somewhat outdated AST transform, <a href="https://github.com/melix/groovy-bytecode-ast" target="_blank">@Bytecode</a>, experimented with allowing you to write bytecode instructions directly in your Groovy code. Let's look at using that AST transform here:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#bbb529;">@CompileStatic @POJO<br></span><span style="color:#cc7832;">class </span>HelloAST {<br>    <span style="color:#bbb529;">@Bytecode<br></span><span style="color:#bbb529;">    </span><span style="color:#cc7832;">static void </span>main(args) {<br>        getstatic <span style="color:#6a8759;">'java/lang/System.out'</span>, <span style="color:#6a8759;">'Ljava/io/PrintStream;'<br></span><span style="color:#6a8759;">        </span>ldc <span style="color:#6a8759;">'Hello from HelloAST'<br></span><span style="color:#6a8759;">        </span>invokevirtual <span style="color:#6a8759;">'java/io/PrintStream.println'</span>, <span style="color:#6a8759;">'(Ljava/lang/String;)V'<br></span><span style="color:#6a8759;">        </span><span style="color:#cc7832;">return<br></span><span style="color:#cc7832;">    </span>}<br>}<br></pre>
<p>We are writing directly the instructions that the Java or Groovy compiler (with static compilation enabled) would produce. For this example, we don't run the script to produce the class file, we just compile it using the Groovy compiler.</p>
<p>We definitely don't recommend relying on the <code>@Bytecode</code> AST transform for any production code but it can be fun to play with. We've also used the <code>@CompileStatic</code> and <code>@POJO</code> AST transforms to tell the compiler that we aren't using any Groovy dynamic features, so that it should write Java-like code whenever possible and avoid calling the Groovy runtime.</p>
<p>We can examine the bytecode using javap and indeed it has bytecode similar to that produced by the other libraries:</p>
<pre>  public static void main(java.lang.String...);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0089) ACC_PUBLIC, ACC_STATIC, ACC_VARARGS
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #21                 // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #23                 // String Hello from HelloAST
         5: invokevirtual #29                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  args   Ljava/lang/Object;
</pre>
<p>Because the code is not calling the Groovy runtime, we can invoke it directly without the Groovy jar:</p>
<pre>$ java HelloAST
Hello from HelloAST
</pre>
<p>That wraps up our little tour of bytecode libraries. I hope you have learnt some additional JVM details!</p>
<h3>Further information</h3>
<ul>
<li><a href="https://github.com/paulk-asert/bytecode-fun" target="_blank">Github repo</a> of the above examples</li>
<li>A <a href="https://openjdk.org/jeps/8280389" target="_blank">draft JEP</a> for what might become an official API for parsing, generating, and transforming Java class files</li>
<li>Social media:&nbsp;<a href="https://twitter.com/ApacheGroovy" target="_blank">@ApacheGroovy</a> <a href="https://fosstodon.org/@ApacheGroovy" target="_blank">@ApacheGroovy@fosstodon.org</a></li>
</ul>
