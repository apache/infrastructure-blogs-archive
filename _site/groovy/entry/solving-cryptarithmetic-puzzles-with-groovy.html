<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Solving cryptarithmetic puzzles with Groovy and constraint programming using Choco, JaCoP, and OR-Tools | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Solving cryptarithmetic puzzles with Groovy and constraint programming using Choco, JaCoP, and OR-Tools" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction When writing solutions to problems, we frequently strive to hide away implementation details. In Object-oriented (OO) programming, we might build a rich hierarchy of classes with well-thought out methods so that our final solution can be expressed in terms of simple nouns and verbs (methods and class instances) in our domain model. When applying functional programming idioms, we will strive to emphasise the relationship between inputs and outputs and hide away side effects and iterative steps. Constraint programming (within the same family as logic programming) also strives to hide away details. Instead of expressing an iterative implementation, it focuses on expressing declarative properties of a solution. A solver is responsible for working out the exact implementation steps. When using constraint programming, we develop a model consisting of variables, the domain of values each variable may hold, and additional constraints between the variables. A solver does all the work. It may employ heuristic searching, inference, propagation, symmetry and backtracking to find possible solutions. We may be able to (or want to, or need to) guide the solver as to which techniques and strategies it should use. Constraint programming has been used to solve various kinds of problems including scheduling problems, and excels at problems with combinatorial possibilities that are too irregular for other mathematical optimisations. Frequently used illustrative problems are Sudoku and Wordle solvers, N-Queen problems, and other kinds of puzzles. We&#39;ll just look at cryptarithmetic puzzles. Cryptarithmetic Problems Cryptarithmetic problems (also known as alphametics, verbal arithmetic, cryptarithm, and word addition) are a type of mathematical game where a mathematical equation is presented where digits in the equation are replaced by letters. Traditionally, each letter usually represents a unique number, and numbers don&#39;t start with the digit zero. If we look at one sample problem: &lt;/p&gt; T O + G O = O U T We can reason about what the solution can be by hand: T, O, U, and G must be all different (game rule) T, G, and O will be between 1 and 9, and U is between 0 and 9 (game rule) If we added the two biggest 2-digit numbers, (99 + 99) we&#39;d get 198, so O must be 1 Looking at the right-most &quot;units&quot; column, 1 + 1 equals 2, so T must be 2 Looking at the &quot;tens&quot; column, we know there is a carry of 1 (since O is 1) and we know T is 2, so G must be 8 or 9. If G was 9, U would be 1 but it can&#39;t be the same as O, so G must be 8 and U must be 0. When solving by hand, we typically reason about individual columns and account for the &quot;carry&quot; to the next column. We&#39;ll come back to this point later but first, let&#39;s look at a slightly bigger problem: S E N D + M O R E = M O N E Y Solving with Brute Force This problem isn&#39;t huge, so we can solve with brute force. We simply try all possible values for the letters in the puzzle: for (s in 1..9) for (e in 0..9) for (n in 0..9) for (d in 0..9) for (m in 1..9) for (o in 0..9) for (r in 0..9) for (y in 0..9) if ([s, e, n, d, m, o, r, y].toSet().size() == 8) { def send = 1000 * s + 100 * e + 10 * n + d def more = 1000 * m + 100 * o + 10 * r + e def money = 10000 * m + 1000 * o + 100 * n + 10 * e + y if (send + more == money) { println &quot;s = $s, e = $e, n = $n, d = $d&quot; println &quot;m = $m, o = $o, r = $r, y = $y&quot; } } This isn&#39;t very efficient though. It calculates 81 million combinations for the variables before skipping all but 1.5 million of them (since most won&#39;t be unique). All up it might execute in the low tens of seconds. Alternatively, Groovy supports calculating permutations, so we can simplify our solution to a single for loop (with some tests to eliminate unhelpful iterations): def digits = 0..9for (p in digits.permutations()) { if (p[-1] &lt; p[-2]) continue def (s, e, n, d, m, o, r, y) = p if (s == 0 || m == 0) continue def send = 1000 * s + 100 * e + 10 * n + d def more = 1000 * m + 100 * o + 10 * r + e def money = 10000 * m + 1000 * o + 100 * n + 10 * e + y if (send + more == money) { println &quot;s = $s, e = $e, n = $n, d = $d&quot; println &quot;m = $m, o = $o, r = $r, y = $y&quot; }} This has the advantage of only generating unique combinations. It will execute in seconds. Running either of these solutions yields: s = 9, e = 5, n = 6, d = 7 m = 1, o = 0, r = 8, y = 2 Using Constraint Programming For the brute force approaches, we had a condition which checked any potential candidate answer to see if it was a correct solution. We had to be very explicit in how we wanted the potential candidates to be created. For constraint programming, we instead define variables to represent the problem, any known bounds on those variables, and we specify any other known properties of the solution, which in our case will be something similar to the condition we had to check if the answer was correct previously. Let&#39;s examine how to do that with three libraries, one with a variation. Choco Here is the code using the Choco library: new Model(&quot;SEND+MORE=MONEY&quot;).with { def (S, M) = [&#39;S&#39;, &#39;M&#39;].collect { intVar(it, 1, 9) } def (E, N, D, O, R, Y) = [&#39;E&#39;, &#39;N&#39;, &#39;D&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;].collect { intVar(it, 0, 9) } allDifferent(S, E, N, D, M, O, R, Y).post() IntVar[] ALL = [ S, E, N, D, M, O, R, E, M, O, N, E, Y ] int[] COEFFS = [ 1000, 100, 10, 1, 1000, 100, 10, 1, -10000, -1000, -100, -10, -1 ] scalar(ALL, COEFFS, &quot;=&quot;, 0).post() println solver.findSolution()} We define our variables and their bounds (domain). We use an allDifferent global constraint to specify the uniqueness requirement and a scalar constraint that ensures that our variables multiplied by their respective scalar coefficients equal 0. This lets us factor in whether the particular variable is representing the &quot;units&quot; column, the &quot;10s&quot; column, the &quot;100s&quot; column etc. This captures the &quot;puzzle addition&quot; constraint. We then ask the solver to find the solution. We could just as easily have asked for all solutions (if more than one existed). This is typical of how we solve such problems. We either define constraints directly between one or more variables or use whatever global constraints our library might support. If our library doesn&#39;t support the constraint we need, we find a way to express it using multiple simpler constraints. The end result is that our code is more declarative than our brute force approaches, and the solution is found in tens of milliseconds. The solver has very efficient strategies for solving such puzzles. &lt;h4 style=”font-family: “Helvetica Neue”, Helvetica, Arial, sans-serif; color: rgb(0, 0, 0);”&gt;JaCoP&lt;/h4&gt; We can solve the same problem using JaCoP: def store = new Store()def (S, M) = [&#39;S&#39;, &#39;M&#39;].collect { new IntVar(store, it, 1, 9) }def (E, N, D, O, R, Y) = [&#39;E&#39;, &#39;N&#39;, &#39;D&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;].collect { new IntVar(store, it, 0, 9) }var ctr = new Alldifferent(S, E, N, D, M, O, R, Y)store.impose(ctr)IntVar[] ALL = [ S, E, N, D, M, O, R, E, M, O, N, E, Y ]int[] COEFFS = [ 1000, 100, 10, 1, 1000, 100, 10, 1, -10000, -1000, -100, -10, -1 ]var lin = new LinearInt(ALL, COEFFS, &quot;==&quot;, 0)store.impose(lin)var label = new DepthFirstSearch()var select = new InputOrderSelect(store, ALL, new IndomainMin())label.labeling(store, select) There are some slight differences in this API, but nearly everything has a one-to-one correspondence to what we saw earlier. We are explicitly selecting search strategies and selection strategies here whereas with Choco, defaults were chosen for us. In both cases, explicit creation of such classes allows the strategies to be altered for particular scenarios if needed. When run, the output looks like this: Labeling has finished with return value of true DFS1: DFS([S = 9, E = 5, N = 6, D = 7, M = 1, O = 0, R = 8, Y = 2], InputOrder, (org.jacop.search.IndomainMin@45394b31)) We can see here the code is very similar as is the execution time. OR-Tools We can repeat the solution using OR-Tools. Here is the code: Loader.loadNativeLibraries()new Solver(&#39;Send+More=Money&#39;).with { def s = makeIntVar(1, 9, &#39;s&#39;) def e = makeIntVar(0, 9, &#39;e&#39;) def n = makeIntVar(0, 9, &#39;n&#39;) def d = makeIntVar(0, 9, &#39;d&#39;) def m = makeIntVar(1, 9, &#39;m&#39;) def o = makeIntVar(0, 9, &#39;o&#39;) def r = makeIntVar(0, 9, &#39;r&#39;) def y = makeIntVar(0, 9, &#39;y&#39;) IntVar[] all = [s, e, n, d, m, o, r, y] IntVar[] scalar = [s, e, n, d, m, o, r, e, m, o, n, e, y] int[] coeffs = [ 1000, 100, 10, 1, // S E N D + 1000, 100, 10, 1, // M O R E = -10000, -1000, -100, -10, -1 // M O N E Y ] addConstraint(makeScalProdEquality(scalar, coeffs, 0)) addConstraint(makeAllDifferent(all)) def db = makePhase(all, INT_VAR_DEFAULT, INT_VALUE_DEFAULT) newSearch(db) while (nextSolution()) { println all.join(&#39; &#39;) } endSearch() // Statistics println &quot;Solutions: ${solutions()}&quot; println &quot;Failures: ${failures()}&quot; println &quot;Branches: ${branches()}&quot; println &quot;Wall time: ${wallTime()}ms&quot;} which has this output: s(9) e(5) n(6) d(7) m(1) o(0) r(8) y(2) Solutions: 1 Failures: 5 Branches: 10 Wall time: 60ms OR-Tools is written in C++ but has interfaces for numerous languages including Java - which is perfect for Groovy use. &lt;h4 style=”font-family: “Helvetica Neue”, Helvetica, Arial, sans-serif; color: rgb(0, 0, 0);”&gt;Choco with JSR331&lt;/h4&gt; It is great to have multiple libraries to pick from but having a standard API can help switching between such libraries. This is where JSR331 comes in. It defines a standard API for interacting with constraint solvers and linear solves. Here we use a JSR331 implementation backed by an earlier version of the Choco library. The code looks like this: import javax.constraints.*ProblemFactory.newProblem(&#39;SEND+MORE=MONEY&#39;).with { def (S, M) = [&#39;S&#39;, &#39;M&#39;].collect { variable(it, 1, 9) } def (E, N, D, O, R, Y) = [&#39;E&#39;, &#39;N&#39;, &#39;D&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;].collect { variable(it, 0, 9) } postAllDifferent(S, E, N, D, M, O, R, Y) Var[] ALL = [ S, E, N, D, M, O, R, E, M, O, N, E, Y] int[] COEFFS = [ 1000, 100, 10, 1, 1000, 100, 10, 1, -10000, -1000, -100, -10, -1] post(COEFFS, ALL, &#39;=&#39;, 0) def solver = getSolver() def solution = solver.findSolution() println solution ?: &#39;No solution&#39; solver.logStats()} It is quite similar to earlier examples but now exclusively uses the JSR331 classes in the javax.constraint package. There are implementations of those classes backed by several implementations. So, indeed it would be possible to swap between them. When run, the output is: Solution #1: S[9] M[1] E[5] N[6] D[7] O[0] R[8] Y[2] Having said that, at the time of writing, JSR331 popularity doesn&#39;t appear to be on the rise. Most folks using constraint programming libraries seem to be using the direct library classes. Indeed, the version of the Choco implementation used by the JSR331 implementation is over 10 years old. Incorporating Carry The scalar product global constraint we have used in the previous examples is very powerful and probably would be our first choice for this problem. We can, however, model constraint programming problems in multiple ways, so let&#39;s look at a solution that avoids that global constraint. Instead, we will develop a model that mirrors how we reasoned about the original TO + GO = OUT problem that we solved by hand. For that, we just considered a column at a time and accounted for the carry. We&#39;ll explicitly introduce variables to hold the carry (0 if no carry, or 1 if there is a carry) into our model. Then we&#39;ll express the mathematical constraints that are applicable for each column. Here is the code: new Model(&quot;SEND+MORE=MONEY&quot;).with { def (S, M) = [&#39;S&#39;, &#39;M&#39;].collect { intVar(it, 1, 9) } def (E, N, D, O, R, Y) = [&#39;E&#39;, &#39;N&#39;, &#39;D&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;].collect { intVar(it, 0, 9) } def C = (0..3).collect{ intVar(&quot;C$it&quot;, 0, 9) } allDifferent(S, E, N, D, M, O, R, Y).post() C[3] .eq(M).post() // C3 C2 C1 C0 C[2].add(S).add(M).eq(O.add(C[3].mul(10))).post() // S E N D C[1].add(E).add(O).eq(N.add(C[2].mul(10))).post() // M O R E C[0].add(N).add(R).eq(E.add(C[1].mul(10))).post() // ------------- D .add(E).eq(Y.add(C[0].mul(10))).post() // M O N E Y println solver.findSolution()} We can see that there is now no scalar product global constraint any more but instead the constraints for each column. When run, the output looks like this: Solution: S=9, M=1, E=5, N=6, D=7, O=0, R=8, Y=2, C0=1, C1=1, C2=0, C3=1, sum_exp_1=9, sum_exp_2=10, (C3*10)=10, sum_exp_3=10, sum_exp_4=6, sum_exp_5=6, (C2*10)=0, sum_exp_6=6, sum_exp_7=7, sum_exp_8=15, (C1*10)=10, sum_exp_9=15, sum_exp_10=12, (C0*10)=10, sum_exp_11=12, We can see that as we were defining our constraints for each column, subexpressions were being created in the model which are reflected in the solution. They are if you like, temporary calculations along the way to getting the answer - or more accurately a snapshot of ever changing temporary calculations. They don&#39;t form part of the answer that interests us, so we would be free to just print out the part of the solution which interests us if we wanted. Creating a DSL The previous example has lots of calls to add and mul methods. We can create a little bit of a DSL to provide some syntactic sugar to our previous examples to allow use of Groovy&#39;s operator overloading, support ranges when specifying the domain of a variable, and a few other niceties. Our code becomes: model(&quot;SEND+MORE=MONEY&quot;) { def (S, M) = [&#39;S&#39;, &#39;M&#39;].collect { intVar(it, 1..9) } def (E, N, D, O, R, Y) = [&#39;E&#39;, &#39;N&#39;, &#39;D&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;].collect { intVar(it, 0..9) } def C = intVarArray(4, 0..1) [allDifferent(S, E, N, D, M, O, R, Y), // C3 C2 C1 C0 C[3] .eq(M), // S E N D (C[2] + S + M).eq(O + C[3] * 10), // M O R E (C[1] + E + O).eq(N + C[2] * 10), // ------------- (C[0] + N + R).eq(E + C[1] * 10), // M O N E Y (D + E).eq(Y + C[0] * 10)]*.post() println solver.findSolution()} It has the same output as previously. You might wonder how the solver finds the solution. You can watch the variables in the debugger and use tools like choco-cpviz&nbsp;but it is a quite convoluted process until you are used to it. We&#39;ll try to give you a flavor of what is going on here. Basically, there will be various steps of pruning wherever possible and branching with possible backtracking. Below are some snapshots for our example above. To start with, we have nearly 90 light green squares which represents our problem search space. We walk our way through the rules looking for ways to prune the search space: As we are locking in the value of variables, we can substitute them into and simplify our constraints. When we reapply them, they will be quicker to evaluate and may reveal more information. At this point we only have 2 of our variables locked down but our search space is nearly half what we started with and we have simplified some of our constraints. We would continue branching and solving at this point until we find our solution or determine that no solution is possible. Looking at other languages The example repo also contains solutions for this problem in other languages so you can compare and contrast including Clojure, Haskell (Frege), Java, JavaScript (Nashorn), Ruby (JRuby), Python (Jython), Kotlin, Lua (Luaj), Prolog (tuprolog), and Scala. Other examples To wrap up, let&#39;s look at solving a few more examples (using Choco). We&#39;ll solve some of the examples from an interesting blog on the history of Cryptarithmetic problems: ABCD * 4 = DCBA AA + BB + CC = ABC HALF + HALF = WHOLE HALF + FIFTH + TENTH + TENTH + TENTH = WHOLE Here is the code: new Model(&quot;ABCD*4=DCBA&quot;).with { def (A, D) = [&#39;A&#39;, &#39;D&#39;].collect { intVar(it, 1, 9) } def (B, C) = [&#39;B&#39;, &#39;C&#39;].collect { intVar(it, 0, 9) } def R = (0..2).collect { intVar(0, 9) } allDifferent(A, B, C, D).post() R[2].add(A.mul(4)).eq(D).post() R[1].add(B.mul(4)).eq(C.add(R[2].mul(10))).post() R[0].add(C.mul(4)).eq(B.add(R[1].mul(10))).post() D.mul(4).eq(A.add(R[0].mul(10))).post() solver.findAllSolutions().each { println &quot;$name: ${pretty(it, [A, B, C, D, &#39; * 4 = &#39;, D, C, B, A])}\n$it\n&quot; }}new Model(&quot;AA+BB+CC=ABC&quot;).with { def (A, B, C) = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;].collect { intVar(it, 1, 9) } allDifferent(A, B, C).post() A.mul(11).add(B.mul(11).add(C.mul(11))).eq(A.mul(100).add(B.mul(10)).add(C)).post() solver.findAllSolutions().each { println &quot;$name: ${pretty(it, [A, A, &#39; + &#39;, B, B, &#39; + &#39;, C, C, &#39; = &#39;, A, B, C])}\n$it\n&quot; }}new Model(&quot;HALF+HALF=WHOLE&quot;).with { def (H, W) = [&#39;H&#39;, &#39;W&#39;].collect { intVar(it, 1, 9) } def (A, E, F, L, O) = [&#39;A&#39;, &#39;E&#39;, &#39;F&#39;, &#39;L&#39;, &#39;O&#39;].collect { intVar(it, 0, 9) } allDifferent(H, W, A, E, F, L, O).post() IntVar[] ALL = [ H, A, L, F, W, H, O, L, E] int[] COEFFS = [ 2000, 200, 20, 2, -10000, -1000, -100, -10, -1] scalar(ALL, COEFFS, &quot;=&quot;, 0).post() solver.findAllSolutions().each { println &quot;$name: ${pretty(it, [H, A, L, F, &#39; + &#39;, H, A, L, F, &#39; = &#39;, W, H, O, L, E])}\n$it\n&quot; }}new Model(&quot;HALF+FIFTH+TENTH+TENTH+TENTH=WHOLE&quot;).with { def (H, F, T, W) = [&#39;H&#39;, &#39;F&#39;, &#39;T&#39;, &#39;W&#39;].collect { intVar(it, 1, 9) } def (A, L, I, E, N, O) = [&#39;A&#39;, &#39;L&#39;, &#39;I&#39;, &#39;E&#39;, &#39;N&#39;, &#39;O&#39;].collect { intVar(it, 0, 9) } allDifferent(H, F, T, W, A, L, I, E, N, O).post() IntVar[] ALL = [ H, A, L, F, F, I, F, T, H, T, E, N, T, H, T, E, N, T, H, T, E, N, T, H, W, H, O, L, E] int[] COEFFS = [ 1000, 100, 10, 1, 10000, 1000, 100, 10, 1, 10000, 1000, 100, 10, 1, 10000, 1000, 100, 10, 1, 10000, 1000, 100, 10, 1, -10000, -1000, -100, -10, -1] scalar(ALL, COEFFS, &quot;=&quot;, 0).post() solver.findAllSolutions().each { def parts = [H, A, L, F, &#39;+&#39;, F, I, F, T, H, &#39;+&#39;, T, E, N, T, H, &#39;+&#39;, T, E, N, T, H, &#39;+&#39;, T, E, N, T, H, &#39;=&#39;, W, H, O, L, E] println &quot;$name: ${pretty(it, parts)}\n$it\n&quot; }}// helper method to print solutionsdef pretty(model, parts) { parts.collect { p -&gt; p instanceof IntVar ? model.getIntVal(p) : p }.join()} which has this output: ABCD*4=DCBA: 2178 * 4 = 8712 Solution: A=2, D=8, B=1, C=7, IV_1=3, IV_2=3, IV_3=0, (A*4)=8, sum_exp_4=8, (B*4)=4, ..., AA+BB+CC=ABC: 11 + 99 + 88 = 198 Solution: A=1, B=9, C=8, (A*11)=11, (B*11)=99, (C*11)=88, ..., HALF+HALF=WHOLE: 9604 + 9604 = 19208 Solution: H=9, W=1, A=6, E=8, F=4, L=0, O=2, HALF+HALF=WHOLE: 9703 + 9703 = 19406 Solution: H=9, W=1, A=7, E=6, F=3, L=0, O=4, HALF+HALF=WHOLE: 9802 + 9802 = 19604 Solution: H=9, W=1, A=8, E=4, F=2, L=0, O=6, HALF+FIFTH+TENTH+TENTH+TENTH=WHOLE: 6701+14126+25326+25326+25326=96805 Solution: H=6, F=1, T=2, W=9, A=7, L=0, I=4, E=5, N=3, O=8, You should see the common patterns used for solving these puzzles. Further Information JaCoP Java Constraint Programming solver Choco open source library for constraint programming OR-Tools constraint optimization Verbal arithmetic problems described (wikipedia) JSR331&nbsp;Constraint Programming API Github repo containing sample code Conclusion We have looked at using Groovy and a few constraint programming libraries to solve a cryptarithmetic puzzles. Why not try solving some of your own puzzles." />
<meta property="og:description" content="Introduction When writing solutions to problems, we frequently strive to hide away implementation details. In Object-oriented (OO) programming, we might build a rich hierarchy of classes with well-thought out methods so that our final solution can be expressed in terms of simple nouns and verbs (methods and class instances) in our domain model. When applying functional programming idioms, we will strive to emphasise the relationship between inputs and outputs and hide away side effects and iterative steps. Constraint programming (within the same family as logic programming) also strives to hide away details. Instead of expressing an iterative implementation, it focuses on expressing declarative properties of a solution. A solver is responsible for working out the exact implementation steps. When using constraint programming, we develop a model consisting of variables, the domain of values each variable may hold, and additional constraints between the variables. A solver does all the work. It may employ heuristic searching, inference, propagation, symmetry and backtracking to find possible solutions. We may be able to (or want to, or need to) guide the solver as to which techniques and strategies it should use. Constraint programming has been used to solve various kinds of problems including scheduling problems, and excels at problems with combinatorial possibilities that are too irregular for other mathematical optimisations. Frequently used illustrative problems are Sudoku and Wordle solvers, N-Queen problems, and other kinds of puzzles. We&#39;ll just look at cryptarithmetic puzzles. Cryptarithmetic Problems Cryptarithmetic problems (also known as alphametics, verbal arithmetic, cryptarithm, and word addition) are a type of mathematical game where a mathematical equation is presented where digits in the equation are replaced by letters. Traditionally, each letter usually represents a unique number, and numbers don&#39;t start with the digit zero. If we look at one sample problem: &lt;/p&gt; T O + G O = O U T We can reason about what the solution can be by hand: T, O, U, and G must be all different (game rule) T, G, and O will be between 1 and 9, and U is between 0 and 9 (game rule) If we added the two biggest 2-digit numbers, (99 + 99) we&#39;d get 198, so O must be 1 Looking at the right-most &quot;units&quot; column, 1 + 1 equals 2, so T must be 2 Looking at the &quot;tens&quot; column, we know there is a carry of 1 (since O is 1) and we know T is 2, so G must be 8 or 9. If G was 9, U would be 1 but it can&#39;t be the same as O, so G must be 8 and U must be 0. When solving by hand, we typically reason about individual columns and account for the &quot;carry&quot; to the next column. We&#39;ll come back to this point later but first, let&#39;s look at a slightly bigger problem: S E N D + M O R E = M O N E Y Solving with Brute Force This problem isn&#39;t huge, so we can solve with brute force. We simply try all possible values for the letters in the puzzle: for (s in 1..9) for (e in 0..9) for (n in 0..9) for (d in 0..9) for (m in 1..9) for (o in 0..9) for (r in 0..9) for (y in 0..9) if ([s, e, n, d, m, o, r, y].toSet().size() == 8) { def send = 1000 * s + 100 * e + 10 * n + d def more = 1000 * m + 100 * o + 10 * r + e def money = 10000 * m + 1000 * o + 100 * n + 10 * e + y if (send + more == money) { println &quot;s = $s, e = $e, n = $n, d = $d&quot; println &quot;m = $m, o = $o, r = $r, y = $y&quot; } } This isn&#39;t very efficient though. It calculates 81 million combinations for the variables before skipping all but 1.5 million of them (since most won&#39;t be unique). All up it might execute in the low tens of seconds. Alternatively, Groovy supports calculating permutations, so we can simplify our solution to a single for loop (with some tests to eliminate unhelpful iterations): def digits = 0..9for (p in digits.permutations()) { if (p[-1] &lt; p[-2]) continue def (s, e, n, d, m, o, r, y) = p if (s == 0 || m == 0) continue def send = 1000 * s + 100 * e + 10 * n + d def more = 1000 * m + 100 * o + 10 * r + e def money = 10000 * m + 1000 * o + 100 * n + 10 * e + y if (send + more == money) { println &quot;s = $s, e = $e, n = $n, d = $d&quot; println &quot;m = $m, o = $o, r = $r, y = $y&quot; }} This has the advantage of only generating unique combinations. It will execute in seconds. Running either of these solutions yields: s = 9, e = 5, n = 6, d = 7 m = 1, o = 0, r = 8, y = 2 Using Constraint Programming For the brute force approaches, we had a condition which checked any potential candidate answer to see if it was a correct solution. We had to be very explicit in how we wanted the potential candidates to be created. For constraint programming, we instead define variables to represent the problem, any known bounds on those variables, and we specify any other known properties of the solution, which in our case will be something similar to the condition we had to check if the answer was correct previously. Let&#39;s examine how to do that with three libraries, one with a variation. Choco Here is the code using the Choco library: new Model(&quot;SEND+MORE=MONEY&quot;).with { def (S, M) = [&#39;S&#39;, &#39;M&#39;].collect { intVar(it, 1, 9) } def (E, N, D, O, R, Y) = [&#39;E&#39;, &#39;N&#39;, &#39;D&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;].collect { intVar(it, 0, 9) } allDifferent(S, E, N, D, M, O, R, Y).post() IntVar[] ALL = [ S, E, N, D, M, O, R, E, M, O, N, E, Y ] int[] COEFFS = [ 1000, 100, 10, 1, 1000, 100, 10, 1, -10000, -1000, -100, -10, -1 ] scalar(ALL, COEFFS, &quot;=&quot;, 0).post() println solver.findSolution()} We define our variables and their bounds (domain). We use an allDifferent global constraint to specify the uniqueness requirement and a scalar constraint that ensures that our variables multiplied by their respective scalar coefficients equal 0. This lets us factor in whether the particular variable is representing the &quot;units&quot; column, the &quot;10s&quot; column, the &quot;100s&quot; column etc. This captures the &quot;puzzle addition&quot; constraint. We then ask the solver to find the solution. We could just as easily have asked for all solutions (if more than one existed). This is typical of how we solve such problems. We either define constraints directly between one or more variables or use whatever global constraints our library might support. If our library doesn&#39;t support the constraint we need, we find a way to express it using multiple simpler constraints. The end result is that our code is more declarative than our brute force approaches, and the solution is found in tens of milliseconds. The solver has very efficient strategies for solving such puzzles. &lt;h4 style=”font-family: “Helvetica Neue”, Helvetica, Arial, sans-serif; color: rgb(0, 0, 0);”&gt;JaCoP&lt;/h4&gt; We can solve the same problem using JaCoP: def store = new Store()def (S, M) = [&#39;S&#39;, &#39;M&#39;].collect { new IntVar(store, it, 1, 9) }def (E, N, D, O, R, Y) = [&#39;E&#39;, &#39;N&#39;, &#39;D&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;].collect { new IntVar(store, it, 0, 9) }var ctr = new Alldifferent(S, E, N, D, M, O, R, Y)store.impose(ctr)IntVar[] ALL = [ S, E, N, D, M, O, R, E, M, O, N, E, Y ]int[] COEFFS = [ 1000, 100, 10, 1, 1000, 100, 10, 1, -10000, -1000, -100, -10, -1 ]var lin = new LinearInt(ALL, COEFFS, &quot;==&quot;, 0)store.impose(lin)var label = new DepthFirstSearch()var select = new InputOrderSelect(store, ALL, new IndomainMin())label.labeling(store, select) There are some slight differences in this API, but nearly everything has a one-to-one correspondence to what we saw earlier. We are explicitly selecting search strategies and selection strategies here whereas with Choco, defaults were chosen for us. In both cases, explicit creation of such classes allows the strategies to be altered for particular scenarios if needed. When run, the output looks like this: Labeling has finished with return value of true DFS1: DFS([S = 9, E = 5, N = 6, D = 7, M = 1, O = 0, R = 8, Y = 2], InputOrder, (org.jacop.search.IndomainMin@45394b31)) We can see here the code is very similar as is the execution time. OR-Tools We can repeat the solution using OR-Tools. Here is the code: Loader.loadNativeLibraries()new Solver(&#39;Send+More=Money&#39;).with { def s = makeIntVar(1, 9, &#39;s&#39;) def e = makeIntVar(0, 9, &#39;e&#39;) def n = makeIntVar(0, 9, &#39;n&#39;) def d = makeIntVar(0, 9, &#39;d&#39;) def m = makeIntVar(1, 9, &#39;m&#39;) def o = makeIntVar(0, 9, &#39;o&#39;) def r = makeIntVar(0, 9, &#39;r&#39;) def y = makeIntVar(0, 9, &#39;y&#39;) IntVar[] all = [s, e, n, d, m, o, r, y] IntVar[] scalar = [s, e, n, d, m, o, r, e, m, o, n, e, y] int[] coeffs = [ 1000, 100, 10, 1, // S E N D + 1000, 100, 10, 1, // M O R E = -10000, -1000, -100, -10, -1 // M O N E Y ] addConstraint(makeScalProdEquality(scalar, coeffs, 0)) addConstraint(makeAllDifferent(all)) def db = makePhase(all, INT_VAR_DEFAULT, INT_VALUE_DEFAULT) newSearch(db) while (nextSolution()) { println all.join(&#39; &#39;) } endSearch() // Statistics println &quot;Solutions: ${solutions()}&quot; println &quot;Failures: ${failures()}&quot; println &quot;Branches: ${branches()}&quot; println &quot;Wall time: ${wallTime()}ms&quot;} which has this output: s(9) e(5) n(6) d(7) m(1) o(0) r(8) y(2) Solutions: 1 Failures: 5 Branches: 10 Wall time: 60ms OR-Tools is written in C++ but has interfaces for numerous languages including Java - which is perfect for Groovy use. &lt;h4 style=”font-family: “Helvetica Neue”, Helvetica, Arial, sans-serif; color: rgb(0, 0, 0);”&gt;Choco with JSR331&lt;/h4&gt; It is great to have multiple libraries to pick from but having a standard API can help switching between such libraries. This is where JSR331 comes in. It defines a standard API for interacting with constraint solvers and linear solves. Here we use a JSR331 implementation backed by an earlier version of the Choco library. The code looks like this: import javax.constraints.*ProblemFactory.newProblem(&#39;SEND+MORE=MONEY&#39;).with { def (S, M) = [&#39;S&#39;, &#39;M&#39;].collect { variable(it, 1, 9) } def (E, N, D, O, R, Y) = [&#39;E&#39;, &#39;N&#39;, &#39;D&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;].collect { variable(it, 0, 9) } postAllDifferent(S, E, N, D, M, O, R, Y) Var[] ALL = [ S, E, N, D, M, O, R, E, M, O, N, E, Y] int[] COEFFS = [ 1000, 100, 10, 1, 1000, 100, 10, 1, -10000, -1000, -100, -10, -1] post(COEFFS, ALL, &#39;=&#39;, 0) def solver = getSolver() def solution = solver.findSolution() println solution ?: &#39;No solution&#39; solver.logStats()} It is quite similar to earlier examples but now exclusively uses the JSR331 classes in the javax.constraint package. There are implementations of those classes backed by several implementations. So, indeed it would be possible to swap between them. When run, the output is: Solution #1: S[9] M[1] E[5] N[6] D[7] O[0] R[8] Y[2] Having said that, at the time of writing, JSR331 popularity doesn&#39;t appear to be on the rise. Most folks using constraint programming libraries seem to be using the direct library classes. Indeed, the version of the Choco implementation used by the JSR331 implementation is over 10 years old. Incorporating Carry The scalar product global constraint we have used in the previous examples is very powerful and probably would be our first choice for this problem. We can, however, model constraint programming problems in multiple ways, so let&#39;s look at a solution that avoids that global constraint. Instead, we will develop a model that mirrors how we reasoned about the original TO + GO = OUT problem that we solved by hand. For that, we just considered a column at a time and accounted for the carry. We&#39;ll explicitly introduce variables to hold the carry (0 if no carry, or 1 if there is a carry) into our model. Then we&#39;ll express the mathematical constraints that are applicable for each column. Here is the code: new Model(&quot;SEND+MORE=MONEY&quot;).with { def (S, M) = [&#39;S&#39;, &#39;M&#39;].collect { intVar(it, 1, 9) } def (E, N, D, O, R, Y) = [&#39;E&#39;, &#39;N&#39;, &#39;D&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;].collect { intVar(it, 0, 9) } def C = (0..3).collect{ intVar(&quot;C$it&quot;, 0, 9) } allDifferent(S, E, N, D, M, O, R, Y).post() C[3] .eq(M).post() // C3 C2 C1 C0 C[2].add(S).add(M).eq(O.add(C[3].mul(10))).post() // S E N D C[1].add(E).add(O).eq(N.add(C[2].mul(10))).post() // M O R E C[0].add(N).add(R).eq(E.add(C[1].mul(10))).post() // ------------- D .add(E).eq(Y.add(C[0].mul(10))).post() // M O N E Y println solver.findSolution()} We can see that there is now no scalar product global constraint any more but instead the constraints for each column. When run, the output looks like this: Solution: S=9, M=1, E=5, N=6, D=7, O=0, R=8, Y=2, C0=1, C1=1, C2=0, C3=1, sum_exp_1=9, sum_exp_2=10, (C3*10)=10, sum_exp_3=10, sum_exp_4=6, sum_exp_5=6, (C2*10)=0, sum_exp_6=6, sum_exp_7=7, sum_exp_8=15, (C1*10)=10, sum_exp_9=15, sum_exp_10=12, (C0*10)=10, sum_exp_11=12, We can see that as we were defining our constraints for each column, subexpressions were being created in the model which are reflected in the solution. They are if you like, temporary calculations along the way to getting the answer - or more accurately a snapshot of ever changing temporary calculations. They don&#39;t form part of the answer that interests us, so we would be free to just print out the part of the solution which interests us if we wanted. Creating a DSL The previous example has lots of calls to add and mul methods. We can create a little bit of a DSL to provide some syntactic sugar to our previous examples to allow use of Groovy&#39;s operator overloading, support ranges when specifying the domain of a variable, and a few other niceties. Our code becomes: model(&quot;SEND+MORE=MONEY&quot;) { def (S, M) = [&#39;S&#39;, &#39;M&#39;].collect { intVar(it, 1..9) } def (E, N, D, O, R, Y) = [&#39;E&#39;, &#39;N&#39;, &#39;D&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;].collect { intVar(it, 0..9) } def C = intVarArray(4, 0..1) [allDifferent(S, E, N, D, M, O, R, Y), // C3 C2 C1 C0 C[3] .eq(M), // S E N D (C[2] + S + M).eq(O + C[3] * 10), // M O R E (C[1] + E + O).eq(N + C[2] * 10), // ------------- (C[0] + N + R).eq(E + C[1] * 10), // M O N E Y (D + E).eq(Y + C[0] * 10)]*.post() println solver.findSolution()} It has the same output as previously. You might wonder how the solver finds the solution. You can watch the variables in the debugger and use tools like choco-cpviz&nbsp;but it is a quite convoluted process until you are used to it. We&#39;ll try to give you a flavor of what is going on here. Basically, there will be various steps of pruning wherever possible and branching with possible backtracking. Below are some snapshots for our example above. To start with, we have nearly 90 light green squares which represents our problem search space. We walk our way through the rules looking for ways to prune the search space: As we are locking in the value of variables, we can substitute them into and simplify our constraints. When we reapply them, they will be quicker to evaluate and may reveal more information. At this point we only have 2 of our variables locked down but our search space is nearly half what we started with and we have simplified some of our constraints. We would continue branching and solving at this point until we find our solution or determine that no solution is possible. Looking at other languages The example repo also contains solutions for this problem in other languages so you can compare and contrast including Clojure, Haskell (Frege), Java, JavaScript (Nashorn), Ruby (JRuby), Python (Jython), Kotlin, Lua (Luaj), Prolog (tuprolog), and Scala. Other examples To wrap up, let&#39;s look at solving a few more examples (using Choco). We&#39;ll solve some of the examples from an interesting blog on the history of Cryptarithmetic problems: ABCD * 4 = DCBA AA + BB + CC = ABC HALF + HALF = WHOLE HALF + FIFTH + TENTH + TENTH + TENTH = WHOLE Here is the code: new Model(&quot;ABCD*4=DCBA&quot;).with { def (A, D) = [&#39;A&#39;, &#39;D&#39;].collect { intVar(it, 1, 9) } def (B, C) = [&#39;B&#39;, &#39;C&#39;].collect { intVar(it, 0, 9) } def R = (0..2).collect { intVar(0, 9) } allDifferent(A, B, C, D).post() R[2].add(A.mul(4)).eq(D).post() R[1].add(B.mul(4)).eq(C.add(R[2].mul(10))).post() R[0].add(C.mul(4)).eq(B.add(R[1].mul(10))).post() D.mul(4).eq(A.add(R[0].mul(10))).post() solver.findAllSolutions().each { println &quot;$name: ${pretty(it, [A, B, C, D, &#39; * 4 = &#39;, D, C, B, A])}\n$it\n&quot; }}new Model(&quot;AA+BB+CC=ABC&quot;).with { def (A, B, C) = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;].collect { intVar(it, 1, 9) } allDifferent(A, B, C).post() A.mul(11).add(B.mul(11).add(C.mul(11))).eq(A.mul(100).add(B.mul(10)).add(C)).post() solver.findAllSolutions().each { println &quot;$name: ${pretty(it, [A, A, &#39; + &#39;, B, B, &#39; + &#39;, C, C, &#39; = &#39;, A, B, C])}\n$it\n&quot; }}new Model(&quot;HALF+HALF=WHOLE&quot;).with { def (H, W) = [&#39;H&#39;, &#39;W&#39;].collect { intVar(it, 1, 9) } def (A, E, F, L, O) = [&#39;A&#39;, &#39;E&#39;, &#39;F&#39;, &#39;L&#39;, &#39;O&#39;].collect { intVar(it, 0, 9) } allDifferent(H, W, A, E, F, L, O).post() IntVar[] ALL = [ H, A, L, F, W, H, O, L, E] int[] COEFFS = [ 2000, 200, 20, 2, -10000, -1000, -100, -10, -1] scalar(ALL, COEFFS, &quot;=&quot;, 0).post() solver.findAllSolutions().each { println &quot;$name: ${pretty(it, [H, A, L, F, &#39; + &#39;, H, A, L, F, &#39; = &#39;, W, H, O, L, E])}\n$it\n&quot; }}new Model(&quot;HALF+FIFTH+TENTH+TENTH+TENTH=WHOLE&quot;).with { def (H, F, T, W) = [&#39;H&#39;, &#39;F&#39;, &#39;T&#39;, &#39;W&#39;].collect { intVar(it, 1, 9) } def (A, L, I, E, N, O) = [&#39;A&#39;, &#39;L&#39;, &#39;I&#39;, &#39;E&#39;, &#39;N&#39;, &#39;O&#39;].collect { intVar(it, 0, 9) } allDifferent(H, F, T, W, A, L, I, E, N, O).post() IntVar[] ALL = [ H, A, L, F, F, I, F, T, H, T, E, N, T, H, T, E, N, T, H, T, E, N, T, H, W, H, O, L, E] int[] COEFFS = [ 1000, 100, 10, 1, 10000, 1000, 100, 10, 1, 10000, 1000, 100, 10, 1, 10000, 1000, 100, 10, 1, 10000, 1000, 100, 10, 1, -10000, -1000, -100, -10, -1] scalar(ALL, COEFFS, &quot;=&quot;, 0).post() solver.findAllSolutions().each { def parts = [H, A, L, F, &#39;+&#39;, F, I, F, T, H, &#39;+&#39;, T, E, N, T, H, &#39;+&#39;, T, E, N, T, H, &#39;+&#39;, T, E, N, T, H, &#39;=&#39;, W, H, O, L, E] println &quot;$name: ${pretty(it, parts)}\n$it\n&quot; }}// helper method to print solutionsdef pretty(model, parts) { parts.collect { p -&gt; p instanceof IntVar ? model.getIntVal(p) : p }.join()} which has this output: ABCD*4=DCBA: 2178 * 4 = 8712 Solution: A=2, D=8, B=1, C=7, IV_1=3, IV_2=3, IV_3=0, (A*4)=8, sum_exp_4=8, (B*4)=4, ..., AA+BB+CC=ABC: 11 + 99 + 88 = 198 Solution: A=1, B=9, C=8, (A*11)=11, (B*11)=99, (C*11)=88, ..., HALF+HALF=WHOLE: 9604 + 9604 = 19208 Solution: H=9, W=1, A=6, E=8, F=4, L=0, O=2, HALF+HALF=WHOLE: 9703 + 9703 = 19406 Solution: H=9, W=1, A=7, E=6, F=3, L=0, O=4, HALF+HALF=WHOLE: 9802 + 9802 = 19604 Solution: H=9, W=1, A=8, E=4, F=2, L=0, O=6, HALF+FIFTH+TENTH+TENTH+TENTH=WHOLE: 6701+14126+25326+25326+25326=96805 Solution: H=6, F=1, T=2, W=9, A=7, L=0, I=4, E=5, N=3, O=8, You should see the common patterns used for solving these puzzles. Further Information JaCoP Java Constraint Programming solver Choco open source library for constraint programming OR-Tools constraint optimization Verbal arithmetic problems described (wikipedia) JSR331&nbsp;Constraint Programming API Github repo containing sample code Conclusion We have looked at using Groovy and a few constraint programming libraries to solve a cryptarithmetic puzzles. Why not try solving some of your own puzzles." />
<link rel="canonical" href="http://localhost:4000/groovy/entry/solving-cryptarithmetic-puzzles-with-groovy" />
<meta property="og:url" content="http://localhost:4000/groovy/entry/solving-cryptarithmetic-puzzles-with-groovy" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-09-05T13:43:31-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Solving cryptarithmetic puzzles with Groovy and constraint programming using Choco, JaCoP, and OR-Tools" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-05T13:43:31-04:00","datePublished":"2022-09-05T13:43:31-04:00","description":"Introduction When writing solutions to problems, we frequently strive to hide away implementation details. In Object-oriented (OO) programming, we might build a rich hierarchy of classes with well-thought out methods so that our final solution can be expressed in terms of simple nouns and verbs (methods and class instances) in our domain model. When applying functional programming idioms, we will strive to emphasise the relationship between inputs and outputs and hide away side effects and iterative steps. Constraint programming (within the same family as logic programming) also strives to hide away details. Instead of expressing an iterative implementation, it focuses on expressing declarative properties of a solution. A solver is responsible for working out the exact implementation steps. When using constraint programming, we develop a model consisting of variables, the domain of values each variable may hold, and additional constraints between the variables. A solver does all the work. It may employ heuristic searching, inference, propagation, symmetry and backtracking to find possible solutions. We may be able to (or want to, or need to) guide the solver as to which techniques and strategies it should use. Constraint programming has been used to solve various kinds of problems including scheduling problems, and excels at problems with combinatorial possibilities that are too irregular for other mathematical optimisations. Frequently used illustrative problems are Sudoku and Wordle solvers, N-Queen problems, and other kinds of puzzles. We&#39;ll just look at cryptarithmetic puzzles. Cryptarithmetic Problems Cryptarithmetic problems (also known as alphametics, verbal arithmetic, cryptarithm, and word addition) are a type of mathematical game where a mathematical equation is presented where digits in the equation are replaced by letters. Traditionally, each letter usually represents a unique number, and numbers don&#39;t start with the digit zero. If we look at one sample problem: &lt;/p&gt; T O + G O = O U T We can reason about what the solution can be by hand: T, O, U, and G must be all different (game rule) T, G, and O will be between 1 and 9, and U is between 0 and 9 (game rule) If we added the two biggest 2-digit numbers, (99 + 99) we&#39;d get 198, so O must be 1 Looking at the right-most &quot;units&quot; column, 1 + 1 equals 2, so T must be 2 Looking at the &quot;tens&quot; column, we know there is a carry of 1 (since O is 1) and we know T is 2, so G must be 8 or 9. If G was 9, U would be 1 but it can&#39;t be the same as O, so G must be 8 and U must be 0. When solving by hand, we typically reason about individual columns and account for the &quot;carry&quot; to the next column. We&#39;ll come back to this point later but first, let&#39;s look at a slightly bigger problem: S E N D + M O R E = M O N E Y Solving with Brute Force This problem isn&#39;t huge, so we can solve with brute force. We simply try all possible values for the letters in the puzzle: for (s in 1..9) for (e in 0..9) for (n in 0..9) for (d in 0..9) for (m in 1..9) for (o in 0..9) for (r in 0..9) for (y in 0..9) if ([s, e, n, d, m, o, r, y].toSet().size() == 8) { def send = 1000 * s + 100 * e + 10 * n + d def more = 1000 * m + 100 * o + 10 * r + e def money = 10000 * m + 1000 * o + 100 * n + 10 * e + y if (send + more == money) { println &quot;s = $s, e = $e, n = $n, d = $d&quot; println &quot;m = $m, o = $o, r = $r, y = $y&quot; } } This isn&#39;t very efficient though. It calculates 81 million combinations for the variables before skipping all but 1.5 million of them (since most won&#39;t be unique). All up it might execute in the low tens of seconds. Alternatively, Groovy supports calculating permutations, so we can simplify our solution to a single for loop (with some tests to eliminate unhelpful iterations): def digits = 0..9for (p in digits.permutations()) { if (p[-1] &lt; p[-2]) continue def (s, e, n, d, m, o, r, y) = p if (s == 0 || m == 0) continue def send = 1000 * s + 100 * e + 10 * n + d def more = 1000 * m + 100 * o + 10 * r + e def money = 10000 * m + 1000 * o + 100 * n + 10 * e + y if (send + more == money) { println &quot;s = $s, e = $e, n = $n, d = $d&quot; println &quot;m = $m, o = $o, r = $r, y = $y&quot; }} This has the advantage of only generating unique combinations. It will execute in seconds. Running either of these solutions yields: s = 9, e = 5, n = 6, d = 7 m = 1, o = 0, r = 8, y = 2 Using Constraint Programming For the brute force approaches, we had a condition which checked any potential candidate answer to see if it was a correct solution. We had to be very explicit in how we wanted the potential candidates to be created. For constraint programming, we instead define variables to represent the problem, any known bounds on those variables, and we specify any other known properties of the solution, which in our case will be something similar to the condition we had to check if the answer was correct previously. Let&#39;s examine how to do that with three libraries, one with a variation. Choco Here is the code using the Choco library: new Model(&quot;SEND+MORE=MONEY&quot;).with { def (S, M) = [&#39;S&#39;, &#39;M&#39;].collect { intVar(it, 1, 9) } def (E, N, D, O, R, Y) = [&#39;E&#39;, &#39;N&#39;, &#39;D&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;].collect { intVar(it, 0, 9) } allDifferent(S, E, N, D, M, O, R, Y).post() IntVar[] ALL = [ S, E, N, D, M, O, R, E, M, O, N, E, Y ] int[] COEFFS = [ 1000, 100, 10, 1, 1000, 100, 10, 1, -10000, -1000, -100, -10, -1 ] scalar(ALL, COEFFS, &quot;=&quot;, 0).post() println solver.findSolution()} We define our variables and their bounds (domain). We use an allDifferent global constraint to specify the uniqueness requirement and a scalar constraint that ensures that our variables multiplied by their respective scalar coefficients equal 0. This lets us factor in whether the particular variable is representing the &quot;units&quot; column, the &quot;10s&quot; column, the &quot;100s&quot; column etc. This captures the &quot;puzzle addition&quot; constraint. We then ask the solver to find the solution. We could just as easily have asked for all solutions (if more than one existed). This is typical of how we solve such problems. We either define constraints directly between one or more variables or use whatever global constraints our library might support. If our library doesn&#39;t support the constraint we need, we find a way to express it using multiple simpler constraints. The end result is that our code is more declarative than our brute force approaches, and the solution is found in tens of milliseconds. The solver has very efficient strategies for solving such puzzles. &lt;h4 style=”font-family: “Helvetica Neue”, Helvetica, Arial, sans-serif; color: rgb(0, 0, 0);”&gt;JaCoP&lt;/h4&gt; We can solve the same problem using JaCoP: def store = new Store()def (S, M) = [&#39;S&#39;, &#39;M&#39;].collect { new IntVar(store, it, 1, 9) }def (E, N, D, O, R, Y) = [&#39;E&#39;, &#39;N&#39;, &#39;D&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;].collect { new IntVar(store, it, 0, 9) }var ctr = new Alldifferent(S, E, N, D, M, O, R, Y)store.impose(ctr)IntVar[] ALL = [ S, E, N, D, M, O, R, E, M, O, N, E, Y ]int[] COEFFS = [ 1000, 100, 10, 1, 1000, 100, 10, 1, -10000, -1000, -100, -10, -1 ]var lin = new LinearInt(ALL, COEFFS, &quot;==&quot;, 0)store.impose(lin)var label = new DepthFirstSearch()var select = new InputOrderSelect(store, ALL, new IndomainMin())label.labeling(store, select) There are some slight differences in this API, but nearly everything has a one-to-one correspondence to what we saw earlier. We are explicitly selecting search strategies and selection strategies here whereas with Choco, defaults were chosen for us. In both cases, explicit creation of such classes allows the strategies to be altered for particular scenarios if needed. When run, the output looks like this: Labeling has finished with return value of true DFS1: DFS([S = 9, E = 5, N = 6, D = 7, M = 1, O = 0, R = 8, Y = 2], InputOrder, (org.jacop.search.IndomainMin@45394b31)) We can see here the code is very similar as is the execution time. OR-Tools We can repeat the solution using OR-Tools. Here is the code: Loader.loadNativeLibraries()new Solver(&#39;Send+More=Money&#39;).with { def s = makeIntVar(1, 9, &#39;s&#39;) def e = makeIntVar(0, 9, &#39;e&#39;) def n = makeIntVar(0, 9, &#39;n&#39;) def d = makeIntVar(0, 9, &#39;d&#39;) def m = makeIntVar(1, 9, &#39;m&#39;) def o = makeIntVar(0, 9, &#39;o&#39;) def r = makeIntVar(0, 9, &#39;r&#39;) def y = makeIntVar(0, 9, &#39;y&#39;) IntVar[] all = [s, e, n, d, m, o, r, y] IntVar[] scalar = [s, e, n, d, m, o, r, e, m, o, n, e, y] int[] coeffs = [ 1000, 100, 10, 1, // S E N D + 1000, 100, 10, 1, // M O R E = -10000, -1000, -100, -10, -1 // M O N E Y ] addConstraint(makeScalProdEquality(scalar, coeffs, 0)) addConstraint(makeAllDifferent(all)) def db = makePhase(all, INT_VAR_DEFAULT, INT_VALUE_DEFAULT) newSearch(db) while (nextSolution()) { println all.join(&#39; &#39;) } endSearch() // Statistics println &quot;Solutions: ${solutions()}&quot; println &quot;Failures: ${failures()}&quot; println &quot;Branches: ${branches()}&quot; println &quot;Wall time: ${wallTime()}ms&quot;} which has this output: s(9) e(5) n(6) d(7) m(1) o(0) r(8) y(2) Solutions: 1 Failures: 5 Branches: 10 Wall time: 60ms OR-Tools is written in C++ but has interfaces for numerous languages including Java - which is perfect for Groovy use. &lt;h4 style=”font-family: “Helvetica Neue”, Helvetica, Arial, sans-serif; color: rgb(0, 0, 0);”&gt;Choco with JSR331&lt;/h4&gt; It is great to have multiple libraries to pick from but having a standard API can help switching between such libraries. This is where JSR331 comes in. It defines a standard API for interacting with constraint solvers and linear solves. Here we use a JSR331 implementation backed by an earlier version of the Choco library. The code looks like this: import javax.constraints.*ProblemFactory.newProblem(&#39;SEND+MORE=MONEY&#39;).with { def (S, M) = [&#39;S&#39;, &#39;M&#39;].collect { variable(it, 1, 9) } def (E, N, D, O, R, Y) = [&#39;E&#39;, &#39;N&#39;, &#39;D&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;].collect { variable(it, 0, 9) } postAllDifferent(S, E, N, D, M, O, R, Y) Var[] ALL = [ S, E, N, D, M, O, R, E, M, O, N, E, Y] int[] COEFFS = [ 1000, 100, 10, 1, 1000, 100, 10, 1, -10000, -1000, -100, -10, -1] post(COEFFS, ALL, &#39;=&#39;, 0) def solver = getSolver() def solution = solver.findSolution() println solution ?: &#39;No solution&#39; solver.logStats()} It is quite similar to earlier examples but now exclusively uses the JSR331 classes in the javax.constraint package. There are implementations of those classes backed by several implementations. So, indeed it would be possible to swap between them. When run, the output is: Solution #1: S[9] M[1] E[5] N[6] D[7] O[0] R[8] Y[2] Having said that, at the time of writing, JSR331 popularity doesn&#39;t appear to be on the rise. Most folks using constraint programming libraries seem to be using the direct library classes. Indeed, the version of the Choco implementation used by the JSR331 implementation is over 10 years old. Incorporating Carry The scalar product global constraint we have used in the previous examples is very powerful and probably would be our first choice for this problem. We can, however, model constraint programming problems in multiple ways, so let&#39;s look at a solution that avoids that global constraint. Instead, we will develop a model that mirrors how we reasoned about the original TO + GO = OUT problem that we solved by hand. For that, we just considered a column at a time and accounted for the carry. We&#39;ll explicitly introduce variables to hold the carry (0 if no carry, or 1 if there is a carry) into our model. Then we&#39;ll express the mathematical constraints that are applicable for each column. Here is the code: new Model(&quot;SEND+MORE=MONEY&quot;).with { def (S, M) = [&#39;S&#39;, &#39;M&#39;].collect { intVar(it, 1, 9) } def (E, N, D, O, R, Y) = [&#39;E&#39;, &#39;N&#39;, &#39;D&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;].collect { intVar(it, 0, 9) } def C = (0..3).collect{ intVar(&quot;C$it&quot;, 0, 9) } allDifferent(S, E, N, D, M, O, R, Y).post() C[3] .eq(M).post() // C3 C2 C1 C0 C[2].add(S).add(M).eq(O.add(C[3].mul(10))).post() // S E N D C[1].add(E).add(O).eq(N.add(C[2].mul(10))).post() // M O R E C[0].add(N).add(R).eq(E.add(C[1].mul(10))).post() // ------------- D .add(E).eq(Y.add(C[0].mul(10))).post() // M O N E Y println solver.findSolution()} We can see that there is now no scalar product global constraint any more but instead the constraints for each column. When run, the output looks like this: Solution: S=9, M=1, E=5, N=6, D=7, O=0, R=8, Y=2, C0=1, C1=1, C2=0, C3=1, sum_exp_1=9, sum_exp_2=10, (C3*10)=10, sum_exp_3=10, sum_exp_4=6, sum_exp_5=6, (C2*10)=0, sum_exp_6=6, sum_exp_7=7, sum_exp_8=15, (C1*10)=10, sum_exp_9=15, sum_exp_10=12, (C0*10)=10, sum_exp_11=12, We can see that as we were defining our constraints for each column, subexpressions were being created in the model which are reflected in the solution. They are if you like, temporary calculations along the way to getting the answer - or more accurately a snapshot of ever changing temporary calculations. They don&#39;t form part of the answer that interests us, so we would be free to just print out the part of the solution which interests us if we wanted. Creating a DSL The previous example has lots of calls to add and mul methods. We can create a little bit of a DSL to provide some syntactic sugar to our previous examples to allow use of Groovy&#39;s operator overloading, support ranges when specifying the domain of a variable, and a few other niceties. Our code becomes: model(&quot;SEND+MORE=MONEY&quot;) { def (S, M) = [&#39;S&#39;, &#39;M&#39;].collect { intVar(it, 1..9) } def (E, N, D, O, R, Y) = [&#39;E&#39;, &#39;N&#39;, &#39;D&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;].collect { intVar(it, 0..9) } def C = intVarArray(4, 0..1) [allDifferent(S, E, N, D, M, O, R, Y), // C3 C2 C1 C0 C[3] .eq(M), // S E N D (C[2] + S + M).eq(O + C[3] * 10), // M O R E (C[1] + E + O).eq(N + C[2] * 10), // ------------- (C[0] + N + R).eq(E + C[1] * 10), // M O N E Y (D + E).eq(Y + C[0] * 10)]*.post() println solver.findSolution()} It has the same output as previously. You might wonder how the solver finds the solution. You can watch the variables in the debugger and use tools like choco-cpviz&nbsp;but it is a quite convoluted process until you are used to it. We&#39;ll try to give you a flavor of what is going on here. Basically, there will be various steps of pruning wherever possible and branching with possible backtracking. Below are some snapshots for our example above. To start with, we have nearly 90 light green squares which represents our problem search space. We walk our way through the rules looking for ways to prune the search space: As we are locking in the value of variables, we can substitute them into and simplify our constraints. When we reapply them, they will be quicker to evaluate and may reveal more information. At this point we only have 2 of our variables locked down but our search space is nearly half what we started with and we have simplified some of our constraints. We would continue branching and solving at this point until we find our solution or determine that no solution is possible. Looking at other languages The example repo also contains solutions for this problem in other languages so you can compare and contrast including Clojure, Haskell (Frege), Java, JavaScript (Nashorn), Ruby (JRuby), Python (Jython), Kotlin, Lua (Luaj), Prolog (tuprolog), and Scala. Other examples To wrap up, let&#39;s look at solving a few more examples (using Choco). We&#39;ll solve some of the examples from an interesting blog on the history of Cryptarithmetic problems: ABCD * 4 = DCBA AA + BB + CC = ABC HALF + HALF = WHOLE HALF + FIFTH + TENTH + TENTH + TENTH = WHOLE Here is the code: new Model(&quot;ABCD*4=DCBA&quot;).with { def (A, D) = [&#39;A&#39;, &#39;D&#39;].collect { intVar(it, 1, 9) } def (B, C) = [&#39;B&#39;, &#39;C&#39;].collect { intVar(it, 0, 9) } def R = (0..2).collect { intVar(0, 9) } allDifferent(A, B, C, D).post() R[2].add(A.mul(4)).eq(D).post() R[1].add(B.mul(4)).eq(C.add(R[2].mul(10))).post() R[0].add(C.mul(4)).eq(B.add(R[1].mul(10))).post() D.mul(4).eq(A.add(R[0].mul(10))).post() solver.findAllSolutions().each { println &quot;$name: ${pretty(it, [A, B, C, D, &#39; * 4 = &#39;, D, C, B, A])}\\n$it\\n&quot; }}new Model(&quot;AA+BB+CC=ABC&quot;).with { def (A, B, C) = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;].collect { intVar(it, 1, 9) } allDifferent(A, B, C).post() A.mul(11).add(B.mul(11).add(C.mul(11))).eq(A.mul(100).add(B.mul(10)).add(C)).post() solver.findAllSolutions().each { println &quot;$name: ${pretty(it, [A, A, &#39; + &#39;, B, B, &#39; + &#39;, C, C, &#39; = &#39;, A, B, C])}\\n$it\\n&quot; }}new Model(&quot;HALF+HALF=WHOLE&quot;).with { def (H, W) = [&#39;H&#39;, &#39;W&#39;].collect { intVar(it, 1, 9) } def (A, E, F, L, O) = [&#39;A&#39;, &#39;E&#39;, &#39;F&#39;, &#39;L&#39;, &#39;O&#39;].collect { intVar(it, 0, 9) } allDifferent(H, W, A, E, F, L, O).post() IntVar[] ALL = [ H, A, L, F, W, H, O, L, E] int[] COEFFS = [ 2000, 200, 20, 2, -10000, -1000, -100, -10, -1] scalar(ALL, COEFFS, &quot;=&quot;, 0).post() solver.findAllSolutions().each { println &quot;$name: ${pretty(it, [H, A, L, F, &#39; + &#39;, H, A, L, F, &#39; = &#39;, W, H, O, L, E])}\\n$it\\n&quot; }}new Model(&quot;HALF+FIFTH+TENTH+TENTH+TENTH=WHOLE&quot;).with { def (H, F, T, W) = [&#39;H&#39;, &#39;F&#39;, &#39;T&#39;, &#39;W&#39;].collect { intVar(it, 1, 9) } def (A, L, I, E, N, O) = [&#39;A&#39;, &#39;L&#39;, &#39;I&#39;, &#39;E&#39;, &#39;N&#39;, &#39;O&#39;].collect { intVar(it, 0, 9) } allDifferent(H, F, T, W, A, L, I, E, N, O).post() IntVar[] ALL = [ H, A, L, F, F, I, F, T, H, T, E, N, T, H, T, E, N, T, H, T, E, N, T, H, W, H, O, L, E] int[] COEFFS = [ 1000, 100, 10, 1, 10000, 1000, 100, 10, 1, 10000, 1000, 100, 10, 1, 10000, 1000, 100, 10, 1, 10000, 1000, 100, 10, 1, -10000, -1000, -100, -10, -1] scalar(ALL, COEFFS, &quot;=&quot;, 0).post() solver.findAllSolutions().each { def parts = [H, A, L, F, &#39;+&#39;, F, I, F, T, H, &#39;+&#39;, T, E, N, T, H, &#39;+&#39;, T, E, N, T, H, &#39;+&#39;, T, E, N, T, H, &#39;=&#39;, W, H, O, L, E] println &quot;$name: ${pretty(it, parts)}\\n$it\\n&quot; }}// helper method to print solutionsdef pretty(model, parts) { parts.collect { p -&gt; p instanceof IntVar ? model.getIntVal(p) : p }.join()} which has this output: ABCD*4=DCBA: 2178 * 4 = 8712 Solution: A=2, D=8, B=1, C=7, IV_1=3, IV_2=3, IV_3=0, (A*4)=8, sum_exp_4=8, (B*4)=4, ..., AA+BB+CC=ABC: 11 + 99 + 88 = 198 Solution: A=1, B=9, C=8, (A*11)=11, (B*11)=99, (C*11)=88, ..., HALF+HALF=WHOLE: 9604 + 9604 = 19208 Solution: H=9, W=1, A=6, E=8, F=4, L=0, O=2, HALF+HALF=WHOLE: 9703 + 9703 = 19406 Solution: H=9, W=1, A=7, E=6, F=3, L=0, O=4, HALF+HALF=WHOLE: 9802 + 9802 = 19604 Solution: H=9, W=1, A=8, E=4, F=2, L=0, O=6, HALF+FIFTH+TENTH+TENTH+TENTH=WHOLE: 6701+14126+25326+25326+25326=96805 Solution: H=6, F=1, T=2, W=9, A=7, L=0, I=4, E=5, N=3, O=8, You should see the common patterns used for solving these puzzles. Further Information JaCoP Java Constraint Programming solver Choco open source library for constraint programming OR-Tools constraint optimization Verbal arithmetic problems described (wikipedia) JSR331&nbsp;Constraint Programming API Github repo containing sample code Conclusion We have looked at using Groovy and a few constraint programming libraries to solve a cryptarithmetic puzzles. Why not try solving some of your own puzzles.","headline":"Solving cryptarithmetic puzzles with Groovy and constraint programming using Choco, JaCoP, and OR-Tools","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/groovy/entry/solving-cryptarithmetic-puzzles-with-groovy"},"url":"http://localhost:4000/groovy/entry/solving-cryptarithmetic-puzzles-with-groovy"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Solving cryptarithmetic puzzles with Groovy and constraint programming using Choco, JaCoP, and OR-Tools</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-09-05T13:43:31-04:00" itemprop="datePublished">Sep 5, 2022
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Paul King", "login"=>"paulk", "email"=>"paulk@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><br></p>
<h3>Introduction</h3>
<p>When writing solutions to problems, we frequently strive to hide away implementation details. In Object-oriented (OO) programming, we might build a rich hierarchy of classes with well-thought out methods so that our final solution can be expressed in terms of simple nouns and verbs (methods and class instances) in our domain model. When applying functional programming idioms, we will strive to emphasise the relationship between inputs and outputs and hide away side effects and iterative steps. <i><a href="https://en.wikipedia.org/wiki/Constraint_programming" target="_blank">Constraint programming</a></i> (within the same family as logic programming) also strives to hide away details. Instead of expressing an iterative implementation, it focuses on expressing declarative properties of a solution. A solver is responsible for working out the exact implementation steps.</p>
<p>When using constraint programming, we develop a model consisting of <i>variables</i>, the <i>domain</i> of values each variable may hold, and additional <i>constraints</i> between the variables. A solver does all the work. It may employ heuristic searching, inference, propagation, symmetry and backtracking to find possible solutions. We may be able to (or want to, or need to) guide the solver as to which techniques and strategies it should use. Constraint programming has been used to solve various kinds of problems including scheduling problems, and excels at problems with combinatorial possibilities that are too irregular for other mathematical optimisations. Frequently used illustrative problems are Sudoku and Wordle solvers, <a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle" target="_blank">N-Queen problems</a>, and other kinds of puzzles. We'll just look at cryptarithmetic puzzles.</p>
<h3>Cryptarithmetic Problems</h3>
<p><a href="https://en.wikipedia.org/wiki/Verbal_arithmetic" target="_blank">Cryptarithmetic problems</a> (also known as alphametics, verbal arithmetic, cryptarithm, and word addition) are a type of mathematical game where a mathematical equation is presented where digits in the equation are replaced by letters. Traditionally, each letter usually represents a unique number, and numbers don't start with the digit zero. If we look at one <a href="https://en.wikipedia.org/wiki/Verbal_arithmetic" target="_blank">sample problem</a>:</p></p>
<table>
<tbody>
<tr>
<td style="text-align:center; padding-top:0px; padding-bottom:0px;"></td>
<td style="text-align:center; padding-top:0px; padding-bottom:0px;"></td>
<td style="text-align:center; padding-top:0px; padding-bottom:0px; font-family: monospace; font-size: 22px;">T</td>
<td style="text-align:center; padding-left:3px; padding-right:3px; font-family: monospace; font-size: 22px;">O</td>
</tr>
<tr style="border-bottom:1pt solid black;">
<td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">+</td>
<td></td>
<td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">G</td>
<td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">O</td>
</tr>
<tr>
<td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">=</td>
<td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">O</td>
<td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">U</td>
<td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">T</td>
</tr>
</tbody>
</table>
<p>We can reason about what the solution can be by hand:</p>
<ul>
<li>T, O, U, and G must be all different (game rule)<br></li>
<li>T, G, and O will be between 1 and 9, and U is between 0 and 9 (game rule)</li>
<li>If we added the two biggest 2-digit numbers, (99 + 99) we'd get 198, so <i><b>O must be 1</b></i></li>
<li>Looking at the right-most "units" column, 1 + 1 equals 2, so <i><b>T must be 2</b></i></li>
<li>Looking at the "tens" column, we know there is a carry of 1 (since O is 1) and we know T is 2, so G must be 8 or 9. If G was 9, U would be 1 but it can't be the same as O, so <i><b>G must be 8</b></i> and <i><b>U must be 0</b></i>.</li>
</ul>
<p>When solving by hand, we typically reason about individual columns and account for the "carry" to the next column. We'll come back to this point later but first, let's look at a slightly bigger problem:</p>
<table>
<tbody>
<tr>
<td style="font-family:monospace; font-size: 22px; text-align:center; padding-top:0px; padding-bottom:0px;"></td>
<td style="text-align:center; padding-top:0px; padding-bottom:0px;"></td>
<td style="font-family:monospace; font-size: 22px; text-align:center; padding-top:0px; padding-bottom:0px;">S</td>
<td style="font-family:monospace; font-size: 22px; text-align:center; padding-top:0px; padding-bottom:0px;">E</td>
<td style="text-align:center; padding-top:0px; padding-bottom:0px; font-family: monospace; font-size: 22px;">N</td>
<td style="text-align:center; padding-left:3px; padding-right:3px; font-family: monospace; font-size: 22px;">D</td>
</tr>
<tr style="border-bottom:1pt solid black;">
<td style="font-family:monospace; font-size: 22px; text-align:center; padding-top:0px; padding-bottom:0px;">+</td>
<td style="text-align:center; padding-top:0px; padding-bottom:0px;"></td>
<td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">M</td>
<td style="font-family:monospace; font-size: 22px; text-align:center; padding-top:0px; padding-bottom:0px;">O</td>
<td style=" text-align:center; padding:3px; font-family:monospace; font-size:22px;">R</td>
<td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">E</td>
</tr>
<tr>
<td style="font-family:monospace; font-size: 22px; text-align:center; padding:3px;">=</td>
<td style="text-align:center; padding:3px; font-family:monospace; font-size: 22px;">M</td>
<td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">O</td>
<td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">N</td>
<td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">E</td>
<td style="font-family:monospace; font-size: 22px; text-align:center; padding:3px;">Y</td>
</tr>
</tbody>
</table>
<h3>Solving with Brute Force</h3>
<p>This problem isn't huge, so we can solve with brute force. We simply try all possible values for the letters in the puzzle:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">for </span>(s <span style="color:#cc7832;">in </span><span style="color:#6897bb;">1</span>..<span style="color:#6897bb;">9</span>)<br>    <span style="color:#cc7832;">for </span>(e <span style="color:#cc7832;">in </span><span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9</span>)<br>        <span style="color:#cc7832;">for </span>(n <span style="color:#cc7832;">in </span><span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9</span>)<br>            <span style="color:#cc7832;">for </span>(d <span style="color:#cc7832;">in </span><span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9</span>)<br>                <span style="color:#cc7832;">for </span>(m <span style="color:#cc7832;">in </span><span style="color:#6897bb;">1</span>..<span style="color:#6897bb;">9</span>)<br>                    <span style="color:#cc7832;">for </span>(o <span style="color:#cc7832;">in </span><span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9</span>)<br>                        <span style="color:#cc7832;">for </span>(r <span style="color:#cc7832;">in </span><span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9</span>)<br>                            <span style="color:#cc7832;">for </span>(y <span style="color:#cc7832;">in </span><span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9</span>)<br>                                <span style="color:#cc7832;">if </span>([s, e, n, d, m, o, r, y].toSet().size() == <span style="color:#6897bb;">8</span>) {<br>                                    <span style="color:#cc7832;">def </span>send = <span style="color:#6897bb;">1000 </span>* s + <span style="color:#6897bb;">100 </span>* e + <span style="color:#6897bb;">10 </span>* n + d<br>                                    <span style="color:#cc7832;">def </span>more = <span style="color:#6897bb;">1000 </span>* m + <span style="color:#6897bb;">100 </span>* o + <span style="color:#6897bb;">10 </span>* r + e<br>                                    <span style="color:#cc7832;">def </span>money = <span style="color:#6897bb;">10000 </span>* m + <span style="color:#6897bb;">1000 </span>* o + <span style="color:#6897bb;">100 </span>* n + <span style="color:#6897bb;">10 </span>* e + y<br>                                    <span style="color:#cc7832;">if </span>(send + more == money) {<br>                                        println <span style="color:#6a8759;">"s = </span>$s<span style="color:#6a8759;">, e = </span>$e<span style="color:#6a8759;">, n = </span>$n<span style="color:#6a8759;">, d = </span>$d<span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">                                        </span>println <span style="color:#6a8759;">"m = </span>$m<span style="color:#6a8759;">, o = </span>$o<span style="color:#6a8759;">, r = </span>$r<span style="color:#6a8759;">, y = </span>$y<span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">                                    </span>}<br>                                }<br></pre>
<p>This isn't very efficient though. It calculates 81 million combinations for the variables before skipping all but 1.5 million of them (since most won't be unique). All up it might execute in the low tens of seconds.</p>
<p>Alternatively, Groovy supports calculating permutations, so we can simplify our solution to a single for loop (with some tests to eliminate unhelpful iterations):</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>digits = <span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9<br></span><span style="color:#cc7832;">for </span>(p <span style="color:#cc7832;">in </span>digits.permutations()) {<br>    <span style="color:#cc7832;">if </span>(p[-<span style="color:#6897bb;">1</span>] < p[-<span style="color:#6897bb;">2</span>]) <span style="color:#cc7832;">continue<br></span><span style="color:#cc7832;">    def </span>(s, e, n, d, m, o, r, y) = p<br>    <span style="color:#cc7832;">if </span>(s == <span style="color:#6897bb;">0 </span>|| m == <span style="color:#6897bb;">0</span>) <span style="color:#cc7832;">continue<br></span><span style="color:#cc7832;">    def </span>send = <span style="color:#6897bb;">1000 </span>* s + <span style="color:#6897bb;">100 </span>* e + <span style="color:#6897bb;">10 </span>* n + d<br>    <span style="color:#cc7832;">def </span>more = <span style="color:#6897bb;">1000 </span>* m + <span style="color:#6897bb;">100 </span>* o + <span style="color:#6897bb;">10 </span>* r + e<br>    <span style="color:#cc7832;">def </span>money = <span style="color:#6897bb;">10000 </span>* m + <span style="color:#6897bb;">1000 </span>* o + <span style="color:#6897bb;">100 </span>* n + <span style="color:#6897bb;">10 </span>* e + y<br>    <span style="color:#cc7832;">if </span>(send + more == money) {<br>        println <span style="color:#6a8759;">"s = </span>$s<span style="color:#6a8759;">, e = </span>$e<span style="color:#6a8759;">, n = </span>$n<span style="color:#6a8759;">, d = </span>$d<span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">        </span>println <span style="color:#6a8759;">"m = </span>$m<span style="color:#6a8759;">, o = </span>$o<span style="color:#6a8759;">, r = </span>$r<span style="color:#6a8759;">, y = </span>$y<span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>}<br>}<br></pre>
<p>This has the advantage of only generating unique combinations. It will execute in seconds.</p>
<p>Running either of these solutions yields:</p>
<pre>s = 9, e = 5, n = 6, d = 7
m = 1, o = 0, r = 8, y = 2
</pre>
<h3>Using Constraint Programming</h3>
<p>For the brute force approaches, we had a condition which checked any potential candidate answer to see if it was a correct solution. We had to be very explicit in how we wanted the potential candidates to be created. For constraint programming, we instead define variables to represent the problem, any known bounds on those variables, and we specify any other known properties of the solution, which in our case will be something similar to the condition we had to check if the answer was correct previously. Let's examine how to do that with three libraries, one with a variation.</p>
<h4>Choco</h4>
<p>Here is the code using the <a href="https://choco-solver.org/" target="_blank">Choco</a> library:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">new </span>Model(<span style="color:#6a8759;">"SEND+MORE=MONEY"</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(S, M) = [<span style="color:#6a8759;">'S'</span>, <span style="color:#6a8759;">'M'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(E, N, D, O, R, Y) = [<span style="color:#6a8759;">'E'</span>, <span style="color:#6a8759;">'N'</span>, <span style="color:#6a8759;">'D'</span>, <span style="color:#6a8759;">'O'</span>, <span style="color:#6a8759;">'R'</span>, <span style="color:#6a8759;">'Y'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="font-weight:bold;">    </span>allDifferent(S, E, N, D, M, O, R, Y).post()<br><br><span style="color:#808080;">    </span>IntVar[] ALL = [<br>            S, E, N, D,<br>            M, O, R, E,<br>         M, O, N, E, Y ]<br>    <span style="color:#cc7832;">int</span>[] COEFFS = [<br>            <span style="color:#6897bb;">1000</span>,  <span style="color:#6897bb;">100</span>,  <span style="color:#6897bb;">10</span>,  <span style="color:#6897bb;">1</span>,<br>            <span style="color:#6897bb;">1000</span>,  <span style="color:#6897bb;">100</span>,  <span style="color:#6897bb;">10</span>,  <span style="color:#6897bb;">1</span>,<br>   -<span style="color:#6897bb;">10000</span>, -<span style="color:#6897bb;">1000</span>, -<span style="color:#6897bb;">100</span>, -<span style="color:#6897bb;">10</span>, -<span style="color:#6897bb;">1 </span>]<br><br>    scalar(ALL, COEFFS, <span style="color:#6a8759;">"="</span>, <span style="color:#6897bb;">0</span>).post()<br><br>    println <span style="color:#9876aa;">solver</span>.findSolution()<br><span style="font-weight:bold;">}<br></span></pre>
<p>We define our variables and their bounds (domain). We use an <code>allDifferent</code> global constraint to specify the uniqueness requirement and a <code>scalar</code> constraint that ensures that our variables multiplied by their respective scalar coefficients equal 0. This lets us factor in whether the particular variable is representing the "units" column, the "10s" column, the "100s" column etc. This captures the "puzzle addition" constraint. We then ask the solver to find the solution. We could just as easily have asked for all solutions (if more than one existed).</p>
<p>This is typical of how we solve such problems. We either define constraints directly between one or more variables or use whatever global constraints our library might support. If our library doesn't support the constraint we need, we find a way to express it using multiple simpler constraints.</p>
<p>The end result is that our code is more declarative than our brute force approaches, and the solution is found in tens of milliseconds. The solver has very efficient strategies for solving such puzzles.</p>
<h4 style="font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(0, 0, 0);"><span style="color: inherit; font-family: inherit;">JaCoP</span><br></h4>
<p>We can solve the same problem using <a href="https://github.com/radsz/jacop" target="_blank">JaCoP</a>:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>store = <span style="color:#cc7832;">new </span>Store()<br><span style="color:#cc7832;">def </span>(S, M) = [<span style="color:#6a8759;">'S'</span>, <span style="color:#6a8759;">'M'</span>].collect <span style="font-weight:bold;">{ </span><span style="color:#cc7832;">new </span>IntVar(store, it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="color:#cc7832;">def </span>(E, N, D, O, R, Y) = [<span style="color:#6a8759;">'E'</span>, <span style="color:#6a8759;">'N'</span>, <span style="color:#6a8759;">'D'</span>, <span style="color:#6a8759;">'O'</span>, <span style="color:#6a8759;">'R'</span>, <span style="color:#6a8759;">'Y'</span>].collect <span style="font-weight:bold;">{ </span><span style="color:#cc7832;">new </span>IntVar(store, it, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="color:#cc7832;">var </span>ctr = <span style="color:#cc7832;">new </span>Alldifferent(S, E, N, D, M, O, R, Y)<br>store.impose(ctr)<br><br>IntVar[] ALL = [<br>                S,   E,   N,   D,<br>                M,   O,   R,   E,<br>           M,   O,   N,   E,   Y ]<br><span style="color:#cc7832;">int</span>[] COEFFS = [<br>             <span style="color:#6897bb;">1000</span>,  <span style="color:#6897bb;">100</span>,  <span style="color:#6897bb;">10</span>,  <span style="color:#6897bb;">1</span>,<br>             <span style="color:#6897bb;">1000</span>,  <span style="color:#6897bb;">100</span>,  <span style="color:#6897bb;">10</span>,  <span style="color:#6897bb;">1</span>,<br>    -<span style="color:#6897bb;">10000</span>, -<span style="color:#6897bb;">1000</span>, -<span style="color:#6897bb;">100</span>, -<span style="color:#6897bb;">10</span>, -<span style="color:#6897bb;">1 </span>]<br><span style="color:#cc7832;">var </span>lin = <span style="color:#cc7832;">new </span>LinearInt(ALL, COEFFS, <span style="color:#6a8759;">"=="</span>, <span style="color:#6897bb;">0</span>)<br>store.impose(lin)<br><br><span style="color:#cc7832;">var </span>label = <span style="color:#cc7832;">new </span>DepthFirstSearch()<br><span style="color:#cc7832;">var </span>select = <span style="color:#cc7832;">new </span>InputOrderSelect(store, ALL, <span style="color:#cc7832;">new </span>IndomainMin())<br>label.labeling(store, select)<span style="color:#6a8759;"><br></span></pre>
<p>There are some slight differences in this API, but nearly everything has a one-to-one correspondence to what we saw earlier. We are explicitly selecting search strategies and selection strategies here whereas with Choco, defaults were chosen for us. In both cases, explicit creation of such classes allows the strategies to be altered for particular scenarios if needed.</p>
<p>When run, the output looks like this:</p>
<pre>Labeling has finished with return value of true
DFS1: DFS([S = 9, E = 5, N = 6, D = 7, M = 1, O = 0, R = 8, Y = 2], InputOrder, (org.jacop.search.IndomainMin@45394b31))
</pre>
<p>We can see here the code is very similar as is the execution time.</p>
<h4>OR-Tools</h4>
<p>We can repeat the solution using <a href="https://developers.google.com/optimization/cp" target="_blank">OR-Tools</a>. Here is the code:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">Loader.<span style="color:#9876aa;font-style:italic;">loadNativeLibraries</span>()<br><br><span style="color:#cc7832;">new </span>Solver(<span style="color:#6a8759;">'Send+More=Money'</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>s = makeIntVar(<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'s'</span>)<br>    <span style="color:#cc7832;">def </span>e = makeIntVar(<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'e'</span>)<br>    <span style="color:#cc7832;">def </span>n = makeIntVar(<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'n'</span>)<br>    <span style="color:#cc7832;">def </span>d = makeIntVar(<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'d'</span>)<br>    <span style="color:#cc7832;">def </span>m = makeIntVar(<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'m'</span>)<br>    <span style="color:#cc7832;">def </span>o = makeIntVar(<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'o'</span>)<br>    <span style="color:#cc7832;">def </span>r = makeIntVar(<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'r'</span>)<br>    <span style="color:#cc7832;">def </span>y = makeIntVar(<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'y'</span>)<br><br>    IntVar[] all = [s, e, n, d, m, o, r, y]<br>    IntVar[] scalar = [s, e, n, d, m, o, r, e, m, o, n, e, y]<br>    <span style="color:#cc7832;">int</span>[] coeffs = [<br>                 <span style="color:#6897bb;">1000</span>,  <span style="color:#6897bb;">100</span>,  <span style="color:#6897bb;">10</span>,  <span style="color:#6897bb;">1</span>,  <span style="color:#808080;">//  S E N D +<br></span><span style="color:#808080;">                 </span><span style="color:#6897bb;">1000</span>,  <span style="color:#6897bb;">100</span>,  <span style="color:#6897bb;">10</span>,  <span style="color:#6897bb;">1</span>,  <span style="color:#808080;">//  M O R E =<br></span><span style="color:#808080;">        </span>-<span style="color:#6897bb;">10000</span>, -<span style="color:#6897bb;">1000</span>, -<span style="color:#6897bb;">100</span>, -<span style="color:#6897bb;">10</span>, -<span style="color:#6897bb;">1   </span><span style="color:#808080;">//  M O N E Y<br></span><span style="color:#808080;">    </span>]<br><br>    addConstraint(makeScalProdEquality(scalar, coeffs, <span style="color:#6897bb;">0</span>))<br>    addConstraint(makeAllDifferent(all))<br><br>    <span style="color:#cc7832;">def </span>db = makePhase(all, <span style="color:#9876aa;font-style:italic;">INT_VAR_DEFAULT</span>, <span style="color:#9876aa;font-style:italic;">INT_VALUE_DEFAULT</span>)<br>    newSearch(db)<br>    <span style="color:#cc7832;">while </span>(nextSolution()) {<br>        println all.join(<span style="color:#6a8759;">' '</span>)<br>    }<br>    endSearch()<br><br>    <span style="color:#808080;">// Statistics<br></span><span style="color:#808080;">    </span>println <span style="color:#6a8759;">"Solutions: </span>$<span style="font-weight:bold;">{</span>solutions()<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>println <span style="color:#6a8759;">"Failures: </span>$<span style="font-weight:bold;">{</span>failures()<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>println <span style="color:#6a8759;">"Branches: </span>$<span style="font-weight:bold;">{</span>branches()<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>println <span style="color:#6a8759;">"Wall time: </span>$<span style="font-weight:bold;">{</span>wallTime()<span style="font-weight:bold;">}</span><span style="color:#6a8759;">ms"<br></span><span style="font-weight:bold;">}<br></span></pre>
<p>which has this output:</p>
<pre>s(9) e(5) n(6) d(7) m(1) o(0) r(8) y(2)
Solutions: 1
Failures: 5
Branches: 10
Wall time: 60ms
</pre>
<p>OR-Tools is written in C++ but has interfaces for numerous languages including Java - which is perfect for Groovy use.</p>
<h4 style="font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(0, 0, 0);">Choco with JSR331</h4>
<p>It is great to have multiple libraries to pick from but having a standard API can help switching between such libraries. This is where JSR331 comes in. It defines a standard API for interacting with constraint solvers and linear solves. Here we use a <a href="https://openrules.com/jsr331/JSR331.UserManual.pdf" target="_blank">JSR331 implementation</a> backed by an earlier version of the Choco library. The code looks like this:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">import </span>javax.constraints.*<br><br>ProblemFactory.<span style="color:#9876aa;font-style:italic;">newProblem</span>(<span style="color:#6a8759;">'SEND+MORE=MONEY'</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(S, M) = [<span style="color:#6a8759;">'S'</span>, <span style="color:#6a8759;">'M'</span>].collect <span style="font-weight:bold;">{ </span>variable(it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(E, N, D, O, R, Y) = [<span style="color:#6a8759;">'E'</span>, <span style="color:#6a8759;">'N'</span>, <span style="color:#6a8759;">'D'</span>, <span style="color:#6a8759;">'O'</span>, <span style="color:#6a8759;">'R'</span>, <span style="color:#6a8759;">'Y'</span>].collect <span style="font-weight:bold;">{ </span>variable(it, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="font-weight:bold;">    </span>postAllDifferent(S, E, N, D, M, O, R, Y)<br><br>    Var[] ALL = [<br>            S, E, N, D,<br>            M, O, R, E,<br>            M, O, N, E, Y]<br>    <span style="color:#cc7832;">int</span>[] COEFFS = [<br>            <span style="color:#6897bb;">1000</span>, <span style="color:#6897bb;">100</span>, <span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">1</span>,<br>            <span style="color:#6897bb;">1000</span>, <span style="color:#6897bb;">100</span>, <span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">1</span>,<br>            -<span style="color:#6897bb;">10000</span>, -<span style="color:#6897bb;">1000</span>, -<span style="color:#6897bb;">100</span>, -<span style="color:#6897bb;">10</span>, -<span style="color:#6897bb;">1</span>]<br><br>    post(COEFFS, ALL, <span style="color:#6a8759;">'='</span>, <span style="color:#6897bb;">0</span>)<br><br>    <span style="color:#cc7832;">def </span>solver = getSolver()<br>    <span style="color:#cc7832;">def </span>solution = solver.findSolution()<br>    println solution ?: <span style="color:#6a8759;">'No solution'<br></span><span style="color:#6a8759;">    </span>solver.logStats()<br><span style="font-weight:bold;">}<br></span></pre>
<div>It is quite similar to earlier examples but now exclusively uses the JSR331 classes in the javax.constraint package. There are implementations of those classes backed by several implementations. So, indeed it would be possible to swap between them. When run, the output is:</div>
<pre>Solution #1:
	 S[9] M[1] E[5] N[6] D[7] O[0] R[8] Y[2]
</pre>
<p>Having said that, at the time of writing, JSR331 popularity doesn't appear to be on the rise. Most folks using constraint programming libraries seem to be using the direct library classes. Indeed, the version of the Choco implementation used by the JSR331 implementation is over 10 years old.</p>
<h3>Incorporating Carry</h3>
<p>The scalar product global constraint we have used in the previous examples is very powerful and probably would be our first choice for this problem. We can, however, model constraint programming problems in multiple ways, so let's look at a solution that avoids that global constraint.</p>
<p>Instead, we will develop a model that mirrors how we reasoned about the original <code>TO + GO = OUT</code> problem that we solved by hand. For that, we just considered a column at a time and accounted for the carry. We'll explicitly introduce variables to hold the carry (0 if no carry, or 1 if there is a carry) into our model. Then we'll express the mathematical constraints that are applicable for each column.</p>
<p>Here is the code:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">new </span>Model(<span style="color:#6a8759;">"SEND+MORE=MONEY"</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(S, M) = [<span style="color:#6a8759;">'S'</span>, <span style="color:#6a8759;">'M'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(E, N, D, O, R, Y) = [<span style="color:#6a8759;">'E'</span>, <span style="color:#6a8759;">'N'</span>, <span style="color:#6a8759;">'D'</span>, <span style="color:#6a8759;">'O'</span>, <span style="color:#6a8759;">'R'</span>, <span style="color:#6a8759;">'Y'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>C = (<span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">3</span>).collect<span style="font-weight:bold;">{ </span>intVar(<span style="font-size: 9.6pt; color: rgb(106, 135, 89);">"C</span><span style="font-size: 9.6pt;">$it</span><span style="font-size: 9.6pt; color: rgb(106, 135, 89);">"</span><span style="font-size: 9.6pt;">, </span><span style="font-size: 9.6pt; color: rgb(104, 151, 187);">0</span><span style="font-size: 9.6pt;">, </span><span style="font-size: 9.6pt; color: rgb(104, 151, 187);">9</span><span style="font-size: 9.6pt;">)</span> <span style="font-size: 9.6pt; font-weight: bold;">}</span><br><span style="font-weight:bold;"><br></span><span style="font-weight:bold;">    </span>allDifferent(S, E, N, D, M, O, R, Y).post()<br>    C[<span style="color:#6897bb;">3</span>]              .eq(M).post()                         <span style="font-size: 9.6pt; color: rgb(128, 128, 128);">//  C3 C2 C1 C0</span><br>    C[<span style="color:#6897bb;">2</span>].add(S).add(M).eq(O.add(C[<span style="color:#6897bb;">3</span>].mul(<span style="color:#6897bb;">10</span>))).post()       <span style="font-size: 9.6pt; color: rgb(128, 128, 128);">//      S  E  N  D</span><br>    C[<span style="color:#6897bb;">1</span>].add(E).add(O).eq(N.add(C[<span style="color:#6897bb;">2</span>].mul(<span style="color:#6897bb;">10</span>))).post()       <span style="font-size: 9.6pt; color: rgb(128, 128, 128);">//      M  O  R  E</span><br>    C[<span style="color:#6897bb;">0</span>].add(N).add(R).eq(E.add(C[<span style="color:#6897bb;">1</span>].mul(<span style="color:#6897bb;">10</span>))).post()       <span style="font-size: 9.6pt; color: rgb(128, 128, 128);">//   -------------</span><br>             D .add(E).eq(Y.add(C[<span style="color:#6897bb;">0</span>].mul(<span style="color:#6897bb;">10</span>))).post()       <span style="font-size: 9.6pt; color: rgb(128, 128, 128);">//   M  O  N  E  Y</span><br><br>    println <span style="color:#9876aa;">solver</span>.findSolution()<span style="color:#6a8759;"><br></span><span style="font-weight:bold;">}<br></span></pre>
<p>We can see that there is now no scalar product global constraint any more but instead the constraints for each column.<br></p>
<p>When run, the output looks like this:</p>
<pre>Solution: S=9, M=1, E=5, N=6, D=7, O=0, R=8, Y=2, C0=1, C1=1, C2=0, C3=1, sum_exp_1=9,
sum_exp_2=10, (C3*10)=10, sum_exp_3=10, sum_exp_4=6, sum_exp_5=6, (C2*10)=0, sum_exp_6=6,
sum_exp_7=7, sum_exp_8=15, (C1*10)=10, sum_exp_9=15, sum_exp_10=12, (C0*10)=10, sum_exp_11=12,</pre>
<p>We can see that as we were defining our constraints for each column, subexpressions were being created in the model which are reflected in the solution. They are if you like, temporary calculations along the way to getting the answer - or more accurately a snapshot of ever changing temporary calculations. They don't form part of the answer that interests us, so we would be free to just print out the part of the solution which interests us if we wanted.</p>
<h3>Creating a DSL</h3>
<p>The previous example has lots of calls to <code>add</code> and <code>mul</code> methods. We can create a little bit of a DSL to provide some syntactic sugar to our previous examples to allow use of Groovy's operator overloading, support ranges when specifying the domain of a variable, and a few other niceties. Our code becomes:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">model(<span style="color:#6a8759;">"SEND+MORE=MONEY"</span>) <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(S, M) = [<span style="color:#6a8759;">'S'</span>, <span style="color:#6a8759;">'M'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">1</span>..<span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(E, N, D, O, R, Y) = [<span style="color:#6a8759;">'E'</span>, <span style="color:#6a8759;">'N'</span>, <span style="color:#6a8759;">'D'</span>, <span style="color:#6a8759;">'O'</span>, <span style="color:#6a8759;">'R'</span>, <span style="color:#6a8759;">'Y'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>C = intVarArray(<span style="color:#6897bb;">4</span>, <span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">1</span>)<br><br>    [allDifferent(S, E, N, D, M, O, R, Y),      <span style="color:#808080;">//  C3 C2 C1 C0<br></span><span style="color:#808080;">     </span>C[<span style="color:#6897bb;">3</span>]         .eq(M),                       <span style="color:#808080;">//      S  E  N  D<br></span><span style="color:#808080;">    </span>(C[<span style="color:#6897bb;">2</span>] + S + M).eq(O + C[<span style="color:#6897bb;">3</span>] * <span style="color:#6897bb;">10</span>),           <span style="color:#808080;">//      M  O  R  E<br></span><span style="color:#808080;">    </span>(C[<span style="color:#6897bb;">1</span>] + E + O).eq(N + C[<span style="color:#6897bb;">2</span>] * <span style="color:#6897bb;">10</span>),           <span style="color:#808080;">//   -------------<br></span><span style="color:#808080;">    </span>(C[<span style="color:#6897bb;">0</span>] + N + R).eq(E + C[<span style="color:#6897bb;">1</span>] * <span style="color:#6897bb;">10</span>),           <span style="color:#808080;">//   M  O  N  E  Y<br></span><span style="color:#808080;">           </span>(D + E).eq(Y + C[<span style="color:#6897bb;">0</span>] * <span style="color:#6897bb;">10</span>)]*.post()<br><br>    println <span style="color:#9876aa;">solver</span>.findSolution()<span style="color:#6a8759;"><br></span><span style="font-weight:bold;">}<br></span></pre>
<p>It has the same output as previously.</p>
<p>You might wonder how the solver finds the solution. You can watch the variables in the debugger and use tools like <a href="https://github.com/chocoteam/choco-cpviz" target="_blank">choco-cpviz</a>&nbsp;but it is a quite convoluted process until you are used to it. We'll try to give you a flavor of what is going on here. Basically, there will be various steps of pruning wherever possible and branching with possible backtracking. Below are some snapshots for our example above.</p>
<p>To start with, we have nearly 90 light green squares which represents our problem search space. We walk our way through the rules looking for ways to prune the search space:</p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/bdb17727-caee-473c-b450-3ec60e74e13b" style="width:80%;" alt="choco_step1.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/171a4583-806a-4c1b-9557-892d87e5670c" style="width:80%;" alt=" choco_step2.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/6807b9ad-8390-45ec-ad58-10dd1346bf45" style="width:80%;" alt=" choco_step3.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/b2b2221a-60fa-4d9a-9fa1-16ddb213fcce" style="width:80%;" alt="choco_step4.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/6303ed53-ff6c-4572-b70d-52b299d4fff7" style="width:80%;" alt="choco_step5.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/658ff512-433f-452a-9a81-904449dfb623" style="width:80%;" alt="choco_step6.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/f81d5630-ede4-4b75-9e74-b73b81be0b21" style="width:80%;" alt="choco_step7.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/8de231cc-c0da-4170-845a-6653b84779b9" style="width:80%;" alt="choco_step8.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/46227911-c406-4234-88d1-fe1f9ac9c517" style="width:80%;" alt="choco_step9.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/31060d5c-6716-4efe-8f99-910c1771ef28" style="width:80%;" alt="choco_step10.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/4b9324d7-2bf3-48c9-af8b-b35872aaf5cf" style="width:80%;" alt="choco_step11.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/71197695-f379-4777-9ed5-ddae1577ee3d" style="width:80%;" alt="choco_step12.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/6ff23a4e-b444-4794-bc79-e6591582bff9" style="width:80%;" alt="choco_step13.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/6262d9bc-7f14-4b8f-a952-18668c6f1340" style="width:30%;" alt="choco_step14.png"></p>
<p>As we are locking in the value of variables, we can substitute them into and simplify our constraints. When we reapply them, they will be quicker to evaluate and may reveal more information.</p>
<p>At this point we only have 2 of our variables locked down but our search space is nearly half what we started with and we have simplified some of our constraints. We would continue branching and solving at this point until we find our solution or determine that no solution is possible.</p>
<h3>Looking at other languages</h3>
<p>The example repo also contains solutions for this problem in other languages so you can compare and contrast<br />
including<br />
<a href="https://clojure.org/" rel="nofollow">Clojure</a>,<br />
Haskell (<a href="https://github.com/Frege/frege">Frege</a>),<br />
<a href="https://www.java.com/" rel="nofollow">Java</a>,<br />
JavaScript (<a href="https://docs.oracle.com/javase/10/nashorn/" rel="nofollow">Nashorn</a>),<br />
Ruby (<a href="https://www.jruby.org/" rel="nofollow">JRuby</a>),<br />
Python (<a href="https://www.jython.org/" rel="nofollow">Jython</a>),<br />
<a href="https://kotlinlang.org/" rel="nofollow">Kotlin</a>,<br />
Lua (<a href="https://github.com/luaj/luaj">Luaj</a>),<br />
Prolog (<a href="http://apice.unibo.it/xwiki/bin/view/Tuprolog/" rel="nofollow">tuprolog</a>),<br />
and <a href="https://www.scala-lang.org/" rel="nofollow">Scala</a>.</p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/a1fc3f0b-3997-4e91-987a-51a5423581e4" style="width:80%;" alt="other language logos"></p>
<h3>Other examples</h3>
<p>To wrap up, let's look at solving a few more examples (using Choco). We'll solve some of the examples from an interesting blog on the <a href="https://pballew.blogspot.com/2015/02/some-history-notes-about-alphametrics.html" target="_blank">history of Cryptarithmetic problems</a>:</p>
<ul>
<li><code>ABCD * 4 = DCBA</code></li>
<li><code>AA + BB + CC = ABC</code></li>
<li><code>HALF + HALF = WHOLE</code></li>
<li><code>HALF + FIFTH + TENTH + TENTH + TENTH = WHOLE</code></li>
</ul>
<p>Here is the code:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">new </span>Model(<span style="color:#6a8759;">"ABCD*4=DCBA"</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(A, D) = [<span style="color:#6a8759;">'A'</span>, <span style="color:#6a8759;">'D'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(B, C) = [<span style="color:#6a8759;">'B'</span>, <span style="color:#6a8759;">'C'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>R = (<span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">2</span>).collect <span style="font-weight:bold;">{ </span>intVar(<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="font-weight:bold;">    </span>allDifferent(A, B, C, D).post()<br>    R[<span style="color:#6897bb;">2</span>].add(A.mul(<span style="color:#6897bb;">4</span>)).eq(D).post()<br>    R[<span style="color:#6897bb;">1</span>].add(B.mul(<span style="color:#6897bb;">4</span>)).eq(C.add(R[<span style="color:#6897bb;">2</span>].mul(<span style="color:#6897bb;">10</span>))).post()<br>    R[<span style="color:#6897bb;">0</span>].add(C.mul(<span style="color:#6897bb;">4</span>)).eq(B.add(R[<span style="color:#6897bb;">1</span>].mul(<span style="color:#6897bb;">10</span>))).post()<br>    D.mul(<span style="color:#6897bb;">4</span>).eq(A.add(R[<span style="color:#6897bb;">0</span>].mul(<span style="color:#6897bb;">10</span>))).post()<br>    <span style="color:#9876aa;">solver</span>.findAllSolutions().each <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">        </span>println <span style="color:#6a8759;">"</span>$<span style="color:#9876aa;">name</span><span style="color:#6a8759;">: </span>$<span style="font-weight:bold;">{</span>pretty(it, [A, B, C, D, <span style="color:#6a8759;">' * 4 = '</span>, D, C, B, A])<span style="font-weight:bold;">}</span><span style="color:#cc7832;">\n</span>$it<span style="color:#cc7832;">\n</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="color:#cc7832;">new </span>Model(<span style="color:#6a8759;">"AA+BB+CC=ABC"</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(A, B, C) = [<span style="color:#6a8759;">'A'</span>, <span style="color:#6a8759;">'B'</span>, <span style="color:#6a8759;">'C'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span>allDifferent(A, B, C).post()<br>    A.mul(<span style="color:#6897bb;">11</span>).add(B.mul(<span style="color:#6897bb;">11</span>).add(C.mul(<span style="color:#6897bb;">11</span>))).eq(A.mul(<span style="color:#6897bb;">100</span>).add(B.mul(<span style="color:#6897bb;">10</span>)).add(C)).post()<br>    <span style="color:#9876aa;">solver</span>.findAllSolutions().each <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">        </span>println <span style="color:#6a8759;">"</span>$<span style="color:#9876aa;">name</span><span style="color:#6a8759;">: </span>$<span style="font-weight:bold;">{</span>pretty(it, [A, A, <span style="color:#6a8759;">' + '</span>, B, B, <span style="color:#6a8759;">' + '</span>, C, C, <span style="color:#6a8759;">' = '</span>, A, B, C])<span style="font-weight:bold;">}</span><span style="color:#cc7832;">\n</span>$it<span style="color:#cc7832;">\n</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="color:#cc7832;">new </span>Model(<span style="color:#6a8759;">"HALF+HALF=WHOLE"</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(H, W) = [<span style="color:#6a8759;">'H'</span>, <span style="color:#6a8759;">'W'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(A, E, F, L, O) = [<span style="color:#6a8759;">'A'</span>, <span style="color:#6a8759;">'E'</span>, <span style="color:#6a8759;">'F'</span>, <span style="color:#6a8759;">'L'</span>, <span style="color:#6a8759;">'O'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span>allDifferent(H, W, A, E, F, L, O).post()<br>    IntVar[] ALL = [<br>            H, A, L, F,<br>            W, H, O, L, E]<br>    <span style="color:#cc7832;">int</span>[] COEFFS = [<br>            <span style="color:#6897bb;">2000</span>, <span style="color:#6897bb;">200</span>, <span style="color:#6897bb;">20</span>, <span style="color:#6897bb;">2</span>,<br>            -<span style="color:#6897bb;">10000</span>, -<span style="color:#6897bb;">1000</span>, -<span style="color:#6897bb;">100</span>, -<span style="color:#6897bb;">10</span>, -<span style="color:#6897bb;">1</span>]<br>    scalar(ALL, COEFFS, <span style="color:#6a8759;">"="</span>, <span style="color:#6897bb;">0</span>).post()<br>    <span style="color:#9876aa;">solver</span>.findAllSolutions().each <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">        </span>println <span style="color:#6a8759;">"</span>$<span style="color:#9876aa;">name</span><span style="color:#6a8759;">: </span>$<span style="font-weight:bold;">{</span>pretty(it, [H, A, L, F, <span style="color:#6a8759;">' + '</span>, H, A, L, F, <span style="color:#6a8759;">' = '</span>, W, H, O, L, E])<span style="font-weight:bold;">}</span><span style="color:#cc7832;">\n</span>$it<span style="color:#cc7832;">\n</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="color:#cc7832;">new </span>Model(<span style="color:#6a8759;">"HALF+FIFTH+TENTH+TENTH+TENTH=WHOLE"</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(H, F, T, W) = [<span style="color:#6a8759;">'H'</span>, <span style="color:#6a8759;">'F'</span>, <span style="color:#6a8759;">'T'</span>, <span style="color:#6a8759;">'W'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(A, L, I, E, N, O) = [<span style="color:#6a8759;">'A'</span>, <span style="color:#6a8759;">'L'</span>, <span style="color:#6a8759;">'I'</span>, <span style="color:#6a8759;">'E'</span>, <span style="color:#6a8759;">'N'</span>, <span style="color:#6a8759;">'O'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span>allDifferent(H, F, T, W, A, L, I, E, N, O).post()<br>    IntVar[] ALL = [<br>            H, A, L, F,<br>            F, I, F, T, H,<br>            T, E, N, T, H,<br>            T, E, N, T, H,<br>            T, E, N, T, H,<br>            W, H, O, L, E]<br>    <span style="color:#cc7832;">int</span>[] COEFFS = [<br>            <span style="color:#6897bb;">1000</span>, <span style="color:#6897bb;">100</span>, <span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">1</span>,<br>            <span style="color:#6897bb;">10000</span>, <span style="color:#6897bb;">1000</span>, <span style="color:#6897bb;">100</span>, <span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">1</span>,<br>            <span style="color:#6897bb;">10000</span>, <span style="color:#6897bb;">1000</span>, <span style="color:#6897bb;">100</span>, <span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">1</span>,<br>            <span style="color:#6897bb;">10000</span>, <span style="color:#6897bb;">1000</span>, <span style="color:#6897bb;">100</span>, <span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">1</span>,<br>            <span style="color:#6897bb;">10000</span>, <span style="color:#6897bb;">1000</span>, <span style="color:#6897bb;">100</span>, <span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">1</span>,<br>            -<span style="color:#6897bb;">10000</span>, -<span style="color:#6897bb;">1000</span>, -<span style="color:#6897bb;">100</span>, -<span style="color:#6897bb;">10</span>, -<span style="color:#6897bb;">1</span>]<br>    scalar(ALL, COEFFS, <span style="color:#6a8759;">"="</span>, <span style="color:#6897bb;">0</span>).post()<br>    <span style="color:#9876aa;">solver</span>.findAllSolutions().each <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">        </span><span style="color:#cc7832;">def </span>parts = [H, A, L, F, <span style="color:#6a8759;">'+'</span>, F, I, F, T, H, <span style="color:#6a8759;">'+'</span>, T, E, N, T, H, <span style="color:#6a8759;">'+'</span>,<br>                     T, E, N, T, H, <span style="color:#6a8759;">'+'</span>, T, E, N, T, H, <span style="color:#6a8759;">'='</span>, W, H, O, L, E]<br>        println <span style="color:#6a8759;">"</span>$<span style="color:#9876aa;">name</span><span style="color:#6a8759;">: </span>$<span style="font-weight:bold;">{</span>pretty(it, parts)<span style="font-weight:bold;">}</span><span style="color:#cc7832;">\n</span>$it<span style="color:#cc7832;">\n</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="color:#808080;">// helper method to print solutions<br></span><span style="color:#cc7832;">def </span>pretty(model, parts) {<br>    parts.collect <span style="font-weight:bold;">{ </span>p <span style="font-weight:bold;">-> </span>p <span style="color:#cc7832;">instanceof </span>IntVar ? model.getIntVal(p) : p <span style="font-weight:bold;">}</span>.join()<br>}</pre>
<p>which has this output:</p>
<pre>ABCD*4=DCBA: 2178 * 4 = 8712
Solution: A=2, D=8, B=1, C=7, IV_1=3, IV_2=3, IV_3=0, (A*4)=8, sum_exp_4=8, (B*4)=4, ..., 

AA+BB+CC=ABC: 11 + 99 + 88 = 198
Solution: A=1, B=9, C=8, (A*11)=11, (B*11)=99, (C*11)=88, ..., 

HALF+HALF=WHOLE: 9604 + 9604 = 19208
Solution: H=9, W=1, A=6, E=8, F=4, L=0, O=2, 

HALF+HALF=WHOLE: 9703 + 9703 = 19406
Solution: H=9, W=1, A=7, E=6, F=3, L=0, O=4, 

HALF+HALF=WHOLE: 9802 + 9802 = 19604
Solution: H=9, W=1, A=8, E=4, F=2, L=0, O=6, 

HALF+FIFTH+TENTH+TENTH+TENTH=WHOLE: 6701+14126+25326+25326+25326=96805
Solution: H=6, F=1, T=2, W=9, A=7, L=0, I=4, E=5, N=3, O=8, 
</pre>
<p>You should see the common patterns used for solving these puzzles.</p>
<h3>Further Information</h3>
<ul>
<li><a href="https://github.com/radsz/jacop" target="_blank">JaCoP</a> Java Constraint Programming solver</li>
<li><a href="https://choco-solver.org/" target="_blank">Choco</a> open source library for constraint programming</li>
<li><a href="https://developers.google.com/optimization/cp" target="_blank">OR-Tools</a> constraint optimization</li>
<li><a href="https://en.wikipedia.org/wiki/Verbal_arithmetic" target="_blank">Verbal arithmetic</a> problems described (wikipedia)</li>
<li><a href="https://www.jcp.org/en/jsr/detail?id=331" target="_blank">JSR331</a>&nbsp;Constraint Programming API</li>
<li><a href="https://github.com/paulk-asert/groovy-constraint-programming/tree/master/subprojects/SendMoreMoney" target="_blank">Github repo</a> containing sample code</li>
</ul>
<h3>Conclusion</h3>
<p>We have looked at using Groovy and a few constraint programming libraries to solve a cryptarithmetic puzzles. Why not try solving some of your own puzzles.</p>

  </div><a class="u-url" href="/groovy/entry/solving-cryptarithmetic-puzzles-with-groovy" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
