<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Apache HBase Internals: Locking and Multiversion Concurrency Control | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Apache HBase Internals: Locking and Multiversion Concurrency Control" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="by Gregory Chanan HBase Committer Cloudera, Inc.&nbsp; &lt;/p&gt; &lt;/p&gt; &lt;/p&gt; NOTE: This blog post describes how Apache HBase does concurrency control. &nbsp;This assumes knowledge of the HBase write path, which you can read more about in this other blog post. Introduction Apache HBase provides a consistent and understandable data model to the user while still offering high performance. &nbsp;In this blog, we&rsquo;ll first discuss the guarantees of the HBase data model and how they differ from those of a traditional database. &nbsp;Next, we&rsquo;ll motivate the need for concurrency control by studying concurrent writes and then introduce a simple concurrency control solution. &nbsp;Finally, we&rsquo;ll study read/write concurrency control and discuss an efficient solution called Multiversion Concurrency Control. Why Concurrency Control? In order to understand HBase concurrency control, we first need to understand why HBase needs concurrency control at all; in other words, what properties does HBase guarantee about the data that requires concurrency control?The answer is that HBase guarantees ACID semantics per-row. &nbsp;ACID is an acronym for:&bull; Atomicity: All parts of transaction complete or none complete&bull; Consistency: Only valid data written to database&bull; Isolation: Parallel transactions do not impact each other&rsquo;s execution&bull; Durability: Once transaction committed, it remainsIf you have experience with traditional relational databases, these terms may be familiar to you. &nbsp;Traditional relational databases typically provide ACID semantics across all the data in the database; for performance reasons, HBase only provides ACID semantics on a per-row basis. &nbsp;If you are not familiar with these terms, don&rsquo;t worry. &nbsp;Instead of dwelling on the precise definitions, let&rsquo;s look at a couple of examples. Writes and Write-Write Synchronization Consider two concurrent writes to HBase that represent {company, role} combinations I&rsquo;ve held: &lt;/b&gt; Image 1. &nbsp;Two writes to the same rowFrom the previously cited Write Path Blog Post, we know that HBase will perform the following steps for each write:(1) Write to Write-Ahead-Log (WAL)(2) Update MemStore: write each data cell [the (row, column) pair] to the memstoreList 1. Simple list of write stepsThat is, we write to the WAL for disaster recovery purposes and then update an in-memory copy (MemStore) of the data.Now, assume we have no concurrency control over the writes and consider the following order of events: Image 2. &nbsp;One possible order of events for two writesAt the end, we are left with the following state: Image 3. &nbsp;Inconsistent result in absence of write-write synchronizationwhich is a role I&rsquo;ve never held. &nbsp;In ACID terms, we have not provided Isolation for the writes, as the two writes became intermixed.We clearly need some concurrency control. &nbsp;The simplest solution is to provide exclusive locks per row in order to provide isolation for writes that update the same row. &nbsp;So, our new list of steps for writes is as follows (new steps are in blue).(0) Obtain Row Lock(1) Write to Write-Ahead-Log (WAL)(2) Update MemStore: write each cell to the memstore(3) Release Row LockList 2: List of write-steps with write-write synchronization &lt;/p&gt; Read-Write Synchronization So far, we&rsquo;ve added row locks to writes in order to guarantee ACID semantics. &nbsp;Do we need to add any concurrency control for reads? &nbsp;Let&rsquo;s consider another order of events for our example above (Note that this order follows the rules in List 2):Image 4. &nbsp;One possible order of operations for two writes and a readAssume no concurrency control for reads and that we request a read concurrently with the two writes. &nbsp;Assume the read is executed directly before &ldquo;Waiter&rdquo; is written to the MemStore; this read action is represented by a red line above. &nbsp;In that case, we will again read the inconsistent row: Image 5. &nbsp;Inconsistent result in absence of read-write synchronizationTherefore, we need some concurrency control to deal with read-write synchronization. &nbsp;The simplest solution would be to have the reads obtain and release the row locks in the same manner as the writes. &nbsp;This would resolve the ACID violation, but the downside is that our reads and writes would both contend for the row locks, slowing each other down.Instead, HBase uses a form of Multiversion Concurrency Control (MVCC) to avoid requiring the reads to obtain row locks. &nbsp;Multiversion Concurrency Control works in HBase as follows:For writes:(w1) After acquiring the RowLock, each write operation is immediately assigned a write number(w2) Each data cell in the write stores its write number.(w3) A write operation completes by declaring it is finished with the write number.For reads:(r1) &nbsp;Each read operation is first assigned a read timestamp, called a read point.(r2) &nbsp;The read point is assigned to be the highest integer such that all writes with write number &lt;= x have been completed.(r3) &nbsp;A read r for a certain (row, column) combination returns the data cell with the matching (row, column) whose write number is the largest value that is less than or equal to the read point of r.List 3. Multiversion Concurrency Control stepsLet&rsquo;s look at the operations in Image 4 again, this time using MultiVersion Concurrency Control: Image 6. &nbsp;Write steps with Multiversion Concurrency ControlNotice the new steps introduced for Multiversion Concurrency Control. &nbsp;Each write is assigned a write number (step w1), each data cell is written to the memstore with its write number (step w2, e.g. &ldquo;Cloudera [wn=1]&rdquo;) and each write completes by finishing its write number (step w3).Now, let&rsquo;s consider the read in Image 4, i.e. a read that begins after step &ldquo;Restaurant [wn=2]&rdquo; but before the step &ldquo;Waiter [wn=2]&rdquo;. &nbsp;From rule r1 and r2, its read point will be assigned to 1. &nbsp;From r3, it will read the values with write number of 1, leaving us with:Image 7. &nbsp;Consistent answer with Multiversion Concurrency ControlA consistent response without requiring locking the row for the reads!Let&rsquo;s put this all together by listing the steps for a write with Multiversion Concurrency Control: (new steps required for read-write synchronization are in red):(0) Obtain Row Lock(0a) Acquire New Write Number(1) Write to Write-Ahead-Log (WAL)(2) Update MemStore: write each cell to the memstore(2a) Finish Write Number(3) Release Row Lock Conclusion In this blog we first defined HBase&rsquo;s row-level ACID guarantees. &nbsp;We then demonstrated the need for concurrency control by studying concurrent writes and introduced a row-level locking solution. &nbsp;Finally, we investigated read-write concurrency control and presented an efficient mechanism called Multiversion Concurrency Control (MVCC).This blog post is accurate as of HBase 0.92. &nbsp;HBase 0.94 has various optimizations, e.g. HBASE-5541 that will be described in a future blog post.&lt;/b&gt; &nbsp;" />
<meta property="og:description" content="by Gregory Chanan HBase Committer Cloudera, Inc.&nbsp; &lt;/p&gt; &lt;/p&gt; &lt;/p&gt; NOTE: This blog post describes how Apache HBase does concurrency control. &nbsp;This assumes knowledge of the HBase write path, which you can read more about in this other blog post. Introduction Apache HBase provides a consistent and understandable data model to the user while still offering high performance. &nbsp;In this blog, we&rsquo;ll first discuss the guarantees of the HBase data model and how they differ from those of a traditional database. &nbsp;Next, we&rsquo;ll motivate the need for concurrency control by studying concurrent writes and then introduce a simple concurrency control solution. &nbsp;Finally, we&rsquo;ll study read/write concurrency control and discuss an efficient solution called Multiversion Concurrency Control. Why Concurrency Control? In order to understand HBase concurrency control, we first need to understand why HBase needs concurrency control at all; in other words, what properties does HBase guarantee about the data that requires concurrency control?The answer is that HBase guarantees ACID semantics per-row. &nbsp;ACID is an acronym for:&bull; Atomicity: All parts of transaction complete or none complete&bull; Consistency: Only valid data written to database&bull; Isolation: Parallel transactions do not impact each other&rsquo;s execution&bull; Durability: Once transaction committed, it remainsIf you have experience with traditional relational databases, these terms may be familiar to you. &nbsp;Traditional relational databases typically provide ACID semantics across all the data in the database; for performance reasons, HBase only provides ACID semantics on a per-row basis. &nbsp;If you are not familiar with these terms, don&rsquo;t worry. &nbsp;Instead of dwelling on the precise definitions, let&rsquo;s look at a couple of examples. Writes and Write-Write Synchronization Consider two concurrent writes to HBase that represent {company, role} combinations I&rsquo;ve held: &lt;/b&gt; Image 1. &nbsp;Two writes to the same rowFrom the previously cited Write Path Blog Post, we know that HBase will perform the following steps for each write:(1) Write to Write-Ahead-Log (WAL)(2) Update MemStore: write each data cell [the (row, column) pair] to the memstoreList 1. Simple list of write stepsThat is, we write to the WAL for disaster recovery purposes and then update an in-memory copy (MemStore) of the data.Now, assume we have no concurrency control over the writes and consider the following order of events: Image 2. &nbsp;One possible order of events for two writesAt the end, we are left with the following state: Image 3. &nbsp;Inconsistent result in absence of write-write synchronizationwhich is a role I&rsquo;ve never held. &nbsp;In ACID terms, we have not provided Isolation for the writes, as the two writes became intermixed.We clearly need some concurrency control. &nbsp;The simplest solution is to provide exclusive locks per row in order to provide isolation for writes that update the same row. &nbsp;So, our new list of steps for writes is as follows (new steps are in blue).(0) Obtain Row Lock(1) Write to Write-Ahead-Log (WAL)(2) Update MemStore: write each cell to the memstore(3) Release Row LockList 2: List of write-steps with write-write synchronization &lt;/p&gt; Read-Write Synchronization So far, we&rsquo;ve added row locks to writes in order to guarantee ACID semantics. &nbsp;Do we need to add any concurrency control for reads? &nbsp;Let&rsquo;s consider another order of events for our example above (Note that this order follows the rules in List 2):Image 4. &nbsp;One possible order of operations for two writes and a readAssume no concurrency control for reads and that we request a read concurrently with the two writes. &nbsp;Assume the read is executed directly before &ldquo;Waiter&rdquo; is written to the MemStore; this read action is represented by a red line above. &nbsp;In that case, we will again read the inconsistent row: Image 5. &nbsp;Inconsistent result in absence of read-write synchronizationTherefore, we need some concurrency control to deal with read-write synchronization. &nbsp;The simplest solution would be to have the reads obtain and release the row locks in the same manner as the writes. &nbsp;This would resolve the ACID violation, but the downside is that our reads and writes would both contend for the row locks, slowing each other down.Instead, HBase uses a form of Multiversion Concurrency Control (MVCC) to avoid requiring the reads to obtain row locks. &nbsp;Multiversion Concurrency Control works in HBase as follows:For writes:(w1) After acquiring the RowLock, each write operation is immediately assigned a write number(w2) Each data cell in the write stores its write number.(w3) A write operation completes by declaring it is finished with the write number.For reads:(r1) &nbsp;Each read operation is first assigned a read timestamp, called a read point.(r2) &nbsp;The read point is assigned to be the highest integer such that all writes with write number &lt;= x have been completed.(r3) &nbsp;A read r for a certain (row, column) combination returns the data cell with the matching (row, column) whose write number is the largest value that is less than or equal to the read point of r.List 3. Multiversion Concurrency Control stepsLet&rsquo;s look at the operations in Image 4 again, this time using MultiVersion Concurrency Control: Image 6. &nbsp;Write steps with Multiversion Concurrency ControlNotice the new steps introduced for Multiversion Concurrency Control. &nbsp;Each write is assigned a write number (step w1), each data cell is written to the memstore with its write number (step w2, e.g. &ldquo;Cloudera [wn=1]&rdquo;) and each write completes by finishing its write number (step w3).Now, let&rsquo;s consider the read in Image 4, i.e. a read that begins after step &ldquo;Restaurant [wn=2]&rdquo; but before the step &ldquo;Waiter [wn=2]&rdquo;. &nbsp;From rule r1 and r2, its read point will be assigned to 1. &nbsp;From r3, it will read the values with write number of 1, leaving us with:Image 7. &nbsp;Consistent answer with Multiversion Concurrency ControlA consistent response without requiring locking the row for the reads!Let&rsquo;s put this all together by listing the steps for a write with Multiversion Concurrency Control: (new steps required for read-write synchronization are in red):(0) Obtain Row Lock(0a) Acquire New Write Number(1) Write to Write-Ahead-Log (WAL)(2) Update MemStore: write each cell to the memstore(2a) Finish Write Number(3) Release Row Lock Conclusion In this blog we first defined HBase&rsquo;s row-level ACID guarantees. &nbsp;We then demonstrated the need for concurrency control by studying concurrent writes and introduced a row-level locking solution. &nbsp;Finally, we investigated read-write concurrency control and presented an efficient mechanism called Multiversion Concurrency Control (MVCC).This blog post is accurate as of HBase 0.92. &nbsp;HBase 0.94 has various optimizations, e.g. HBASE-5541 that will be described in a future blog post.&lt;/b&gt; &nbsp;" />
<link rel="canonical" href="http://localhost:4000/hbase/entry/apache_hbase_internals_locking_and" />
<meta property="og:url" content="http://localhost:4000/hbase/entry/apache_hbase_internals_locking_and" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-06-07T16:48:27-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Apache HBase Internals: Locking and Multiversion Concurrency Control" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-06-07T16:48:27-04:00","datePublished":"2021-06-07T16:48:27-04:00","description":"by Gregory Chanan HBase Committer Cloudera, Inc.&nbsp; &lt;/p&gt; &lt;/p&gt; &lt;/p&gt; NOTE: This blog post describes how Apache HBase does concurrency control. &nbsp;This assumes knowledge of the HBase write path, which you can read more about in this other blog post. Introduction Apache HBase provides a consistent and understandable data model to the user while still offering high performance. &nbsp;In this blog, we&rsquo;ll first discuss the guarantees of the HBase data model and how they differ from those of a traditional database. &nbsp;Next, we&rsquo;ll motivate the need for concurrency control by studying concurrent writes and then introduce a simple concurrency control solution. &nbsp;Finally, we&rsquo;ll study read/write concurrency control and discuss an efficient solution called Multiversion Concurrency Control. Why Concurrency Control? In order to understand HBase concurrency control, we first need to understand why HBase needs concurrency control at all; in other words, what properties does HBase guarantee about the data that requires concurrency control?The answer is that HBase guarantees ACID semantics per-row. &nbsp;ACID is an acronym for:&bull; Atomicity: All parts of transaction complete or none complete&bull; Consistency: Only valid data written to database&bull; Isolation: Parallel transactions do not impact each other&rsquo;s execution&bull; Durability: Once transaction committed, it remainsIf you have experience with traditional relational databases, these terms may be familiar to you. &nbsp;Traditional relational databases typically provide ACID semantics across all the data in the database; for performance reasons, HBase only provides ACID semantics on a per-row basis. &nbsp;If you are not familiar with these terms, don&rsquo;t worry. &nbsp;Instead of dwelling on the precise definitions, let&rsquo;s look at a couple of examples. Writes and Write-Write Synchronization Consider two concurrent writes to HBase that represent {company, role} combinations I&rsquo;ve held: &lt;/b&gt; Image 1. &nbsp;Two writes to the same rowFrom the previously cited Write Path Blog Post, we know that HBase will perform the following steps for each write:(1) Write to Write-Ahead-Log (WAL)(2) Update MemStore: write each data cell [the (row, column) pair] to the memstoreList 1. Simple list of write stepsThat is, we write to the WAL for disaster recovery purposes and then update an in-memory copy (MemStore) of the data.Now, assume we have no concurrency control over the writes and consider the following order of events: Image 2. &nbsp;One possible order of events for two writesAt the end, we are left with the following state: Image 3. &nbsp;Inconsistent result in absence of write-write synchronizationwhich is a role I&rsquo;ve never held. &nbsp;In ACID terms, we have not provided Isolation for the writes, as the two writes became intermixed.We clearly need some concurrency control. &nbsp;The simplest solution is to provide exclusive locks per row in order to provide isolation for writes that update the same row. &nbsp;So, our new list of steps for writes is as follows (new steps are in blue).(0) Obtain Row Lock(1) Write to Write-Ahead-Log (WAL)(2) Update MemStore: write each cell to the memstore(3) Release Row LockList 2: List of write-steps with write-write synchronization &lt;/p&gt; Read-Write Synchronization So far, we&rsquo;ve added row locks to writes in order to guarantee ACID semantics. &nbsp;Do we need to add any concurrency control for reads? &nbsp;Let&rsquo;s consider another order of events for our example above (Note that this order follows the rules in List 2):Image 4. &nbsp;One possible order of operations for two writes and a readAssume no concurrency control for reads and that we request a read concurrently with the two writes. &nbsp;Assume the read is executed directly before &ldquo;Waiter&rdquo; is written to the MemStore; this read action is represented by a red line above. &nbsp;In that case, we will again read the inconsistent row: Image 5. &nbsp;Inconsistent result in absence of read-write synchronizationTherefore, we need some concurrency control to deal with read-write synchronization. &nbsp;The simplest solution would be to have the reads obtain and release the row locks in the same manner as the writes. &nbsp;This would resolve the ACID violation, but the downside is that our reads and writes would both contend for the row locks, slowing each other down.Instead, HBase uses a form of Multiversion Concurrency Control (MVCC) to avoid requiring the reads to obtain row locks. &nbsp;Multiversion Concurrency Control works in HBase as follows:For writes:(w1) After acquiring the RowLock, each write operation is immediately assigned a write number(w2) Each data cell in the write stores its write number.(w3) A write operation completes by declaring it is finished with the write number.For reads:(r1) &nbsp;Each read operation is first assigned a read timestamp, called a read point.(r2) &nbsp;The read point is assigned to be the highest integer such that all writes with write number &lt;= x have been completed.(r3) &nbsp;A read r for a certain (row, column) combination returns the data cell with the matching (row, column) whose write number is the largest value that is less than or equal to the read point of r.List 3. Multiversion Concurrency Control stepsLet&rsquo;s look at the operations in Image 4 again, this time using MultiVersion Concurrency Control: Image 6. &nbsp;Write steps with Multiversion Concurrency ControlNotice the new steps introduced for Multiversion Concurrency Control. &nbsp;Each write is assigned a write number (step w1), each data cell is written to the memstore with its write number (step w2, e.g. &ldquo;Cloudera [wn=1]&rdquo;) and each write completes by finishing its write number (step w3).Now, let&rsquo;s consider the read in Image 4, i.e. a read that begins after step &ldquo;Restaurant [wn=2]&rdquo; but before the step &ldquo;Waiter [wn=2]&rdquo;. &nbsp;From rule r1 and r2, its read point will be assigned to 1. &nbsp;From r3, it will read the values with write number of 1, leaving us with:Image 7. &nbsp;Consistent answer with Multiversion Concurrency ControlA consistent response without requiring locking the row for the reads!Let&rsquo;s put this all together by listing the steps for a write with Multiversion Concurrency Control: (new steps required for read-write synchronization are in red):(0) Obtain Row Lock(0a) Acquire New Write Number(1) Write to Write-Ahead-Log (WAL)(2) Update MemStore: write each cell to the memstore(2a) Finish Write Number(3) Release Row Lock Conclusion In this blog we first defined HBase&rsquo;s row-level ACID guarantees. &nbsp;We then demonstrated the need for concurrency control by studying concurrent writes and introduced a row-level locking solution. &nbsp;Finally, we investigated read-write concurrency control and presented an efficient mechanism called Multiversion Concurrency Control (MVCC).This blog post is accurate as of HBase 0.92. &nbsp;HBase 0.94 has various optimizations, e.g. HBASE-5541 that will be described in a future blog post.&lt;/b&gt; &nbsp;","headline":"Apache HBase Internals: Locking and Multiversion Concurrency Control","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/hbase/entry/apache_hbase_internals_locking_and"},"url":"http://localhost:4000/hbase/entry/apache_hbase_internals_locking_and"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Apache HBase Internals: Locking and Multiversion Concurrency Control</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-06-07T16:48:27-04:00" itemprop="datePublished">Jun 7, 2021
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Michael Stack", "login"=>"stack", "email"=>"stack@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>by Gregory Chanan</p>
<p>HBase Committer</p>
<p>Cloudera, Inc.&nbsp;</p>
<p><b id="internal-source-marker_0.08475310145877302" style="font-family: Times; font-size: medium; font-weight: normal;"> </p>
<p><b id="internal-source-marker_0.08475310145877302" style="font-weight: normal;"> </b></p>
<p><b id="internal-source-marker_0.08475310145877302" style="font-weight: normal;"> </b></p></p>
<p><b id="internal-source-marker_0.08475310145877302" style="font-weight: normal;"> </b></p>
<p><b id="internal-source-marker_0.08475310145877302" style="font-weight: normal;"> </b></p></p>
<p><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">NOTE: This blog post describes how Apache HBase does concurrency control. &nbsp;This assumes knowledge of the HBase write path, which you can read more about in this other </span><a href="http://blog.cloudera.com/blog/2012/06/hbase-write-path/"><span style="font-size: 16px; font-family: Arial; color: #1155cc; background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">blog post</span></a><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">.</span><br></p>
<h2><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Introduction</span></h2>
<p><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Apache HBase provides a consistent and understandable data model to the user while still offering high performance. &nbsp;In this blog, we&rsquo;ll first discuss the guarantees of the HBase data model and how they differ from those of a traditional database. &nbsp;Next, we&rsquo;ll motivate the need for concurrency control by studying concurrent writes and then introduce a simple concurrency control solution. &nbsp;Finally, we&rsquo;ll study read/write concurrency control and discuss an efficient solution called Multiversion Concurrency Control.</span><br> </p>
<h2><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Why Concurrency Control?</span></h2>
<p><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">In order to understand HBase concurrency control, we first need to understand why HBase needs concurrency control at all; in other words, what properties does HBase guarantee about the data that requires concurrency control?</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">The answer is that HBase guarantees </span><a href="http://hbase.apache.org/acid-semantics.html"><span style="font-size: 16px; font-family: Arial; color: #1155cc; background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">ACID semantics per-row</span></a><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">. &nbsp;ACID is an acronym for:</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">&bull; Atomicity: All parts of transaction complete or none complete</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">&bull; Consistency: Only valid data written to database</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">&bull; Isolation: Parallel transactions do not impact each other&rsquo;s execution</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">&bull; Durability: Once transaction committed, it remains</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">If you have experience with traditional relational databases, these terms may be familiar to you. &nbsp;Traditional relational databases typically provide ACID semantics across all the data in the database; for performance reasons, HBase only provides ACID semantics on a per-row basis. &nbsp;If you are not familiar with these terms, don&rsquo;t worry. &nbsp;Instead of dwelling on the precise definitions, let&rsquo;s look at a couple of examples.</span><br> </p>
<h2><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Writes and Write-Write Synchronization</span></h2>
<p><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Consider two concurrent writes to HBase that represent {company, role} combinations I&rsquo;ve held:</span></p>
<p></b>
<p><b id="internal-source-marker_0.08475310145877302" style="font-family: Times; font-size: medium; font-weight: normal;"><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><img src="https://blogs.apache.org/hbase/mediaresource/12b2c8a4-551b-4aa5-8629-874e220a91bd" width="367" height="49"></b></p>
<p><b id="internal-source-marker_0.08475310145877302" style="font-family: Times; font-size: medium; font-weight: normal;"><img src="https://blogs.apache.org/hbase/mediaresource/43338c9b-78c7-4b54-a031-17d18e1695cc" width="366" height="52"><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">Image 1. &nbsp;Two writes to the same row</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">From the previously cited </span><a href="http://blog.cloudera.com/blog/2012/06/hbase-write-path/"><span style="font-size: 16px; font-family: Arial; color: #1155cc; background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">Write Path Blog Post</span></a><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">, we know that HBase will perform the following steps for each write:</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(1) Write to Write-Ahead-Log (WAL)</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(2) Update MemStore: write each data cell [the (row, column) pair] to the memstore</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">List 1. Simple list of write steps</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">That is, we write to the WAL for disaster recovery purposes and then update an in-memory copy (MemStore) of the data.</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Now, assume we have no concurrency control over the writes and consider the following order of events:</span></b></p>
<p><b id="internal-source-marker_0.08475310145877302" style="font-family: Times; font-size: medium; font-weight: normal;"><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><img src="https://blogs.apache.org/hbase/mediaresource/7effbc3f-0c1c-4135-9dc3-f310e9c8b652" width="440" height="183"><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">Image 2. &nbsp;One possible order of events for two writes</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">At the end, we are left with the following state:</span></b></p>
<p><b id="internal-source-marker_0.08475310145877302" style="font-family: Times; font-size: medium; font-weight: normal;"> </b></p>
<p><b id="internal-source-marker_0.08475310145877302" style="font-family: Times; font-size: medium; font-weight: normal;"><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><img src="https://blogs.apache.org/hbase/mediaresource/1194e8c1-7a84-4da1-9953-1a6d74d07a4f" width="370" height="47"><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">Image 3. &nbsp;Inconsistent result in absence of write-write synchronization</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">which is a role I&rsquo;ve never held. &nbsp;In ACID terms, we have not provided Isolation for the writes, as the two writes became intermixed.</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">We clearly need some concurrency control. &nbsp;The simplest solution is to provide exclusive locks per row in order to provide isolation for writes that update the same row. &nbsp;So, our new list of steps for writes is as follows (new steps are in </span><span style="font-size: 16px; font-family: Arial; color: #0000ff; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">blue</span><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">).</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; color: #0000ff; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(0) Obtain Row Lock</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(1) Write to Write-Ahead-Log (WAL)</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(2) Update MemStore: write each cell to the memstore</span><br><span style="font-size: 16px; font-family: Arial; color: #0000ff; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(3) Release Row Lock</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">List 2: List of write-steps with write-write synchronization</span><br></b></p>
<p><b id="internal-source-marker_0.08475310145877302" style="font-family: Times; font-size: medium; font-weight: normal;"> </p>
<h2><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Read-Write Synchronization</span></h2>
<p><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">So far, we&rsquo;ve added row locks to writes in order to guarantee ACID semantics. &nbsp;Do we need to add any concurrency control for reads? &nbsp;Let&rsquo;s consider another order of events for our example above (Note that this order follows the rules in </span><span style="font-size: 16px; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">List 2</span><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">):</span><img src="https://blogs.apache.org/hbase/mediaresource/30530bc9-0305-47a1-a5c2-86281119799c" width="701" height="266"><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">Image 4. &nbsp;One possible order of operations for two writes and a read</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Assume no concurrency control for reads and that we request a read concurrently with the two writes. &nbsp;Assume the read is executed directly before &ldquo;Waiter&rdquo; is written to the MemStore; this read action is represented by a red line above. &nbsp;In that case, we will again read the inconsistent row:</span></p>
<p><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><img src="https://blogs.apache.org/hbase/mediaresource/1194e8c1-7a84-4da1-9953-1a6d74d07a4f" width="370" height="47"><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">Image 5. &nbsp;Inconsistent result in absence of read-write synchronization</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Therefore, we need some concurrency control to deal with read-write synchronization. &nbsp;The simplest solution would be to have the reads obtain and release the row locks in the same manner as the writes. &nbsp;This would resolve the ACID violation, but the downside is that our reads and writes would both contend for the row locks, slowing each other down.</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Instead, HBase uses a form of </span><a href="http://en.wikipedia.org/wiki/Multiversion_concurrency_control"><span style="font-size: 16px; font-family: Arial; color: #1155cc; background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">Multiversion Concurrency Control</span></a><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> (MVCC) to avoid requiring the reads to obtain row locks. &nbsp;Multiversion Concurrency Control works in HBase as follows:</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">For writes:</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(w1) After acquiring the RowLock, each write operation is immediately assigned a write number</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(w2) Each data cell in the write stores its write number.</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(w3) A write operation completes by declaring it is finished with the write number.</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">For reads:</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(r1) &nbsp;Each read operation is first assigned a read timestamp, called a read point.</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(r2) &nbsp;The read point is assigned to be the highest integer such that all writes with write number <= x have been completed.</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(r3) &nbsp;A read r for a certain (row, column) combination returns the data cell with the matching (row, column) whose write number is the largest value that is less than or equal to the read point of r.</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">List 3. Multiversion Concurrency Control steps</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Let&rsquo;s look at the operations in Image 4 again, this time using MultiVersion Concurrency Control:</span></p>
<p><img src="https://blogs.apache.org/hbase/mediaresource/0b9831a0-54aa-4c41-b560-77ba33daceb5" width="721" height="278"><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">Image 6. &nbsp;Write steps with Multiversion Concurrency Control</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Notice the new steps introduced for Multiversion Concurrency Control. &nbsp;Each write is assigned a write number (step w1), each data cell is written to the memstore with its write number (step w2, e.g. &ldquo;Cloudera [wn=1]&rdquo;) and each write completes by finishing its write number (step w3).</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Now, let&rsquo;s consider the read in Image 4, i.e. a read that begins after step &ldquo;Restaurant [wn=2]&rdquo; but before the step &ldquo;Waiter [wn=2]&rdquo;. &nbsp;From rule r1 and r2, its read point will be assigned to 1. &nbsp;From r3, it will read the values with write number of 1, leaving us with:</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><img src="https://blogs.apache.org/hbase/mediaresource/12b2c8a4-551b-4aa5-8629-874e220a91bd" width="367" height="49"><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">Image 7. &nbsp;Consistent answer with Multiversion Concurrency Control</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">A consistent response without requiring locking the row for the reads!</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Let&rsquo;s put this all together by listing the steps for a write with Multiversion Concurrency Control: (new steps required for read-write synchronization are in red):</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(0) Obtain Row Lock</span><br><span style="font-size: 16px; font-family: Arial; color: #ff0000; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(0a) Acquire New Write Number</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(1) Write to Write-Ahead-Log (WAL)</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(2) Update MemStore: write each cell to the memstore</span><br><span style="font-size: 16px; font-family: Arial; color: #ff0000; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(2a) Finish Write Number</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">(3) Release Row Lock</span><br></p>
<h2><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Conclusion</span></h2>
<p><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">In this blog we first defined HBase&rsquo;s row-level ACID guarantees. &nbsp;We then demonstrated the need for concurrency control by studying concurrent writes and introduced a row-level locking solution. &nbsp;Finally, we investigated read-write concurrency control and presented an efficient mechanism called Multiversion Concurrency Control (MVCC).</span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><br><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">This blog post is accurate as of HBase 0.92. &nbsp;HBase 0.94 has various optimizations, e.g. </span><a href="https://issues.apache.org/jira/browse/HBASE-5541"><span style="font-size: 16px; font-family: Arial; color: #1155cc; background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">HBASE-5541</span></a><span style="font-size: 16px; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> that will be described in a future blog post.</span></b></p>
<p>&nbsp;</p>

  </div><a class="u-url" href="/hbase/entry/apache_hbase_internals_locking_and" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
