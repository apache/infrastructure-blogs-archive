<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>News from OpenWebBeans-1.2.0 | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="News from OpenWebBeans-1.2.0" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The Apache OpenWebBeans team has been quite busy with big refactorings. Big improvements have been made to the proxying mechanism, the Bean scanning and the AnnotatedType handling. We managed to improve the overall performance again and now deliver almost native Java like performance for our NormalScoping proxies. Parts which are already implemented Let&#39;s take a close look at a few details of the parts we already finished and explain them briefly. Split between NormalScoping Proxies and Interceptor Proxies In OpenWebBeans 1.0.x and 1.1.x a single Bean only had one single Proxy handling for all tasks - The NormalScopedBeanInterceptorHandler. This did handle all the stuff like Interceptors, Decorators provide subclassing for abstract Decorators but also did the NormalScope handling. As result of this unified handling we only stored the native Contextual Instances in the Contexts (Session, Request map, Conversation map, etc). The negative side effect of this approach was that we had to introduce a quite hacky mechanism to regain access to the CreationalContext. Needless to say that this was not only complex but also error prone. In OpenWebBeans-1.2.0 we now maintain 2 proxies. The first one solely handles NormalScoping, then 2nd one does all the Interceptor and Decorator stuff. The most important change is that we apply the DecoratorProxy directly 1:1 on the Contextual Instance and thus don&#39;t need to do any of those weird CreationalContext hacks anymore. Instead the already intercepted/decorated instance gets stored in the Context. All NormalScope proxies now implement the Interface OwbNormalScopeProxy and have a name *$OwbNormalScopeProxy*. All Interceptor and/or Decorator proxies implement the Interface OwbInterceptorProxy and have a name *$OwbInterceptProxy*. Additionally to those 2 proxies we also introduced a new separate proxy kind for creating subclasses for abstract Decorators which now implement the marker interface OwbDecoratorProxy. Creating our own proxy bytecode For performance reasons we moved from using Javassist (where we fixed quite a few mem leaks in the past) to generating our own native Java ByteCode with ASM. We now only use reflection if really necessary. For standard NormalScoping of public methods we e.g. generate the following code. Consider a simple User class: public class User { public String getGivenName() { return &quot;Hans&quot;; } } For this class the generated bytecode of an OwbNormalScopeProxy will look like the following: public class User$OwbNormalScopeProxy0 extends User { private Provider owbContextualInstanceProvider; public String getGivenName() { return owbContextualInstanceProvider.get().getGivenName(); } } There is no bells and whistle and especially no reflection - just pure plain Java bytecode which is blazingly fast! Btw, we do very similar stuff for non-intercepted methods of intercepted/decorated classes. And we also improved the handling of intercepted methods and are now more than twice as fast as OWB-1.1.7 (which was already very fast).&nbsp; Cleaning up the Bean creation In the past we had 2 ways to create beans. If an Extension used ProcessAnnotatedType to tweak the AnnotatedType of a class then we built the Bean&lt;/i&gt; from the modified AnnotatedType&lt;/i&gt;. For cases where the AnnotatedType did not get modified we took a completely different part and created the Bean from the Class reflection information. This part came from a time where there was no AnnotatedType in the spec yet.&lt;/p&gt; In OWB-1.2.0 we now do all the Bean construction based on the AnnotatedType - regardless if it got provided by a CDI-Extension or remained unchanged. This made our codebase much easier to maintain! Arne also did a great job by introducing and cleaning up all the BeanBuilders and making the final Bean immutable.&lt;/p&gt; Parts waiting to be done More new things to come before the release: Replace Scannotation by xbean-finder. Create the initial AnnotatedTypes from the information already collected by xbean-finder instead of doing expensive Class reflection. CDI-1.0 or CDI-1.1? We initially targeted CDI-1.1 with this release. But during the development we figured that we do not yet need to. All the parts introduced so far are perfectly working with CDI-1.0 as well. Thus it looks like we gonna release OWB-1.2.0 as still being CDI-1.0. But we are well prepared to support the new features of CDI-1.1 very quickly as we already did all the preparations. Sometimes we internally already use CDI-1.1 mechanisms (like the BeanAttributs) and only have to add &#39;implements RandomCdi11FeatureInterface&#39;. This will likely be shipped as OWB-2.0.0 though when the spec hits an almost final status and the TCK is available. How to Test That&#39;s a pretty easy thing. If you have the apache.snapshots maven repo in your build, then you can just reference owb 1.2.0-SNAPSHOT in your build and you&#39;re done!" />
<meta property="og:description" content="The Apache OpenWebBeans team has been quite busy with big refactorings. Big improvements have been made to the proxying mechanism, the Bean scanning and the AnnotatedType handling. We managed to improve the overall performance again and now deliver almost native Java like performance for our NormalScoping proxies. Parts which are already implemented Let&#39;s take a close look at a few details of the parts we already finished and explain them briefly. Split between NormalScoping Proxies and Interceptor Proxies In OpenWebBeans 1.0.x and 1.1.x a single Bean only had one single Proxy handling for all tasks - The NormalScopedBeanInterceptorHandler. This did handle all the stuff like Interceptors, Decorators provide subclassing for abstract Decorators but also did the NormalScope handling. As result of this unified handling we only stored the native Contextual Instances in the Contexts (Session, Request map, Conversation map, etc). The negative side effect of this approach was that we had to introduce a quite hacky mechanism to regain access to the CreationalContext. Needless to say that this was not only complex but also error prone. In OpenWebBeans-1.2.0 we now maintain 2 proxies. The first one solely handles NormalScoping, then 2nd one does all the Interceptor and Decorator stuff. The most important change is that we apply the DecoratorProxy directly 1:1 on the Contextual Instance and thus don&#39;t need to do any of those weird CreationalContext hacks anymore. Instead the already intercepted/decorated instance gets stored in the Context. All NormalScope proxies now implement the Interface OwbNormalScopeProxy and have a name *$OwbNormalScopeProxy*. All Interceptor and/or Decorator proxies implement the Interface OwbInterceptorProxy and have a name *$OwbInterceptProxy*. Additionally to those 2 proxies we also introduced a new separate proxy kind for creating subclasses for abstract Decorators which now implement the marker interface OwbDecoratorProxy. Creating our own proxy bytecode For performance reasons we moved from using Javassist (where we fixed quite a few mem leaks in the past) to generating our own native Java ByteCode with ASM. We now only use reflection if really necessary. For standard NormalScoping of public methods we e.g. generate the following code. Consider a simple User class: public class User { public String getGivenName() { return &quot;Hans&quot;; } } For this class the generated bytecode of an OwbNormalScopeProxy will look like the following: public class User$OwbNormalScopeProxy0 extends User { private Provider owbContextualInstanceProvider; public String getGivenName() { return owbContextualInstanceProvider.get().getGivenName(); } } There is no bells and whistle and especially no reflection - just pure plain Java bytecode which is blazingly fast! Btw, we do very similar stuff for non-intercepted methods of intercepted/decorated classes. And we also improved the handling of intercepted methods and are now more than twice as fast as OWB-1.1.7 (which was already very fast).&nbsp; Cleaning up the Bean creation In the past we had 2 ways to create beans. If an Extension used ProcessAnnotatedType to tweak the AnnotatedType of a class then we built the Bean&lt;/i&gt; from the modified AnnotatedType&lt;/i&gt;. For cases where the AnnotatedType did not get modified we took a completely different part and created the Bean from the Class reflection information. This part came from a time where there was no AnnotatedType in the spec yet.&lt;/p&gt; In OWB-1.2.0 we now do all the Bean construction based on the AnnotatedType - regardless if it got provided by a CDI-Extension or remained unchanged. This made our codebase much easier to maintain! Arne also did a great job by introducing and cleaning up all the BeanBuilders and making the final Bean immutable.&lt;/p&gt; Parts waiting to be done More new things to come before the release: Replace Scannotation by xbean-finder. Create the initial AnnotatedTypes from the information already collected by xbean-finder instead of doing expensive Class reflection. CDI-1.0 or CDI-1.1? We initially targeted CDI-1.1 with this release. But during the development we figured that we do not yet need to. All the parts introduced so far are perfectly working with CDI-1.0 as well. Thus it looks like we gonna release OWB-1.2.0 as still being CDI-1.0. But we are well prepared to support the new features of CDI-1.1 very quickly as we already did all the preparations. Sometimes we internally already use CDI-1.1 mechanisms (like the BeanAttributs) and only have to add &#39;implements RandomCdi11FeatureInterface&#39;. This will likely be shipped as OWB-2.0.0 though when the spec hits an almost final status and the TCK is available. How to Test That&#39;s a pretty easy thing. If you have the apache.snapshots maven repo in your build, then you can just reference owb 1.2.0-SNAPSHOT in your build and you&#39;re done!" />
<link rel="canonical" href="http://localhost:4000/owb/entry/news_from_openwebbeans_1_2" />
<meta property="og:url" content="http://localhost:4000/owb/entry/news_from_openwebbeans_1_2" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-02-15T20:44:31-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="News from OpenWebBeans-1.2.0" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2013-02-15T20:44:31-05:00","datePublished":"2013-02-15T20:44:31-05:00","description":"The Apache OpenWebBeans team has been quite busy with big refactorings. Big improvements have been made to the proxying mechanism, the Bean scanning and the AnnotatedType handling. We managed to improve the overall performance again and now deliver almost native Java like performance for our NormalScoping proxies. Parts which are already implemented Let&#39;s take a close look at a few details of the parts we already finished and explain them briefly. Split between NormalScoping Proxies and Interceptor Proxies In OpenWebBeans 1.0.x and 1.1.x a single Bean only had one single Proxy handling for all tasks - The NormalScopedBeanInterceptorHandler. This did handle all the stuff like Interceptors, Decorators provide subclassing for abstract Decorators but also did the NormalScope handling. As result of this unified handling we only stored the native Contextual Instances in the Contexts (Session, Request map, Conversation map, etc). The negative side effect of this approach was that we had to introduce a quite hacky mechanism to regain access to the CreationalContext. Needless to say that this was not only complex but also error prone. In OpenWebBeans-1.2.0 we now maintain 2 proxies. The first one solely handles NormalScoping, then 2nd one does all the Interceptor and Decorator stuff. The most important change is that we apply the DecoratorProxy directly 1:1 on the Contextual Instance and thus don&#39;t need to do any of those weird CreationalContext hacks anymore. Instead the already intercepted/decorated instance gets stored in the Context. All NormalScope proxies now implement the Interface OwbNormalScopeProxy and have a name *$OwbNormalScopeProxy*. All Interceptor and/or Decorator proxies implement the Interface OwbInterceptorProxy and have a name *$OwbInterceptProxy*. Additionally to those 2 proxies we also introduced a new separate proxy kind for creating subclasses for abstract Decorators which now implement the marker interface OwbDecoratorProxy. Creating our own proxy bytecode For performance reasons we moved from using Javassist (where we fixed quite a few mem leaks in the past) to generating our own native Java ByteCode with ASM. We now only use reflection if really necessary. For standard NormalScoping of public methods we e.g. generate the following code. Consider a simple User class: public class User { public String getGivenName() { return &quot;Hans&quot;; } } For this class the generated bytecode of an OwbNormalScopeProxy will look like the following: public class User$OwbNormalScopeProxy0 extends User { private Provider owbContextualInstanceProvider; public String getGivenName() { return owbContextualInstanceProvider.get().getGivenName(); } } There is no bells and whistle and especially no reflection - just pure plain Java bytecode which is blazingly fast! Btw, we do very similar stuff for non-intercepted methods of intercepted/decorated classes. And we also improved the handling of intercepted methods and are now more than twice as fast as OWB-1.1.7 (which was already very fast).&nbsp; Cleaning up the Bean creation In the past we had 2 ways to create beans. If an Extension used ProcessAnnotatedType to tweak the AnnotatedType of a class then we built the Bean&lt;/i&gt; from the modified AnnotatedType&lt;/i&gt;. For cases where the AnnotatedType did not get modified we took a completely different part and created the Bean from the Class reflection information. This part came from a time where there was no AnnotatedType in the spec yet.&lt;/p&gt; In OWB-1.2.0 we now do all the Bean construction based on the AnnotatedType - regardless if it got provided by a CDI-Extension or remained unchanged. This made our codebase much easier to maintain! Arne also did a great job by introducing and cleaning up all the BeanBuilders and making the final Bean immutable.&lt;/p&gt; Parts waiting to be done More new things to come before the release: Replace Scannotation by xbean-finder. Create the initial AnnotatedTypes from the information already collected by xbean-finder instead of doing expensive Class reflection. CDI-1.0 or CDI-1.1? We initially targeted CDI-1.1 with this release. But during the development we figured that we do not yet need to. All the parts introduced so far are perfectly working with CDI-1.0 as well. Thus it looks like we gonna release OWB-1.2.0 as still being CDI-1.0. But we are well prepared to support the new features of CDI-1.1 very quickly as we already did all the preparations. Sometimes we internally already use CDI-1.1 mechanisms (like the BeanAttributs) and only have to add &#39;implements RandomCdi11FeatureInterface&#39;. This will likely be shipped as OWB-2.0.0 though when the spec hits an almost final status and the TCK is available. How to Test That&#39;s a pretty easy thing. If you have the apache.snapshots maven repo in your build, then you can just reference owb 1.2.0-SNAPSHOT in your build and you&#39;re done!","headline":"News from OpenWebBeans-1.2.0","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/owb/entry/news_from_openwebbeans_1_2"},"url":"http://localhost:4000/owb/entry/news_from_openwebbeans_1_2"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">News from OpenWebBeans-1.2.0</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2013-02-15T20:44:31-05:00" itemprop="datePublished">Feb 15, 2013
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Mark Struberg", "login"=>"struberg", "email"=>"struberg@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>The Apache OpenWebBeans team has been quite busy with big refactorings. Big improvements have been made to the proxying mechanism, the Bean scanning and the AnnotatedType handling. We managed to improve the overall performance again and now deliver almost native Java like performance for our NormalScoping proxies.</p>
<h3>Parts which are already implemented</h3>
<p>Let's take a close look at a few details of the parts we already finished and explain them briefly.</p>
<h5>Split between NormalScoping Proxies and Interceptor Proxies</h5>
<p>In OpenWebBeans 1.0.x and 1.1.x a single Bean only had one single Proxy handling for all tasks - The NormalScopedBeanInterceptorHandler. This did handle all the stuff like Interceptors, Decorators provide subclassing for abstract Decorators but also did the NormalScope handling. </p>
<p>As result of this unified handling we only stored the native Contextual Instances in the Contexts (Session, Request map, Conversation map, etc). The negative side effect of this approach was that we had to introduce a quite hacky mechanism to regain access to the CreationalContext. Needless to say that this was not only complex but also error prone.</p>
<p>In OpenWebBeans-1.2.0 we now maintain 2 proxies. The first one solely handles NormalScoping, then 2nd one does all the Interceptor and Decorator stuff. The most important change is that we apply the DecoratorProxy directly 1:1 on the Contextual Instance and thus don't need to do any of those weird CreationalContext hacks anymore. Instead the already intercepted/decorated instance gets stored in the Context.</p>
<p> All NormalScope proxies now implement the Interface <i>OwbNormalScopeProxy</i> and have a name <i>*$OwbNormalScopeProxy*</i>.</p>
<p> All Interceptor and/or Decorator proxies implement the Interface <i>OwbInterceptorProxy</i> and have a name <i>*$OwbInterceptProxy*</i>.</p>
<p>Additionally to those 2 proxies we also introduced a new separate proxy kind for creating subclasses for abstract Decorators which now implement the marker interface <i>OwbDecoratorProxy</i>.</p>
<h5>Creating our own proxy bytecode</h5>
<p> For performance reasons we moved from using Javassist (where we fixed quite a few mem leaks in the past) to generating our own native Java ByteCode with ASM. We now only use reflection if really necessary. For standard NormalScoping of public methods we e.g. generate the following code. Consider a simple User class:</p>
<pre>public class User {
   public String getGivenName() { return "Hans"; }
}
</pre>
<p>For this class the generated bytecode of an OwbNormalScopeProxy will look like the following:</p>
<pre>public class User$OwbNormalScopeProxy0 extends User {
  private Provider<user> owbContextualInstanceProvider;
 
  public String getGivenName() {
    return owbContextualInstanceProvider.get().getGivenName();
  }
}
</user></pre>
<p>There is no bells and whistle and especially no reflection - just pure plain Java bytecode which is blazingly fast!</p>
<p>Btw, we do very similar stuff for non-intercepted methods of intercepted/decorated classes. And we also improved the handling of intercepted methods and are now more than twice as fast as OWB-1.1.7 (which was already very fast).&nbsp; </p>
<h5>Cleaning up the Bean creation<br /></h5>
<p>In the past we had 2 ways to create beans. If an Extension used ProcessAnnotatedType to tweak the AnnotatedType of a class then we built the <i>Bean<T></i> from the modified <i>AnnotatedType<T></i>. For cases where the AnnotatedType did not get modified we took a completely different part and created the Bean from the Class reflection information. This part came from a time where there was no AnnotatedType in the spec yet.</p>
<p>In OWB-1.2.0 we now do all the Bean<T> construction based on the AnnotatedType - regardless if it got provided by a CDI-Extension or remained unchanged. This made our codebase much easier to maintain! Arne also did a great job by introducing and cleaning up all the BeanBuilders and making the final Bean<T> immutable.</p>
<h3>Parts waiting to be done <br /></h3>
<p>More new things to come before the release:</p>
<ul>
<li>Replace Scannotation by xbean-finder.</li>
<li> Create the initial AnnotatedTypes from the information already collected by xbean-finder instead of doing expensive Class reflection. </li>
</ul>
<h3>CDI-1.0 or CDI-1.1?</h3>
<p> We initially targeted CDI-1.1 with this release. But during the development we figured that we do not yet need to. All the parts introduced so far are perfectly working with CDI-1.0 as well. Thus it looks like we gonna release OWB-1.2.0 as still being CDI-1.0. But we are well prepared to support the new features of CDI-1.1 very quickly as we already did all the preparations. Sometimes we internally already use CDI-1.1 mechanisms (like the BeanAttributs) and only have to add 'implements RandomCdi11FeatureInterface'. This will likely be shipped as OWB-2.0.0 though when the spec hits an almost final status and the TCK is available. </p>
<h3>How to Test<br /></h3>
<p>That's a pretty easy thing. If you have the <a title="apache.snapshots maven repo" href="https://repository.apache.org/content/groups/snapshots/org/apache/openwebbeans/">apache.snapshots maven repo</a> in your build, then you can just reference owb 1.2.0-SNAPSHOT in your build and you're done!</p>

  </div><a class="u-url" href="/owb/entry/news_from_openwebbeans_1_2" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
