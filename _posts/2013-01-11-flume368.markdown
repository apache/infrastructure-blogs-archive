---
layout: post
title: Flume Performance Tuning - part 1
date: '2013-01-11T20:05:40+00:00'
categories: flume
---
<p><strong id="internal-source-marker_0.846074462402612" style="font-weight: normal;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">This is part 1 in a series of articles about tuning the performance of </span><a href="http://flume.apache.org/"><span style="background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">Apache Flume</span></a><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">, a distributed, reliable, and available service for efficiently collecting, aggregating, and moving large amounts of event data.</span></strong></p> 
  <p><strong id="internal-source-marker_0.846074462402612" style="font-weight: normal;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><strong id="internal-source-marker_0.846074462402612" style="font-weight: normal;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">To kick off this series, I’d like to start off discussing some important Flume concepts that come into play when tuning your Flume flows for maximum performance: the </span><span style="background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">channel</span><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> and the </span><span style="background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">transaction batch size</span><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">.</span></strong></strong> </p> 
  <p><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"><b>Setting up a data flow</b></span></p><strong style="font-weight: normal;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Imagine you want to take a heavy stream of user activity from your application server logs and store that onto your Hadoop cluster for analytics. If you have a large deployment of application servers, you would likely want to build a fan-in architecture, where you are sending data from many nodes to relatively fewer nodes.</span></strong> 
  <p> </p><strong id="internal-source-marker_0.846074462402612"> 
    <p style="font-weight: normal;"> </p> 
    <div style="text-align: center;"><strong id="internal-source-marker_0.846074462402612"><img src="https://blogs.apache.org/flume/mediaresource/a800177c-759c-4b7b-a34b-e9d6a7abeb17" alt="A Tiered Flume Topology" border="1" /></strong></div><br /><span style="font-weight: normal;">If you are sending these user events one at a time, each time waiting for acknowledgment that it was delivered, your throughput may be limited by network latency. Naturally, you would want to batch up the events into larger transactions, so that you amortize the latency of the acknowledgment over a larger number of events and therefore get more throughput. </span><br /> 
    <p style="font-weight: normal;"> </p> 
    <p style="font-weight: normal;"><span style="background-color: transparent; font-weight: bold; vertical-align: baseline; white-space: pre-wrap;">Channels</span></p> 
    <p><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">So, what happens if the storage tier goes down momentarily, as in the case of a network partition? What happens to the events if a Flume agent machine crashes? We still want to be able to serve our users on the application tier and retain our data somehow. In order to accomplish this, we need a buffering mechanism on each agent that allows it to store events in the case of downstream failures or slowdowns. In Flume, the </span><span style="font-weight: normal; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">channel</span><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> is what persists events at each hop in the flow. Below is a diagram that illustrates where the channel sits in the architecture of a Flume agent.</span><strong id="internal-source-marker_0.846074462402612"> </strong></p> 
    <p style="display: inline !important;"><strong id="internal-source-marker_0.846074462402612"> </strong></p> 
    <p> </p> 
    <p style="font-weight: normal;"> </p> 
    <p style="text-align: center; font-weight: normal;"><img src="https://blogs.apache.org/flume/mediaresource/8962fbde-7f23-4b43-813a-f150c9afbc0a" alt="Flume agent architecture" /><br /><strong id="internal-source-marker_0.846074462402612" style="font-weight: normal;"> </strong></p> 
    <p style="font-weight: normal; display: inline !important;"><strong id="internal-source-marker_0.846074462402612" style="font-weight: normal;"> </strong></p><strong id="internal-source-marker_0.846074462402612"> 
      <h2 style="font-weight: normal; display: inline !important;"> </h2> 
      <p><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Memory Channel vs. File Channel</span></p> </strong><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">An important decision to make when designing your Flume flow is what type of channel you want to use. At the time of this writing, the two recommended channels are the </span><a href="http://flume.apache.org/FlumeUserGuide.html#file-channel" style="font-weight: normal;"><span style="background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">file channel</span></a><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> and the </span><a href="http://flume.apache.org/FlumeUserGuide.html#memory-channel" style="font-weight: normal;"><span style="background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">memory channel</span></a><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">. The file channel is a </span><span style="font-weight: normal; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">durable </span><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">channel, as it persists all events that are stored in it to disk. So, even if the Java virtual machine is killed, or the operating system crashes or reboots, events that were not successfully transferred to the next agent in the pipeline will still be there when the Flume agent is restarted. The memory channel is a volatile channel, as it buffers events in memory only: if the Java process dies, any events stored in the memory channel are lost. Naturally, the memory channel also exhibits very low put/take latencies compared to the file channel, even for a batch size of 1. Since the number of events that can be stored is limited by available RAM, its ability to buffer events in the case of temporary downstream failure is quite limited. The file channel, on the other hand, has far superior buffering capability due to utilizing cheap, abundant hard disk space.</span><br /> 
    <p><span style="background-color: transparent; font-weight: bold; vertical-align: baseline; white-space: pre-wrap;">Flume event batching </span></p> 
    <p><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">As mentioned earlier, Flume can batch events. </span><span style="font-weight: bold; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">The batch size is the maximum number of events that a sink or client will attempt to take from a channel in a single transaction</span><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">. Tuning the batch size trades throughput vs. latency and duplication under failure. With a small batch size, throughput decreases, but the risk of event duplication is reduced if a failure were to occur. With a large batch size, you get much better throughput, but increased latency, and in the case of a transaction failure, the number of possible duplicates increases.</span></p> 
    <p><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><strong id="internal-source-marker_0.846074462402612"><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Transactions are a critical concept in Flume, because the delivery and durability guarantees made by channels only take effect at the end of each successful transaction. For example, when a source receives or generates an event, in order to store that event into a channel a transaction must first be opened on that channel. Within the transaction, the source puts up to the batch size number of events into the channel, and on success </span><span style="font-weight: normal; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">commits</span><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> the transaction. A sink must go through the same process of operating within a transaction when taking events from a channel.</span></strong></p> 
    <p><strong id="internal-source-marker_0.846074462402612"><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span></strong><strong id="internal-source-marker_0.846074462402612"> </strong></p> 
    <p style="display: inline !important;"><strong id="internal-source-marker_0.846074462402612"><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Batch size is configured at the sink level. The larger the batch, the faster the channels operate (but there is a caveat). In the case of the file channel, this speed difference is because all buffers are flushed and then synced to disk when each transaction is committed. A disk sync is a time-consuming operation (it may take several milliseconds), but it is required to ensure the durability of the data. Likewise, with the memory channel, there is a memory synchronization step when each transaction is committed. Of course, memory synchronization is much faster than a disk sync. For more information on the inner workings of the file channel, please see Brock Noland's </span><a href="https://blogs.apache.org/flume/entry/apache_flume_filechannel" style="font-weight: normal;"><span style="background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">article about the Apache Flume File Channel</span></a><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">.</span></strong></p> 
    <p><strong id="internal-source-marker_0.846074462402612"><strong id="internal-source-marker_0.846074462402612"><strong id="internal-source-marker_0.846074462402612"><strong id="internal-source-marker_0.846074462402612"> </strong></strong></strong></strong></p> 
    <p style="display: inline !important;"><strong id="internal-source-marker_0.846074462402612"><strong id="internal-source-marker_0.846074462402612"><strong id="internal-source-marker_0.846074462402612"><strong id="internal-source-marker_0.846074462402612"><strong id="internal-source-marker_0.846074462402612"><strong id="internal-source-marker_0.846074462402612"><strong id="internal-source-marker_0.846074462402612"><strong id="internal-source-marker_0.846074462402612"><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">The downside of using a large batch size is that if there is some type of failure in the middle of a transaction, such as a downstream host or network failure, there is a possibility of duplicates being created. So, for example, if you set your batch size to 1000, and the machine you are writing to goes offline, duplicates may be generated in groups of up to 1000. This may occur in special cases, for example, if the events got written to the downstream machine but then the connection failed before it could acknowledge that it had received them. However, duplicate events will only appear in exceptional circumstances.</span></strong></strong></strong></strong></strong></strong></strong></strong></p></strong> 
  <p><span style="background-color: transparent; font-weight: bold; vertical-align: baseline; white-space: pre-wrap;">Choosing a batch size</span></p><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">To squeeze all the performance possible out of a Flume system, batch sizes should be tuned with care through experimentation. While I will get into this in more detail in the follow-up to this post, here are some rules of thumb for selecting batch sizes.</span><br /> 
  <p style="font-weight: normal;"> </p> 
  <ol style="font-weight: normal; margin-top: 0pt; margin-bottom: 0pt;"> 
    <li dir="ltr" style="list-style-type: decimal; background-color: transparent; vertical-align: baseline;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Start off with batch sizes equal to the sum of the batch sizes of the input streams coming into that tier. For example, if you have a downstream Flume agent running an Avro source with 10 upstream agents sending events via Avro sinks using a batch size of 100 each, consider starting that downstream agent with a batch size of 1,000. Tune / experiment from there.</span></li> 
    <li dir="ltr" style="list-style-type: decimal; background-color: transparent; vertical-align: baseline;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">If you find yourself setting the batch size very high (say, higher than 10,000) then consider adding another Sink instead, in order to increase the parallelism (each sink typically runs on its own thread). Say you were going to use one HDFS sink with a batch size of 20,000. Experiment with using 2 HDFS sinks with batch sizes of 5,000 or 10,000 to see if that helps more.</span></li> 
    <li dir="ltr" style="list-style-type: decimal; background-color: transparent; vertical-align: baseline;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Prefer the lowest batch size that gives you acceptable performance.</span></li> 
    <li dir="ltr" style="list-style-type: decimal; background-color: transparent; vertical-align: baseline;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Monitor the steady-state channel sizes to get more tuning insight (more on this in the next article).</span></li> 
  </ol> 
  <p style="font-weight: normal;"> </p> 
  <p><span style="background-color: transparent; font-weight: bold; vertical-align: baseline; white-space: pre-wrap;">Different batch sizes in different situations</span></p> 
  <p><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Due to the performance / duplication tradeoff of the batch size parameter, I often see varying batch size settings depending on the use case. In the case of using Flume to write to HBase using the HBase Sink, incrementing counters, a smaller batch size on the order of 100 is often used to reduce the impact in case of hiccups in the system. On the other hand, with an HDFS sink, in order to get maximum throughput, I see people running with batch sizes of 1,000 or even 10,000, since typically they can easily run map-reduce jobs to de-duplicate the data at processing time. Note that when writing large events with large batch sizes to HDFS, often other parameters need to be increased as well. One such parameter is </span><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">hdfs.callTimeout</span><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">, which may be increased to 60 seconds or more to account for the long tail of occasional higher-latency calls to HDFS.</span></p> 
  <p><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><strong id="internal-source-marker_0.846074462402612"><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">At the other end of the spectrum, in cases where batching events at the application (Flume client) tier is not possible, the memory channel is often used at the collector-tier Flume agent (or a localhost agent on the app servers) to get acceptable performance with a batch size of 1, while using larger batch sizes and file channels in the downstream agents in order to get most of the benefits of durability there. For the best performance, however, all tiers including the client/application tier would perform some level of batching. (Please see above diagram for an illustration of the tiers referenced in this scenario.)</span></strong><br /> </p> 
  <p><span style="background-color: transparent; font-weight: bold; vertical-align: baseline; white-space: pre-wrap;">Configuration parameters and gotchas</span></p> 
  <p><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">The actual parameter used to set the batch size varies between sinks, but for most sinks it’s simply called </span><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">batchSize</span><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> or </span><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">batch-size.</span><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> For the HDFS sink, it’s actually called </span><a href="http://flume.apache.org/FlumeUserGuide.html#hdfs-sink" style="font-weight: normal;"><span style="background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">hdfs.batchSize</span></a><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> for historical reasons; I recommend setting hdfs.txnEventMax to the same value as hdfs.batchSize for simplicity. Historically, in the HDFS sink, the number of events taken in a single transaction can be different from the number of events written to HDFS before a sync() operation; In practice, there is little reason these should not be set to the same value.</span></p> 
  <p><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span><strong id="internal-source-marker_0.846074462402612"> </strong></p> 
  <p style="display: inline !important;"><strong id="internal-source-marker_0.846074462402612"><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">One potentially confusing gotcha when tuning the batch size on a sink is that it must be less than or equal to the </span><a href="http://flume.apache.org/FlumeUserGuide.html#memory-channel" style="font-weight: normal;"><span style="background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">transactionCapacity</span></a><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> set on the corresponding channel. The </span><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">transactionCapacity</span><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> should be set to the value of the largest batch size that will be used to store or remove events from that channel.</span></strong></p> 
  <p><strong id="internal-source-marker_0.846074462402612"><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"></span></strong><span style="font-weight: bold; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">tl;dr</span><span style="font-weight: bold; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">:</span><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> Below is a “cheat sheet” batch size tuning summary for your convenience. Please note that these are </span><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"><i>just starting points</i></span><span style="font-weight: normal; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> for tuning.</span> </p> 
  <p> </p> 
  <table style="border: none; border-collapse: collapse; width: 624px;"><colgroup><col width="188" /><col width="228" /><col width="*" /></colgroup> 
    <tbody> 
      <tr style="height: 0px;"> 
        <td style="border: 1px solid #000000; vertical-align: top; padding: 7px;"><span style="background-color: transparent; font-weight: bold; vertical-align: baseline; white-space: pre-wrap;">Sink Type</span></td> 
        <td style="border: 1px solid #000000; vertical-align: top; padding: 7px;"><span style="background-color: transparent; font-weight: bold; vertical-align: baseline; white-space: pre-wrap;">Config parameter</span></td> 
        <td style="border: 1px solid #000000; vertical-align: top; padding: 7px;"><span style="background-color: transparent; font-weight: bold; vertical-align: baseline; white-space: pre-wrap;">Typical value</span></td> 
      </tr> 
      <tr style="height: 0px;"> 
        <td style="border: 1px solid #000000; vertical-align: top; padding: 7px;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Avro</span></td> 
        <td style="border: 1px solid #000000; vertical-align: top; padding: 7px;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">batch-size</span></td> 
        <td style="border: 1px solid #000000; vertical-align: top; padding: 7px;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">100</span></td> 
      </tr> 
      <tr style="height: 0px;"> 
        <td style="border: 1px solid #000000; vertical-align: top; padding: 7px;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">HDFS</span></td> 
        <td style="border: 1px solid #000000; vertical-align: top; padding: 7px;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">hdfs.batchSize, hdfs.txnEventMax</span></td> 
        <td style="border: 1px solid #000000; vertical-align: top; padding: 7px;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">1000</span></td> 
      </tr> 
      <tr style="height: 0px;"> 
        <td style="border: 1px solid #000000; vertical-align: top; padding: 7px;"><span style="vertical-align: baseline; white-space: pre-wrap;">HBaseSink</span></td> 
        <td style="border: 1px solid #000000; vertical-align: top; padding: 7px;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">batchSize</span></td> 
        <td style="border: 1px solid #000000; vertical-align: top; padding: 7px;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">100</span></td> 
      </tr> 
      <tr style="height: 0px;"> 
        <td style="border: 1px solid #000000; vertical-align: top; padding: 7px;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">AsyncHBaseSink</span></td> 
        <td style="border: 1px solid #000000; vertical-align: top; padding: 7px;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">batchSize</span></td> 
        <td style="border: 1px solid #000000; vertical-align: top; padding: 7px;"><span style="background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">100</span> </td> 
      </tr> 
    </tbody> 
  </table> 
  <p><span style="background-color: transparent; white-space: pre-wrap;">That’s all I have space for in one blog post. Please leave feedback and questions in the comments. Look for another post in the future with tips on using Flume’s monitoring capabilities to take advantage of important information which can aid you in your quest for optimum performance.</span></p> 
  <p><i>Mike Percy is a committer and PMC member on the Apache Flume project.</i></p>
