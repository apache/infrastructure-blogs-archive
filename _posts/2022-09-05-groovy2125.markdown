---
layout: post
title: Solving cryptarithmetic puzzles with Groovy and constraint programming using
  Choco, JaCoP, and OR-Tools
date: '2022-09-05T13:43:31+00:00'
categories: groovy
---
<p><br></p>
<h3>Introduction</h3><p>When writing solutions to problems, we frequently strive to hide away implementation details. In Object-oriented (OO) programming, we might build a rich hierarchy of classes with well-thought out methods so that our final solution can be expressed in terms of simple nouns and verbs (methods and class instances) in our domain model. When applying functional programming idioms, we will strive to emphasise the relationship between inputs and outputs and hide away side effects and iterative steps. <i><a href="https://en.wikipedia.org/wiki/Constraint_programming" target="_blank">Constraint programming</a></i> (within the same family as logic programming) also strives to hide away details. Instead of expressing an iterative implementation, it focuses on expressing declarative properties of a solution. A solver is responsible for working out the exact implementation steps.</p><p>When using constraint programming, we develop a model consisting of <i>variables</i>, the <i>domain</i> of values each variable may hold, and additional <i>constraints</i> between the variables. A solver does all the work. It may employ heuristic searching, inference, propagation, symmetry and backtracking to find possible solutions. We may be able to (or want to, or need to) guide the solver as to which techniques and strategies it should use. Constraint programming has been used to solve various kinds of problems including scheduling problems, and excels at problems with combinatorial possibilities that are too irregular for other mathematical optimisations. Frequently used illustrative problems are Sudoku and Wordle solvers, <a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle" target="_blank">N-Queen problems</a>, and other kinds of puzzles. We'll just look at cryptarithmetic puzzles.</p>

<h3>Cryptarithmetic Problems</h3>

<p><a href="https://en.wikipedia.org/wiki/Verbal_arithmetic" target="_blank">Cryptarithmetic problems</a> (also known as alphametics, verbal arithmetic, cryptarithm, and word addition) are a type of mathematical game where a mathematical equation is presented where digits in the equation are replaced by letters. Traditionally, each letter usually represents a unique number, and numbers don't start with the digit zero. If we look at one <a href="https://en.wikipedia.org/wiki/Verbal_arithmetic" target="_blank">sample problem</a>:</p>
<p></p><p></p>
<table><tbody>
<tr><td style="text-align:center; padding-top:0px; padding-bottom:0px;"></td><td style="text-align:center; padding-top:0px; padding-bottom:0px;"></td><td style="text-align:center; padding-top:0px; padding-bottom:0px; font-family: monospace; font-size: 22px;">T</td><td style="text-align:center; padding-left:3px; padding-right:3px; font-family: monospace; font-size: 22px;">O</td></tr>
<tr style="border-bottom:1pt solid black;"><td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">+</td><td></td><td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">G</td><td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">O</td></tr>
<tr><td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">=</td><td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">O</td><td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">U</td><td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">T</td></tr>
</tbody>
</table><p></p>
<p>We can reason about what the solution can be by hand:</p><ul><li>T, O, U, and G must be all different (game rule)<br></li><li>T, G, and O will be between 1 and 9, and U is between 0 and 9 (game rule)</li><li>If we added the two biggest 2-digit numbers, (99 + 99) we'd get 198, so <i><b>O must be 1</b></i></li><li>Looking at the right-most "units" column, 1 + 1 equals 2, so <i><b>T must be 2</b></i></li><li>Looking at the "tens" column, we know there is a carry of 1 (since O is 1) and we know T is 2, so G must be 8 or 9. If G was 9, U would be 1 but it can't be the same as O, so <i><b>G must be 8</b></i> and <i><b>U must be 0</b></i>.</li></ul><p>When solving by hand, we typically reason about individual columns and account for the "carry" to the next column. We'll come back to this point later but first, let's look at a slightly bigger problem:</p>
<table><tbody>

<tr><td style="font-family:monospace; font-size: 22px; text-align:center; padding-top:0px; padding-bottom:0px;"></td><td style="text-align:center; padding-top:0px; padding-bottom:0px;"></td><td style="font-family:monospace; font-size: 22px; text-align:center; padding-top:0px; padding-bottom:0px;">S</td><td style="font-family:monospace; font-size: 22px; text-align:center; padding-top:0px; padding-bottom:0px;">E</td><td style="text-align:center; padding-top:0px; padding-bottom:0px; font-family: monospace; font-size: 22px;">N</td><td style="text-align:center; padding-left:3px; padding-right:3px; font-family: monospace; font-size: 22px;">D</td></tr>

<tr style="border-bottom:1pt solid black;"><td style="font-family:monospace; font-size: 22px; text-align:center; padding-top:0px; padding-bottom:0px;">+</td><td style="text-align:center; padding-top:0px; padding-bottom:0px;"></td><td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">M</td><td style="font-family:monospace; font-size: 22px; text-align:center; padding-top:0px; padding-bottom:0px;">O</td><td style=" text-align:center; padding:3px; font-family:monospace; font-size:22px;">R</td><td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">E</td></tr>

<tr><td style="font-family:monospace; font-size: 22px; text-align:center; padding:3px;">=</td><td style="text-align:center; padding:3px; font-family:monospace; font-size: 22px;">M</td><td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">O</td><td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">N</td><td style="text-align:center; padding:3px; font-family: monospace; font-size: 22px;">E</td><td style="font-family:monospace; font-size: 22px; text-align:center; padding:3px;">Y</td></tr>

</tbody>
</table>
<h3>Solving with Brute Force</h3>

<p>This problem isn't huge, so we can solve with brute force. We simply try all possible values for the letters in the puzzle:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">for </span>(s <span style="color:#cc7832;">in </span><span style="color:#6897bb;">1</span>..<span style="color:#6897bb;">9</span>)<br>    <span style="color:#cc7832;">for </span>(e <span style="color:#cc7832;">in </span><span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9</span>)<br>        <span style="color:#cc7832;">for </span>(n <span style="color:#cc7832;">in </span><span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9</span>)<br>            <span style="color:#cc7832;">for </span>(d <span style="color:#cc7832;">in </span><span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9</span>)<br>                <span style="color:#cc7832;">for </span>(m <span style="color:#cc7832;">in </span><span style="color:#6897bb;">1</span>..<span style="color:#6897bb;">9</span>)<br>                    <span style="color:#cc7832;">for </span>(o <span style="color:#cc7832;">in </span><span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9</span>)<br>                        <span style="color:#cc7832;">for </span>(r <span style="color:#cc7832;">in </span><span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9</span>)<br>                            <span style="color:#cc7832;">for </span>(y <span style="color:#cc7832;">in </span><span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9</span>)<br>                                <span style="color:#cc7832;">if </span>([s, e, n, d, m, o, r, y].toSet().size() == <span style="color:#6897bb;">8</span>) {<br>                                    <span style="color:#cc7832;">def </span>send = <span style="color:#6897bb;">1000 </span>* s + <span style="color:#6897bb;">100 </span>* e + <span style="color:#6897bb;">10 </span>* n + d<br>                                    <span style="color:#cc7832;">def </span>more = <span style="color:#6897bb;">1000 </span>* m + <span style="color:#6897bb;">100 </span>* o + <span style="color:#6897bb;">10 </span>* r + e<br>                                    <span style="color:#cc7832;">def </span>money = <span style="color:#6897bb;">10000 </span>* m + <span style="color:#6897bb;">1000 </span>* o + <span style="color:#6897bb;">100 </span>* n + <span style="color:#6897bb;">10 </span>* e + y<br>                                    <span style="color:#cc7832;">if </span>(send + more == money) {<br>                                        println <span style="color:#6a8759;">"s = </span>$s<span style="color:#6a8759;">, e = </span>$e<span style="color:#6a8759;">, n = </span>$n<span style="color:#6a8759;">, d = </span>$d<span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">                                        </span>println <span style="color:#6a8759;">"m = </span>$m<span style="color:#6a8759;">, o = </span>$o<span style="color:#6a8759;">, r = </span>$r<span style="color:#6a8759;">, y = </span>$y<span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">                                    </span>}<br>                                }<br></pre><p>This isn't very efficient though. It calculates 81 million combinations for the variables before skipping all but 1.5 million of them (since most won't be unique). All up it might execute in the low tens of seconds.</p><p>Alternatively, Groovy supports calculating permutations, so we can simplify our solution to a single for loop (with some tests to eliminate unhelpful iterations):</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>digits = <span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9<br></span><span style="color:#cc7832;">for </span>(p <span style="color:#cc7832;">in </span>digits.permutations()) {<br>    <span style="color:#cc7832;">if </span>(p[-<span style="color:#6897bb;">1</span>] &lt; p[-<span style="color:#6897bb;">2</span>]) <span style="color:#cc7832;">continue<br></span><span style="color:#cc7832;">    def </span>(s, e, n, d, m, o, r, y) = p<br>    <span style="color:#cc7832;">if </span>(s == <span style="color:#6897bb;">0 </span>|| m == <span style="color:#6897bb;">0</span>) <span style="color:#cc7832;">continue<br></span><span style="color:#cc7832;">    def </span>send = <span style="color:#6897bb;">1000 </span>* s + <span style="color:#6897bb;">100 </span>* e + <span style="color:#6897bb;">10 </span>* n + d<br>    <span style="color:#cc7832;">def </span>more = <span style="color:#6897bb;">1000 </span>* m + <span style="color:#6897bb;">100 </span>* o + <span style="color:#6897bb;">10 </span>* r + e<br>    <span style="color:#cc7832;">def </span>money = <span style="color:#6897bb;">10000 </span>* m + <span style="color:#6897bb;">1000 </span>* o + <span style="color:#6897bb;">100 </span>* n + <span style="color:#6897bb;">10 </span>* e + y<br>    <span style="color:#cc7832;">if </span>(send + more == money) {<br>        println <span style="color:#6a8759;">"s = </span>$s<span style="color:#6a8759;">, e = </span>$e<span style="color:#6a8759;">, n = </span>$n<span style="color:#6a8759;">, d = </span>$d<span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">        </span>println <span style="color:#6a8759;">"m = </span>$m<span style="color:#6a8759;">, o = </span>$o<span style="color:#6a8759;">, r = </span>$r<span style="color:#6a8759;">, y = </span>$y<span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>}<br>}<br></pre><p>This has the advantage of only generating unique combinations. It will execute in seconds.</p><p>Running either of these solutions yields:</p>
<pre>s = 9, e = 5, n = 6, d = 7
m = 1, o = 0, r = 8, y = 2
</pre>

<h3>Using Constraint Programming</h3>

<p>For the brute force approaches, we had a condition which checked any potential candidate answer to see if it was a correct solution. We had to be very explicit in how we wanted the potential candidates to be created. For constraint programming, we instead define variables to represent the problem, any known bounds on those variables, and we specify any other known properties of the solution, which in our case will be something similar to the condition we had to check if the answer was correct previously. Let's examine how to do that with three libraries, one with a variation.</p>

<h4>Choco</h4><p>Here is the code using the <a href="https://choco-solver.org/" target="_blank">Choco</a> library:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">new </span>Model(<span style="color:#6a8759;">"SEND+MORE=MONEY"</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(S, M) = [<span style="color:#6a8759;">'S'</span>, <span style="color:#6a8759;">'M'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(E, N, D, O, R, Y) = [<span style="color:#6a8759;">'E'</span>, <span style="color:#6a8759;">'N'</span>, <span style="color:#6a8759;">'D'</span>, <span style="color:#6a8759;">'O'</span>, <span style="color:#6a8759;">'R'</span>, <span style="color:#6a8759;">'Y'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="font-weight:bold;">    </span>allDifferent(S, E, N, D, M, O, R, Y).post()<br><br><span style="color:#808080;">    </span>IntVar[] ALL = [<br>            S, E, N, D,<br>            M, O, R, E,<br>         M, O, N, E, Y ]<br>    <span style="color:#cc7832;">int</span>[] COEFFS = [<br>            <span style="color:#6897bb;">1000</span>,  <span style="color:#6897bb;">100</span>,  <span style="color:#6897bb;">10</span>,  <span style="color:#6897bb;">1</span>,<br>            <span style="color:#6897bb;">1000</span>,  <span style="color:#6897bb;">100</span>,  <span style="color:#6897bb;">10</span>,  <span style="color:#6897bb;">1</span>,<br>   -<span style="color:#6897bb;">10000</span>, -<span style="color:#6897bb;">1000</span>, -<span style="color:#6897bb;">100</span>, -<span style="color:#6897bb;">10</span>, -<span style="color:#6897bb;">1 </span>]<br><br>    scalar(ALL, COEFFS, <span style="color:#6a8759;">"="</span>, <span style="color:#6897bb;">0</span>).post()<br><br>    println <span style="color:#9876aa;">solver</span>.findSolution()<br><span style="font-weight:bold;">}<br></span></pre><p>We define our variables and their bounds (domain). We use an <code>allDifferent</code> global constraint to specify the uniqueness requirement and a <code>scalar</code> constraint that ensures that our variables multiplied by their respective scalar coefficients equal 0. This lets us factor in whether the particular variable is representing the "units" column, the "10s" column, the "100s" column etc. This captures the "puzzle addition" constraint. We then ask the solver to find the solution. We could just as easily have asked for all solutions (if more than one existed).</p><p>This is typical of how we solve such problems. We either define constraints directly between one or more variables or use whatever global constraints our library might support. If our library doesn't support the constraint we need, we find a way to express it using multiple simpler constraints.</p><p>The end result is that our code is more declarative than our brute force approaches, and the solution is found in tens of milliseconds. The solver has very efficient strategies for solving such puzzles.</p>
<h4 style="font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(0, 0, 0);"><span style="color: inherit; font-family: inherit;">JaCoP</span><br></h4>
<p>We can solve the same problem using <a href="https://github.com/radsz/jacop" target="_blank">JaCoP</a>:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>store = <span style="color:#cc7832;">new </span>Store()<br><span style="color:#cc7832;">def </span>(S, M) = [<span style="color:#6a8759;">'S'</span>, <span style="color:#6a8759;">'M'</span>].collect <span style="font-weight:bold;">{ </span><span style="color:#cc7832;">new </span>IntVar(store, it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="color:#cc7832;">def </span>(E, N, D, O, R, Y) = [<span style="color:#6a8759;">'E'</span>, <span style="color:#6a8759;">'N'</span>, <span style="color:#6a8759;">'D'</span>, <span style="color:#6a8759;">'O'</span>, <span style="color:#6a8759;">'R'</span>, <span style="color:#6a8759;">'Y'</span>].collect <span style="font-weight:bold;">{ </span><span style="color:#cc7832;">new </span>IntVar(store, it, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="color:#cc7832;">var </span>ctr = <span style="color:#cc7832;">new </span>Alldifferent(S, E, N, D, M, O, R, Y)<br>store.impose(ctr)<br><br>IntVar[] ALL = [<br>                S,   E,   N,   D,<br>                M,   O,   R,   E,<br>           M,   O,   N,   E,   Y ]<br><span style="color:#cc7832;">int</span>[] COEFFS = [<br>             <span style="color:#6897bb;">1000</span>,  <span style="color:#6897bb;">100</span>,  <span style="color:#6897bb;">10</span>,  <span style="color:#6897bb;">1</span>,<br>             <span style="color:#6897bb;">1000</span>,  <span style="color:#6897bb;">100</span>,  <span style="color:#6897bb;">10</span>,  <span style="color:#6897bb;">1</span>,<br>    -<span style="color:#6897bb;">10000</span>, -<span style="color:#6897bb;">1000</span>, -<span style="color:#6897bb;">100</span>, -<span style="color:#6897bb;">10</span>, -<span style="color:#6897bb;">1 </span>]<br><span style="color:#cc7832;">var </span>lin = <span style="color:#cc7832;">new </span>LinearInt(ALL, COEFFS, <span style="color:#6a8759;">"=="</span>, <span style="color:#6897bb;">0</span>)<br>store.impose(lin)<br><br><span style="color:#cc7832;">var </span>label = <span style="color:#cc7832;">new </span>DepthFirstSearch()<br><span style="color:#cc7832;">var </span>select = <span style="color:#cc7832;">new </span>InputOrderSelect(store, ALL, <span style="color:#cc7832;">new </span>IndomainMin())<br>label.labeling(store, select)<span style="color:#6a8759;"><br></span></pre><p>There are some slight differences in this API, but nearly everything has a one-to-one correspondence to what we saw earlier. We are explicitly selecting search strategies and selection strategies here whereas with Choco, defaults were chosen for us. In both cases, explicit creation of such classes allows the strategies to be altered for particular scenarios if needed.</p><p>When run, the output looks like this:</p>
<pre>Labeling has finished with return value of true
DFS1: DFS([S = 9, E = 5, N = 6, D = 7, M = 1, O = 0, R = 8, Y = 2], InputOrder, (org.jacop.search.IndomainMin@45394b31))
</pre>
<p>We can see here the code is very similar as is the execution time.</p>

<h4>OR-Tools</h4><p>We can repeat the solution using <a href="https://developers.google.com/optimization/cp" target="_blank">OR-Tools</a>. Here is the code:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">Loader.<span style="color:#9876aa;font-style:italic;">loadNativeLibraries</span>()<br><br><span style="color:#cc7832;">new </span>Solver(<span style="color:#6a8759;">'Send+More=Money'</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>s = makeIntVar(<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'s'</span>)<br>    <span style="color:#cc7832;">def </span>e = makeIntVar(<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'e'</span>)<br>    <span style="color:#cc7832;">def </span>n = makeIntVar(<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'n'</span>)<br>    <span style="color:#cc7832;">def </span>d = makeIntVar(<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'d'</span>)<br>    <span style="color:#cc7832;">def </span>m = makeIntVar(<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'m'</span>)<br>    <span style="color:#cc7832;">def </span>o = makeIntVar(<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'o'</span>)<br>    <span style="color:#cc7832;">def </span>r = makeIntVar(<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'r'</span>)<br>    <span style="color:#cc7832;">def </span>y = makeIntVar(<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>, <span style="color:#6a8759;">'y'</span>)<br><br>    IntVar[] all = [s, e, n, d, m, o, r, y]<br>    IntVar[] scalar = [s, e, n, d, m, o, r, e, m, o, n, e, y]<br>    <span style="color:#cc7832;">int</span>[] coeffs = [<br>                 <span style="color:#6897bb;">1000</span>,  <span style="color:#6897bb;">100</span>,  <span style="color:#6897bb;">10</span>,  <span style="color:#6897bb;">1</span>,  <span style="color:#808080;">//  S E N D +<br></span><span style="color:#808080;">                 </span><span style="color:#6897bb;">1000</span>,  <span style="color:#6897bb;">100</span>,  <span style="color:#6897bb;">10</span>,  <span style="color:#6897bb;">1</span>,  <span style="color:#808080;">//  M O R E =<br></span><span style="color:#808080;">        </span>-<span style="color:#6897bb;">10000</span>, -<span style="color:#6897bb;">1000</span>, -<span style="color:#6897bb;">100</span>, -<span style="color:#6897bb;">10</span>, -<span style="color:#6897bb;">1   </span><span style="color:#808080;">//  M O N E Y<br></span><span style="color:#808080;">    </span>]<br><br>    addConstraint(makeScalProdEquality(scalar, coeffs, <span style="color:#6897bb;">0</span>))<br>    addConstraint(makeAllDifferent(all))<br><br>    <span style="color:#cc7832;">def </span>db = makePhase(all, <span style="color:#9876aa;font-style:italic;">INT_VAR_DEFAULT</span>, <span style="color:#9876aa;font-style:italic;">INT_VALUE_DEFAULT</span>)<br>    newSearch(db)<br>    <span style="color:#cc7832;">while </span>(nextSolution()) {<br>        println all.join(<span style="color:#6a8759;">' '</span>)<br>    }<br>    endSearch()<br><br>    <span style="color:#808080;">// Statistics<br></span><span style="color:#808080;">    </span>println <span style="color:#6a8759;">"Solutions: </span>$<span style="font-weight:bold;">{</span>solutions()<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>println <span style="color:#6a8759;">"Failures: </span>$<span style="font-weight:bold;">{</span>failures()<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>println <span style="color:#6a8759;">"Branches: </span>$<span style="font-weight:bold;">{</span>branches()<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>println <span style="color:#6a8759;">"Wall time: </span>$<span style="font-weight:bold;">{</span>wallTime()<span style="font-weight:bold;">}</span><span style="color:#6a8759;">ms"<br></span><span style="font-weight:bold;">}<br></span></pre><p>which has this output:</p>
<pre>s(9) e(5) n(6) d(7) m(1) o(0) r(8) y(2)
Solutions: 1
Failures: 5
Branches: 10
Wall time: 60ms
</pre>
<p>OR-Tools is written in C++ but has interfaces for numerous languages including Java - which is perfect for Groovy use.</p><h4 style="font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(0, 0, 0);">Choco with JSR331</h4><p>It is great to have multiple libraries to pick from but having a standard API can help switching between such libraries. This is where JSR331 comes in. It defines a standard API for interacting with constraint solvers and linear solves. Here we use a <a href="https://openrules.com/jsr331/JSR331.UserManual.pdf" target="_blank">JSR331 implementation</a> backed by an earlier version of the Choco library. The code looks like this:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">import </span>javax.constraints.*<br><br>ProblemFactory.<span style="color:#9876aa;font-style:italic;">newProblem</span>(<span style="color:#6a8759;">'SEND+MORE=MONEY'</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(S, M) = [<span style="color:#6a8759;">'S'</span>, <span style="color:#6a8759;">'M'</span>].collect <span style="font-weight:bold;">{ </span>variable(it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(E, N, D, O, R, Y) = [<span style="color:#6a8759;">'E'</span>, <span style="color:#6a8759;">'N'</span>, <span style="color:#6a8759;">'D'</span>, <span style="color:#6a8759;">'O'</span>, <span style="color:#6a8759;">'R'</span>, <span style="color:#6a8759;">'Y'</span>].collect <span style="font-weight:bold;">{ </span>variable(it, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="font-weight:bold;">    </span>postAllDifferent(S, E, N, D, M, O, R, Y)<br><br>    Var[] ALL = [<br>            S, E, N, D,<br>            M, O, R, E,<br>            M, O, N, E, Y]<br>    <span style="color:#cc7832;">int</span>[] COEFFS = [<br>            <span style="color:#6897bb;">1000</span>, <span style="color:#6897bb;">100</span>, <span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">1</span>,<br>            <span style="color:#6897bb;">1000</span>, <span style="color:#6897bb;">100</span>, <span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">1</span>,<br>            -<span style="color:#6897bb;">10000</span>, -<span style="color:#6897bb;">1000</span>, -<span style="color:#6897bb;">100</span>, -<span style="color:#6897bb;">10</span>, -<span style="color:#6897bb;">1</span>]<br><br>    post(COEFFS, ALL, <span style="color:#6a8759;">'='</span>, <span style="color:#6897bb;">0</span>)<br><br>    <span style="color:#cc7832;">def </span>solver = getSolver()<br>    <span style="color:#cc7832;">def </span>solution = solver.findSolution()<br>    println solution ?: <span style="color:#6a8759;">'No solution'<br></span><span style="color:#6a8759;">    </span>solver.logStats()<br><span style="font-weight:bold;">}<br></span></pre><div>It is quite similar to earlier examples but now exclusively uses the JSR331 classes in the javax.constraint package. There are implementations of those classes backed by several implementations. So, indeed it would be possible to swap between them. When run, the output is:</div>
<pre>Solution #1:
	 S[9] M[1] E[5] N[6] D[7] O[0] R[8] Y[2]
</pre>
<p>Having said that, at the time of writing, JSR331 popularity doesn't appear to be on the rise. Most folks using constraint programming libraries seem to be using the direct library classes. Indeed, the version of the Choco implementation used by the JSR331 implementation is over 10 years old.</p>

<h3>Incorporating Carry</h3>

<p>The scalar product global constraint we have used in the previous examples is very powerful and probably would be our first choice for this problem. We can, however, model constraint programming problems in multiple ways, so let's look at a solution that avoids that global constraint.</p><p>Instead, we will develop a model that mirrors how we reasoned about the original <code>TO + GO = OUT</code> problem that we solved by hand. For that, we just considered a column at a time and accounted for the carry. We'll explicitly introduce variables to hold the carry (0 if no carry, or 1 if there is a carry) into our model. Then we'll express the mathematical constraints that are applicable for each column.</p><p>Here is the code:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">new </span>Model(<span style="color:#6a8759;">"SEND+MORE=MONEY"</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(S, M) = [<span style="color:#6a8759;">'S'</span>, <span style="color:#6a8759;">'M'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(E, N, D, O, R, Y) = [<span style="color:#6a8759;">'E'</span>, <span style="color:#6a8759;">'N'</span>, <span style="color:#6a8759;">'D'</span>, <span style="color:#6a8759;">'O'</span>, <span style="color:#6a8759;">'R'</span>, <span style="color:#6a8759;">'Y'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>C = (<span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">3</span>).collect<span style="font-weight:bold;">{ </span>intVar(<span style="font-size: 9.6pt; color: rgb(106, 135, 89);">"C</span><span style="font-size: 9.6pt;">$it</span><span style="font-size: 9.6pt; color: rgb(106, 135, 89);">"</span><span style="font-size: 9.6pt;">, </span><span style="font-size: 9.6pt; color: rgb(104, 151, 187);">0</span><span style="font-size: 9.6pt;">, </span><span style="font-size: 9.6pt; color: rgb(104, 151, 187);">9</span><span style="font-size: 9.6pt;">)</span> <span style="font-size: 9.6pt; font-weight: bold;">}</span><br><span style="font-weight:bold;"><br></span><span style="font-weight:bold;">    </span>allDifferent(S, E, N, D, M, O, R, Y).post()<br>    C[<span style="color:#6897bb;">3</span>]              .eq(M).post()                         <span style="font-size: 9.6pt; color: rgb(128, 128, 128);">//  C3 C2 C1 C0</span><br>    C[<span style="color:#6897bb;">2</span>].add(S).add(M).eq(O.add(C[<span style="color:#6897bb;">3</span>].mul(<span style="color:#6897bb;">10</span>))).post()       <span style="font-size: 9.6pt; color: rgb(128, 128, 128);">//      S  E  N  D</span><br>    C[<span style="color:#6897bb;">1</span>].add(E).add(O).eq(N.add(C[<span style="color:#6897bb;">2</span>].mul(<span style="color:#6897bb;">10</span>))).post()       <span style="font-size: 9.6pt; color: rgb(128, 128, 128);">//      M  O  R  E</span><br>    C[<span style="color:#6897bb;">0</span>].add(N).add(R).eq(E.add(C[<span style="color:#6897bb;">1</span>].mul(<span style="color:#6897bb;">10</span>))).post()       <span style="font-size: 9.6pt; color: rgb(128, 128, 128);">//   -------------</span><br>             D .add(E).eq(Y.add(C[<span style="color:#6897bb;">0</span>].mul(<span style="color:#6897bb;">10</span>))).post()       <span style="font-size: 9.6pt; color: rgb(128, 128, 128);">//   M  O  N  E  Y</span><br><br>    println <span style="color:#9876aa;">solver</span>.findSolution()<span style="color:#6a8759;"><br></span><span style="font-weight:bold;">}<br></span></pre><p>We can see that there is now no scalar product global constraint any more but instead the constraints for each column.<br></p><p>When run, the output looks like this:</p>
<pre>Solution: S=9, M=1, E=5, N=6, D=7, O=0, R=8, Y=2, C0=1, C1=1, C2=0, C3=1, sum_exp_1=9,
sum_exp_2=10, (C3*10)=10, sum_exp_3=10, sum_exp_4=6, sum_exp_5=6, (C2*10)=0, sum_exp_6=6,
sum_exp_7=7, sum_exp_8=15, (C1*10)=10, sum_exp_9=15, sum_exp_10=12, (C0*10)=10, sum_exp_11=12,</pre>
<p>We can see that as we were defining our constraints for each column, subexpressions were being created in the model which are reflected in the solution. They are if you like, temporary calculations along the way to getting the answer - or more accurately a snapshot of ever changing temporary calculations. They don't form part of the answer that interests us, so we would be free to just print out the part of the solution which interests us if we wanted.</p>

<h3>Creating a DSL</h3>

<p>The previous example has lots of calls to <code>add</code> and <code>mul</code> methods. We can create a little bit of a DSL to provide some syntactic sugar to our previous examples to allow use of Groovy's operator overloading, support ranges when specifying the domain of a variable, and a few other niceties. Our code becomes:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">model(<span style="color:#6a8759;">"SEND+MORE=MONEY"</span>) <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(S, M) = [<span style="color:#6a8759;">'S'</span>, <span style="color:#6a8759;">'M'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">1</span>..<span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(E, N, D, O, R, Y) = [<span style="color:#6a8759;">'E'</span>, <span style="color:#6a8759;">'N'</span>, <span style="color:#6a8759;">'D'</span>, <span style="color:#6a8759;">'O'</span>, <span style="color:#6a8759;">'R'</span>, <span style="color:#6a8759;">'Y'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>C = intVarArray(<span style="color:#6897bb;">4</span>, <span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">1</span>)<br><br>    [allDifferent(S, E, N, D, M, O, R, Y),      <span style="color:#808080;">//  C3 C2 C1 C0<br></span><span style="color:#808080;">     </span>C[<span style="color:#6897bb;">3</span>]         .eq(M),                       <span style="color:#808080;">//      S  E  N  D<br></span><span style="color:#808080;">    </span>(C[<span style="color:#6897bb;">2</span>] + S + M).eq(O + C[<span style="color:#6897bb;">3</span>] * <span style="color:#6897bb;">10</span>),           <span style="color:#808080;">//      M  O  R  E<br></span><span style="color:#808080;">    </span>(C[<span style="color:#6897bb;">1</span>] + E + O).eq(N + C[<span style="color:#6897bb;">2</span>] * <span style="color:#6897bb;">10</span>),           <span style="color:#808080;">//   -------------<br></span><span style="color:#808080;">    </span>(C[<span style="color:#6897bb;">0</span>] + N + R).eq(E + C[<span style="color:#6897bb;">1</span>] * <span style="color:#6897bb;">10</span>),           <span style="color:#808080;">//   M  O  N  E  Y<br></span><span style="color:#808080;">           </span>(D + E).eq(Y + C[<span style="color:#6897bb;">0</span>] * <span style="color:#6897bb;">10</span>)]*.post()<br><br>    println <span style="color:#9876aa;">solver</span>.findSolution()<span style="color:#6a8759;"><br></span><span style="font-weight:bold;">}<br></span></pre><p>It has the same output as previously.</p><p>You might wonder how the solver finds the solution. You can watch the variables in the debugger and use tools like <a href="https://github.com/chocoteam/choco-cpviz" target="_blank">choco-cpviz</a>&nbsp;but it is a quite convoluted process until you are used to it. We'll try to give you a flavor of what is going on here. Basically, there will be various steps of pruning wherever possible and branching with possible backtracking. Below are some snapshots for our example above.</p><p>To start with, we have nearly 90 light green squares which represents our problem search space. We walk our way through the rules looking for ways to prune the search space:</p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/bdb17727-caee-473c-b450-3ec60e74e13b" style="width:80%;" alt="choco_step1.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/171a4583-806a-4c1b-9557-892d87e5670c" style="width:80%;" alt=" choco_step2.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/6807b9ad-8390-45ec-ad58-10dd1346bf45" style="width:80%;" alt=" choco_step3.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/b2b2221a-60fa-4d9a-9fa1-16ddb213fcce" style="width:80%;" alt="choco_step4.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/6303ed53-ff6c-4572-b70d-52b299d4fff7" style="width:80%;" alt="choco_step5.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/658ff512-433f-452a-9a81-904449dfb623" style="width:80%;" alt="choco_step6.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/f81d5630-ede4-4b75-9e74-b73b81be0b21" style="width:80%;" alt="choco_step7.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/8de231cc-c0da-4170-845a-6653b84779b9" style="width:80%;" alt="choco_step8.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/46227911-c406-4234-88d1-fe1f9ac9c517" style="width:80%;" alt="choco_step9.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/31060d5c-6716-4efe-8f99-910c1771ef28" style="width:80%;" alt="choco_step10.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/4b9324d7-2bf3-48c9-af8b-b35872aaf5cf" style="width:80%;" alt="choco_step11.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/71197695-f379-4777-9ed5-ddae1577ee3d" style="width:80%;" alt="choco_step12.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/6ff23a4e-b444-4794-bc79-e6591582bff9" style="width:80%;" alt="choco_step13.png"></p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/6262d9bc-7f14-4b8f-a952-18668c6f1340" style="width:30%;" alt="choco_step14.png"></p>
<p>As we are locking in the value of variables, we can substitute them into and simplify our constraints. When we reapply them, they will be quicker to evaluate and may reveal more information.</p><p>At this point we only have 2 of our variables locked down but our search space is nearly half what we started with and we have simplified some of our constraints. We would continue branching and solving at this point until we find our solution or determine that no solution is possible.</p>

<h3>Looking at other languages</h3>

<p>The example repo also contains solutions for this problem in other languages so you can compare and contrast
including
<a href="https://clojure.org/" rel="nofollow">Clojure</a>,
Haskell (<a href="https://github.com/Frege/frege">Frege</a>),
<a href="https://www.java.com/" rel="nofollow">Java</a>,
JavaScript (<a href="https://docs.oracle.com/javase/10/nashorn/" rel="nofollow">Nashorn</a>),
Ruby (<a href="https://www.jruby.org/" rel="nofollow">JRuby</a>),
Python (<a href="https://www.jython.org/" rel="nofollow">Jython</a>),
<a href="https://kotlinlang.org/" rel="nofollow">Kotlin</a>,
Lua (<a href="https://github.com/luaj/luaj">Luaj</a>),
Prolog (<a href="http://apice.unibo.it/xwiki/bin/view/Tuprolog/" rel="nofollow">tuprolog</a>),
and <a href="https://www.scala-lang.org/" rel="nofollow">Scala</a>.</p>

<p><img src="https://blogs.apache.org/groovy/mediaresource/a1fc3f0b-3997-4e91-987a-51a5423581e4" style="width:80%;" alt="other language logos"></p>

<h3>Other examples</h3>

<p>To wrap up, let's look at solving a few more examples (using Choco). We'll solve some of the examples from an interesting blog on the <a href="https://pballew.blogspot.com/2015/02/some-history-notes-about-alphametrics.html" target="_blank">history of Cryptarithmetic problems</a>:</p><ul><li><code>ABCD * 4 = DCBA</code></li><li><code>AA + BB + CC = ABC</code></li><li><code>HALF + HALF = WHOLE</code></li><li><code>HALF + FIFTH + TENTH + TENTH + TENTH = WHOLE</code></li></ul><p>Here is the code:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">new </span>Model(<span style="color:#6a8759;">"ABCD*4=DCBA"</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(A, D) = [<span style="color:#6a8759;">'A'</span>, <span style="color:#6a8759;">'D'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(B, C) = [<span style="color:#6a8759;">'B'</span>, <span style="color:#6a8759;">'C'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>R = (<span style="color:#6897bb;">0</span>..<span style="color:#6897bb;">2</span>).collect <span style="font-weight:bold;">{ </span>intVar(<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="font-weight:bold;">    </span>allDifferent(A, B, C, D).post()<br>    R[<span style="color:#6897bb;">2</span>].add(A.mul(<span style="color:#6897bb;">4</span>)).eq(D).post()<br>    R[<span style="color:#6897bb;">1</span>].add(B.mul(<span style="color:#6897bb;">4</span>)).eq(C.add(R[<span style="color:#6897bb;">2</span>].mul(<span style="color:#6897bb;">10</span>))).post()<br>    R[<span style="color:#6897bb;">0</span>].add(C.mul(<span style="color:#6897bb;">4</span>)).eq(B.add(R[<span style="color:#6897bb;">1</span>].mul(<span style="color:#6897bb;">10</span>))).post()<br>    D.mul(<span style="color:#6897bb;">4</span>).eq(A.add(R[<span style="color:#6897bb;">0</span>].mul(<span style="color:#6897bb;">10</span>))).post()<br>    <span style="color:#9876aa;">solver</span>.findAllSolutions().each <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">        </span>println <span style="color:#6a8759;">"</span>$<span style="color:#9876aa;">name</span><span style="color:#6a8759;">: </span>$<span style="font-weight:bold;">{</span>pretty(it, [A, B, C, D, <span style="color:#6a8759;">' * 4 = '</span>, D, C, B, A])<span style="font-weight:bold;">}</span><span style="color:#cc7832;">\n</span>$it<span style="color:#cc7832;">\n</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="color:#cc7832;">new </span>Model(<span style="color:#6a8759;">"AA+BB+CC=ABC"</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(A, B, C) = [<span style="color:#6a8759;">'A'</span>, <span style="color:#6a8759;">'B'</span>, <span style="color:#6a8759;">'C'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span>allDifferent(A, B, C).post()<br>    A.mul(<span style="color:#6897bb;">11</span>).add(B.mul(<span style="color:#6897bb;">11</span>).add(C.mul(<span style="color:#6897bb;">11</span>))).eq(A.mul(<span style="color:#6897bb;">100</span>).add(B.mul(<span style="color:#6897bb;">10</span>)).add(C)).post()<br>    <span style="color:#9876aa;">solver</span>.findAllSolutions().each <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">        </span>println <span style="color:#6a8759;">"</span>$<span style="color:#9876aa;">name</span><span style="color:#6a8759;">: </span>$<span style="font-weight:bold;">{</span>pretty(it, [A, A, <span style="color:#6a8759;">' + '</span>, B, B, <span style="color:#6a8759;">' + '</span>, C, C, <span style="color:#6a8759;">' = '</span>, A, B, C])<span style="font-weight:bold;">}</span><span style="color:#cc7832;">\n</span>$it<span style="color:#cc7832;">\n</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="color:#cc7832;">new </span>Model(<span style="color:#6a8759;">"HALF+HALF=WHOLE"</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(H, W) = [<span style="color:#6a8759;">'H'</span>, <span style="color:#6a8759;">'W'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(A, E, F, L, O) = [<span style="color:#6a8759;">'A'</span>, <span style="color:#6a8759;">'E'</span>, <span style="color:#6a8759;">'F'</span>, <span style="color:#6a8759;">'L'</span>, <span style="color:#6a8759;">'O'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span>allDifferent(H, W, A, E, F, L, O).post()<br>    IntVar[] ALL = [<br>            H, A, L, F,<br>            W, H, O, L, E]<br>    <span style="color:#cc7832;">int</span>[] COEFFS = [<br>            <span style="color:#6897bb;">2000</span>, <span style="color:#6897bb;">200</span>, <span style="color:#6897bb;">20</span>, <span style="color:#6897bb;">2</span>,<br>            -<span style="color:#6897bb;">10000</span>, -<span style="color:#6897bb;">1000</span>, -<span style="color:#6897bb;">100</span>, -<span style="color:#6897bb;">10</span>, -<span style="color:#6897bb;">1</span>]<br>    scalar(ALL, COEFFS, <span style="color:#6a8759;">"="</span>, <span style="color:#6897bb;">0</span>).post()<br>    <span style="color:#9876aa;">solver</span>.findAllSolutions().each <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">        </span>println <span style="color:#6a8759;">"</span>$<span style="color:#9876aa;">name</span><span style="color:#6a8759;">: </span>$<span style="font-weight:bold;">{</span>pretty(it, [H, A, L, F, <span style="color:#6a8759;">' + '</span>, H, A, L, F, <span style="color:#6a8759;">' = '</span>, W, H, O, L, E])<span style="font-weight:bold;">}</span><span style="color:#cc7832;">\n</span>$it<span style="color:#cc7832;">\n</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="color:#cc7832;">new </span>Model(<span style="color:#6a8759;">"HALF+FIFTH+TENTH+TENTH+TENTH=WHOLE"</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(H, F, T, W) = [<span style="color:#6a8759;">'H'</span>, <span style="color:#6a8759;">'F'</span>, <span style="color:#6a8759;">'T'</span>, <span style="color:#6a8759;">'W'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>(A, L, I, E, N, O) = [<span style="color:#6a8759;">'A'</span>, <span style="color:#6a8759;">'L'</span>, <span style="color:#6a8759;">'I'</span>, <span style="color:#6a8759;">'E'</span>, <span style="color:#6a8759;">'N'</span>, <span style="color:#6a8759;">'O'</span>].collect <span style="font-weight:bold;">{ </span>intVar(it, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">9</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span>allDifferent(H, F, T, W, A, L, I, E, N, O).post()<br>    IntVar[] ALL = [<br>            H, A, L, F,<br>            F, I, F, T, H,<br>            T, E, N, T, H,<br>            T, E, N, T, H,<br>            T, E, N, T, H,<br>            W, H, O, L, E]<br>    <span style="color:#cc7832;">int</span>[] COEFFS = [<br>            <span style="color:#6897bb;">1000</span>, <span style="color:#6897bb;">100</span>, <span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">1</span>,<br>            <span style="color:#6897bb;">10000</span>, <span style="color:#6897bb;">1000</span>, <span style="color:#6897bb;">100</span>, <span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">1</span>,<br>            <span style="color:#6897bb;">10000</span>, <span style="color:#6897bb;">1000</span>, <span style="color:#6897bb;">100</span>, <span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">1</span>,<br>            <span style="color:#6897bb;">10000</span>, <span style="color:#6897bb;">1000</span>, <span style="color:#6897bb;">100</span>, <span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">1</span>,<br>            <span style="color:#6897bb;">10000</span>, <span style="color:#6897bb;">1000</span>, <span style="color:#6897bb;">100</span>, <span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">1</span>,<br>            -<span style="color:#6897bb;">10000</span>, -<span style="color:#6897bb;">1000</span>, -<span style="color:#6897bb;">100</span>, -<span style="color:#6897bb;">10</span>, -<span style="color:#6897bb;">1</span>]<br>    scalar(ALL, COEFFS, <span style="color:#6a8759;">"="</span>, <span style="color:#6897bb;">0</span>).post()<br>    <span style="color:#9876aa;">solver</span>.findAllSolutions().each <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">        </span><span style="color:#cc7832;">def </span>parts = [H, A, L, F, <span style="color:#6a8759;">'+'</span>, F, I, F, T, H, <span style="color:#6a8759;">'+'</span>, T, E, N, T, H, <span style="color:#6a8759;">'+'</span>,<br>                     T, E, N, T, H, <span style="color:#6a8759;">'+'</span>, T, E, N, T, H, <span style="color:#6a8759;">'='</span>, W, H, O, L, E]<br>        println <span style="color:#6a8759;">"</span>$<span style="color:#9876aa;">name</span><span style="color:#6a8759;">: </span>$<span style="font-weight:bold;">{</span>pretty(it, parts)<span style="font-weight:bold;">}</span><span style="color:#cc7832;">\n</span>$it<span style="color:#cc7832;">\n</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="color:#808080;">// helper method to print solutions<br></span><span style="color:#cc7832;">def </span>pretty(model, parts) {<br>    parts.collect <span style="font-weight:bold;">{ </span>p <span style="font-weight:bold;">-&gt; </span>p <span style="color:#cc7832;">instanceof </span>IntVar ? model.getIntVal(p) : p <span style="font-weight:bold;">}</span>.join()<br>}</pre>
<p>which has this output:</p>
<pre>ABCD*4=DCBA: 2178 * 4 = 8712
Solution: A=2, D=8, B=1, C=7, IV_1=3, IV_2=3, IV_3=0, (A*4)=8, sum_exp_4=8, (B*4)=4, ..., 

AA+BB+CC=ABC: 11 + 99 + 88 = 198
Solution: A=1, B=9, C=8, (A*11)=11, (B*11)=99, (C*11)=88, ..., 

HALF+HALF=WHOLE: 9604 + 9604 = 19208
Solution: H=9, W=1, A=6, E=8, F=4, L=0, O=2, 

HALF+HALF=WHOLE: 9703 + 9703 = 19406
Solution: H=9, W=1, A=7, E=6, F=3, L=0, O=4, 

HALF+HALF=WHOLE: 9802 + 9802 = 19604
Solution: H=9, W=1, A=8, E=4, F=2, L=0, O=6, 

HALF+FIFTH+TENTH+TENTH+TENTH=WHOLE: 6701+14126+25326+25326+25326=96805
Solution: H=6, F=1, T=2, W=9, A=7, L=0, I=4, E=5, N=3, O=8, 
</pre>
<p>You should see the common patterns used for solving these puzzles.</p>

<h3>Further Information</h3>

<ul><li><a href="https://github.com/radsz/jacop" target="_blank">JaCoP</a> Java Constraint Programming solver</li><li><a href="https://choco-solver.org/" target="_blank">Choco</a> open source library for constraint programming</li><li><a href="https://developers.google.com/optimization/cp" target="_blank">OR-Tools</a> constraint optimization</li><li><a href="https://en.wikipedia.org/wiki/Verbal_arithmetic" target="_blank">Verbal arithmetic</a> problems described (wikipedia)</li><li><a href="https://www.jcp.org/en/jsr/detail?id=331" target="_blank">JSR331</a>&nbsp;Constraint Programming API</li><li><a href="https://github.com/paulk-asert/groovy-constraint-programming/tree/master/subprojects/SendMoreMoney" target="_blank">Github repo</a> containing sample code</li></ul>

<h3>Conclusion</h3>

<p>We have looked at using Groovy and a few constraint programming libraries to solve a cryptarithmetic puzzles. Why not try solving some of your own puzzles.</p>
