<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>GPars meets Virtual Threads | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="GPars meets Virtual Threads" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An exciting preview feature coming in JDK19 is Virtual Threads (JEP 425). In my experiments so far, virtual threads work well with my favourite Groovy parallel and concurrency library GPars. GPars has been around a while (since Java 5 and Groovy 1.8 days) but still has many useful features. Let&#39;s have a look at a few examples. If you want to try these out, make sure you have a recent JDK19 (currently EA) and enable preview features with your Groovy tooling. Parallel Collections First a refresher, to use the GPars parallel collections feature with normal threads, use the &lt;span style=&quot;background-color: #FFFFFF; color: rgb(8, 8, 8); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 14px;&gt; GParsPool.&lt;span style=&quot; font-style=&quot;italic;&quot;&quot;&gt;withPool&lt;/span&gt; method as follows: withPool { assert [1, 2, 3].collectParallel{ it ** 2 } == [1, 4, 9] } For any Java readers, don&#39;t get confused with the collectParallel method name. Groovy&#39;s collect method (naming inspired by Smalltalk) is the equivalent of Java&#39;s map method. So, the equivalent Groovy code using the Java streams API would be something like: assert [1, 2, 3].parallelStream().map(n -&gt; n ** 2).collect(Collectors.toList()) == [1, 4, 9] Now, let&#39;s bring virtual threads into the picture. Luckily, GPars parallel collection facilities provide a hook for using an existing custom executor service. This makes using virtual threads for such code easy: withExistingPool(Executors.newVirtualThreadPerTaskExecutor()) { assert [1, 2, 3].collectParallel{ it ** 2 } == [1, 4, 9]} Nice! But let&#39;s move onto some areas examples which might be less familiar to Java developers. GPars has additional features for providing custom thread pools and the remaining examples rely on those features. The current version of GPars doesn&#39;t have a&nbsp;&lt;span style=&quot;font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;&quot;&gt;DefaultPool&nbsp;&lt;/span&gt;constructor that takes a vanilla executor service, so, we&#39;ll write our own class: @AutoImplementclass VirtualPool implements Pool { private final ExecutorService pool = Executors.newVirtualThreadPerTaskExecutor() int getPoolSize() { pool.poolSize } void execute(Runnable task) { pool.execute(task) } ExecutorService getExecutorService() { pool }} It is essentially a delegate from the GPars&nbsp;&lt;span style=&quot;font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;&quot;&gt;Pool&lt;/span&gt;&nbsp;interface to the virtual threads executor service. We&#39;ll use this in the remaining examples. Agents Agents provide a thread-safe non-blocking wrapper around an otherwise potentially mutable shared state object. They are inspired by agents in Clojure. In our case we&#39;ll use an agent to &quot;protect&quot; a plain&nbsp;&lt;span style=&quot;font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;&quot;&gt;ArrayList&lt;/span&gt;. For this simple case, we could have used some synchronized list, but in general, agents eliminate the need to find thread-safe implementation classes or indeed care at all about the thread safety of the underlying wrapped object. def mutableState = [] // a non-synchronized mutable listdef agent = new Agent(mutableState)agent.attachToThreadPool(new VirtualPool()) // omit line for normal threadsagent { it &lt;&lt; &#39;Dave&#39; } // one thread updates listagent { it &lt;&lt; &#39;Joe&#39; } // another thread also updatingassert agent.val.size() == 2 Actors Actors allow for a message passing-based concurrency model. The actor model ensures that at most one thread processes the actor&#39;s body at any time. The GPars API and DSLs for actors are quite rich supporting many features. We&#39;ll look at a simple example here. GPars manages actor thread pools in groups. Let&#39;s create one backed by virtual threads: def vgroup = new DefaultPGroup(new VirtualPool()) Now we can write an encrypting and decrypting actor pair as follows: def decryptor = vgroup.actor { loop { react { String message -&gt; reply message.reverse() } }}def console = vgroup.actor { decryptor &lt;&lt; &#39;lellarap si yvoorG&#39; react { println &#39;Decrypted message: &#39; + it }}console.join() // output: Decrypted message: Groovy is parallel Dataflow Dataflow&nbsp;offers an inherently safe and robust declarative concurrency model. Dataflows are also managed via thread groups, so we&#39;ll use&nbsp;&lt;span style=&quot;font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 14px;&quot;&gt;vgroup&lt;/span&gt;&nbsp;which we created earlier. We have three logical tasks which can run in parallel and perform their work. The tasks need to exchange data and they do so using dataflow variables. Think of dataflow variables as one-shot channels safely and reliably transferring data from producers to their consumers. def df = new Dataflows()vgroup.task { df.z = df.x + df.y}vgroup.task { df.x = 10}vgroup.task { df.y = 5}assert df.z == 15 The dataflow framework works out how to schedule the individual tasks and ensures that a task&#39;s input variables are ready when needed. Conclusion We have had a quick glimpse at using virtual threads with Groovy and GPars. It is very early days, so expect much more to emerge in this space once virtual threads are released in preview in production versions of JDK19 and eventually beyond a preview feature." />
<meta property="og:description" content="An exciting preview feature coming in JDK19 is Virtual Threads (JEP 425). In my experiments so far, virtual threads work well with my favourite Groovy parallel and concurrency library GPars. GPars has been around a while (since Java 5 and Groovy 1.8 days) but still has many useful features. Let&#39;s have a look at a few examples. If you want to try these out, make sure you have a recent JDK19 (currently EA) and enable preview features with your Groovy tooling. Parallel Collections First a refresher, to use the GPars parallel collections feature with normal threads, use the &lt;span style=&quot;background-color: #FFFFFF; color: rgb(8, 8, 8); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 14px;&gt; GParsPool.&lt;span style=&quot; font-style=&quot;italic;&quot;&quot;&gt;withPool&lt;/span&gt; method as follows: withPool { assert [1, 2, 3].collectParallel{ it ** 2 } == [1, 4, 9] } For any Java readers, don&#39;t get confused with the collectParallel method name. Groovy&#39;s collect method (naming inspired by Smalltalk) is the equivalent of Java&#39;s map method. So, the equivalent Groovy code using the Java streams API would be something like: assert [1, 2, 3].parallelStream().map(n -&gt; n ** 2).collect(Collectors.toList()) == [1, 4, 9] Now, let&#39;s bring virtual threads into the picture. Luckily, GPars parallel collection facilities provide a hook for using an existing custom executor service. This makes using virtual threads for such code easy: withExistingPool(Executors.newVirtualThreadPerTaskExecutor()) { assert [1, 2, 3].collectParallel{ it ** 2 } == [1, 4, 9]} Nice! But let&#39;s move onto some areas examples which might be less familiar to Java developers. GPars has additional features for providing custom thread pools and the remaining examples rely on those features. The current version of GPars doesn&#39;t have a&nbsp;&lt;span style=&quot;font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;&quot;&gt;DefaultPool&nbsp;&lt;/span&gt;constructor that takes a vanilla executor service, so, we&#39;ll write our own class: @AutoImplementclass VirtualPool implements Pool { private final ExecutorService pool = Executors.newVirtualThreadPerTaskExecutor() int getPoolSize() { pool.poolSize } void execute(Runnable task) { pool.execute(task) } ExecutorService getExecutorService() { pool }} It is essentially a delegate from the GPars&nbsp;&lt;span style=&quot;font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;&quot;&gt;Pool&lt;/span&gt;&nbsp;interface to the virtual threads executor service. We&#39;ll use this in the remaining examples. Agents Agents provide a thread-safe non-blocking wrapper around an otherwise potentially mutable shared state object. They are inspired by agents in Clojure. In our case we&#39;ll use an agent to &quot;protect&quot; a plain&nbsp;&lt;span style=&quot;font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;&quot;&gt;ArrayList&lt;/span&gt;. For this simple case, we could have used some synchronized list, but in general, agents eliminate the need to find thread-safe implementation classes or indeed care at all about the thread safety of the underlying wrapped object. def mutableState = [] // a non-synchronized mutable listdef agent = new Agent(mutableState)agent.attachToThreadPool(new VirtualPool()) // omit line for normal threadsagent { it &lt;&lt; &#39;Dave&#39; } // one thread updates listagent { it &lt;&lt; &#39;Joe&#39; } // another thread also updatingassert agent.val.size() == 2 Actors Actors allow for a message passing-based concurrency model. The actor model ensures that at most one thread processes the actor&#39;s body at any time. The GPars API and DSLs for actors are quite rich supporting many features. We&#39;ll look at a simple example here. GPars manages actor thread pools in groups. Let&#39;s create one backed by virtual threads: def vgroup = new DefaultPGroup(new VirtualPool()) Now we can write an encrypting and decrypting actor pair as follows: def decryptor = vgroup.actor { loop { react { String message -&gt; reply message.reverse() } }}def console = vgroup.actor { decryptor &lt;&lt; &#39;lellarap si yvoorG&#39; react { println &#39;Decrypted message: &#39; + it }}console.join() // output: Decrypted message: Groovy is parallel Dataflow Dataflow&nbsp;offers an inherently safe and robust declarative concurrency model. Dataflows are also managed via thread groups, so we&#39;ll use&nbsp;&lt;span style=&quot;font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 14px;&quot;&gt;vgroup&lt;/span&gt;&nbsp;which we created earlier. We have three logical tasks which can run in parallel and perform their work. The tasks need to exchange data and they do so using dataflow variables. Think of dataflow variables as one-shot channels safely and reliably transferring data from producers to their consumers. def df = new Dataflows()vgroup.task { df.z = df.x + df.y}vgroup.task { df.x = 10}vgroup.task { df.y = 5}assert df.z == 15 The dataflow framework works out how to schedule the individual tasks and ensures that a task&#39;s input variables are ready when needed. Conclusion We have had a quick glimpse at using virtual threads with Groovy and GPars. It is very early days, so expect much more to emerge in this space once virtual threads are released in preview in production versions of JDK19 and eventually beyond a preview feature." />
<link rel="canonical" href="http://localhost:4000/groovy/entry/gpars-meets-virtual-threads" />
<meta property="og:url" content="http://localhost:4000/groovy/entry/gpars-meets-virtual-threads" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-06-20T03:51:07-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="GPars meets Virtual Threads" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-06-20T03:51:07-04:00","datePublished":"2022-06-20T03:51:07-04:00","description":"An exciting preview feature coming in JDK19 is Virtual Threads (JEP 425). In my experiments so far, virtual threads work well with my favourite Groovy parallel and concurrency library GPars. GPars has been around a while (since Java 5 and Groovy 1.8 days) but still has many useful features. Let&#39;s have a look at a few examples. If you want to try these out, make sure you have a recent JDK19 (currently EA) and enable preview features with your Groovy tooling. Parallel Collections First a refresher, to use the GPars parallel collections feature with normal threads, use the &lt;span style=&quot;background-color: #FFFFFF; color: rgb(8, 8, 8); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 14px;&gt; GParsPool.&lt;span style=&quot; font-style=&quot;italic;&quot;&quot;&gt;withPool&lt;/span&gt; method as follows: withPool { assert [1, 2, 3].collectParallel{ it ** 2 } == [1, 4, 9] } For any Java readers, don&#39;t get confused with the collectParallel method name. Groovy&#39;s collect method (naming inspired by Smalltalk) is the equivalent of Java&#39;s map method. So, the equivalent Groovy code using the Java streams API would be something like: assert [1, 2, 3].parallelStream().map(n -&gt; n ** 2).collect(Collectors.toList()) == [1, 4, 9] Now, let&#39;s bring virtual threads into the picture. Luckily, GPars parallel collection facilities provide a hook for using an existing custom executor service. This makes using virtual threads for such code easy: withExistingPool(Executors.newVirtualThreadPerTaskExecutor()) { assert [1, 2, 3].collectParallel{ it ** 2 } == [1, 4, 9]} Nice! But let&#39;s move onto some areas examples which might be less familiar to Java developers. GPars has additional features for providing custom thread pools and the remaining examples rely on those features. The current version of GPars doesn&#39;t have a&nbsp;&lt;span style=&quot;font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;&quot;&gt;DefaultPool&nbsp;&lt;/span&gt;constructor that takes a vanilla executor service, so, we&#39;ll write our own class: @AutoImplementclass VirtualPool implements Pool { private final ExecutorService pool = Executors.newVirtualThreadPerTaskExecutor() int getPoolSize() { pool.poolSize } void execute(Runnable task) { pool.execute(task) } ExecutorService getExecutorService() { pool }} It is essentially a delegate from the GPars&nbsp;&lt;span style=&quot;font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;&quot;&gt;Pool&lt;/span&gt;&nbsp;interface to the virtual threads executor service. We&#39;ll use this in the remaining examples. Agents Agents provide a thread-safe non-blocking wrapper around an otherwise potentially mutable shared state object. They are inspired by agents in Clojure. In our case we&#39;ll use an agent to &quot;protect&quot; a plain&nbsp;&lt;span style=&quot;font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;&quot;&gt;ArrayList&lt;/span&gt;. For this simple case, we could have used some synchronized list, but in general, agents eliminate the need to find thread-safe implementation classes or indeed care at all about the thread safety of the underlying wrapped object. def mutableState = [] // a non-synchronized mutable listdef agent = new Agent(mutableState)agent.attachToThreadPool(new VirtualPool()) // omit line for normal threadsagent { it &lt;&lt; &#39;Dave&#39; } // one thread updates listagent { it &lt;&lt; &#39;Joe&#39; } // another thread also updatingassert agent.val.size() == 2 Actors Actors allow for a message passing-based concurrency model. The actor model ensures that at most one thread processes the actor&#39;s body at any time. The GPars API and DSLs for actors are quite rich supporting many features. We&#39;ll look at a simple example here. GPars manages actor thread pools in groups. Let&#39;s create one backed by virtual threads: def vgroup = new DefaultPGroup(new VirtualPool()) Now we can write an encrypting and decrypting actor pair as follows: def decryptor = vgroup.actor { loop { react { String message -&gt; reply message.reverse() } }}def console = vgroup.actor { decryptor &lt;&lt; &#39;lellarap si yvoorG&#39; react { println &#39;Decrypted message: &#39; + it }}console.join() // output: Decrypted message: Groovy is parallel Dataflow Dataflow&nbsp;offers an inherently safe and robust declarative concurrency model. Dataflows are also managed via thread groups, so we&#39;ll use&nbsp;&lt;span style=&quot;font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 14px;&quot;&gt;vgroup&lt;/span&gt;&nbsp;which we created earlier. We have three logical tasks which can run in parallel and perform their work. The tasks need to exchange data and they do so using dataflow variables. Think of dataflow variables as one-shot channels safely and reliably transferring data from producers to their consumers. def df = new Dataflows()vgroup.task { df.z = df.x + df.y}vgroup.task { df.x = 10}vgroup.task { df.y = 5}assert df.z == 15 The dataflow framework works out how to schedule the individual tasks and ensures that a task&#39;s input variables are ready when needed. Conclusion We have had a quick glimpse at using virtual threads with Groovy and GPars. It is very early days, so expect much more to emerge in this space once virtual threads are released in preview in production versions of JDK19 and eventually beyond a preview feature.","headline":"GPars meets Virtual Threads","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/groovy/entry/gpars-meets-virtual-threads"},"url":"http://localhost:4000/groovy/entry/gpars-meets-virtual-threads"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">GPars meets Virtual Threads</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-06-20T03:51:07-04:00" itemprop="datePublished">Jun 20, 2022
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Paul King", "login"=>"paulk", "email"=>"paulk@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><img src="https://blogs.apache.org/groovy/mediaresource/52d821d8-f108-48e6-805d-f8fdd514f9ca" style="width: 20%;" align="right" alt="gpars-rgb.png">An exciting preview feature coming in JDK19 is Virtual Threads (<a href="https://openjdk.java.net/jeps/425" target="_blank">JEP 425</a>). In my experiments so far, virtual threads work well with my favourite Groovy parallel and concurrency library <a href="http://gpars.org/" target="_blank">GPars</a>. GPars has been around a while (since Java 5 and Groovy 1.8 days) but still has many useful features. Let's have a look at a few examples.</p>
<p>If you want to try these out, make sure you have a recent JDK19 (currently EA) and enable <i>preview </i>features with your Groovy tooling.</p>
<h3>Parallel Collections</h3>
<p>First a refresher, to use the GPars parallel collections feature with normal threads, use the<br />
<span style="background-color: #FFFFFF; color: rgb(8, 8, 8); font-family: "JetBrains Mono", monospace; font-size: 14px;> GParsPool.<span style=" font-style="italic;"">withPool</span> method as follows:</p>
<pre style="color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="font-style:italic;">withPool </span><span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#0033b3;">assert </span>[<span style="color:#1750eb;">1</span>, <span style="color:#1750eb;">2</span>, <span style="color:#1750eb;">3</span>].collectParallel<span style="font-weight:bold;">{ </span>it ** <span style="color:#1750eb;">2 </span><span style="font-weight:bold;">} </span>== [<span style="color:#1750eb;">1</span>, <span style="color:#1750eb;">4</span>, <span style="color:#1750eb;">9</span>]
}</pre>
<p>For any Java readers, don't get confused with the <span style="font-family:'JetBrains Mono',monospace;font-size: 14px; color: rgb(8, 8, 8);">collectParallel</span> method name. Groovy's <span style="font-family:'JetBrains Mono',monospace;font-size: 14px; color: rgb(8, 8, 8);">collect</span> method (naming inspired by Smalltalk) is the equivalent of Java's <span style="font-family:'JetBrains Mono',monospace;font-size: 14px; color: rgb(8, 8, 8);">map</span> method. So, the equivalent Groovy code using the Java streams API would be something like:</p>
<pre style="color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#0033b3;">assert </span>[<span style="color:#1750eb;">1</span>, <span style="color:#1750eb;">2</span>, <span style="color:#1750eb;">3</span>].parallelStream().map(n -> n ** <span style="color:#1750eb;">2</span>).collect(<span style="color:#000000;">Collectors</span>.<span style="font-style:italic;">toList</span>()) == [<span style="color:#1750eb;">1</span>, <span style="color:#1750eb;">4</span>, <span style="color:#1750eb;">9</span>]<br></pre>
<p>Now, let's bring virtual threads into the picture. Luckily, GPars parallel collection facilities provide a hook for using an <i>existing </i>custom executor service. This makes using virtual threads for such code easy:</p>
<pre style="color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="font-style:italic;">withExistingPool</span>(<span style="color:#000000;">Executors</span>.newVirtualThreadPerTaskExecutor()) <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#0033b3;">assert </span>[<span style="color:#1750eb;">1</span>, <span style="color:#1750eb;">2</span>, <span style="color:#1750eb;">3</span>].collectParallel<span style="font-weight:bold;">{ </span>it ** <span style="color:#1750eb;">2 </span><span style="font-weight:bold;">} </span>== [<span style="color:#1750eb;">1</span>, <span style="color:#1750eb;">4</span>, <span style="color:#1750eb;">9</span>]<br><span style="font-weight:bold;">}<br></span></pre>
<p>Nice! But let's move onto some areas examples which might be less familiar to Java developers.</p>
<p>GPars has additional features for providing custom thread pools and the remaining examples rely on those features. The current version of GPars doesn't have a&nbsp;<span style="font-family: "JetBrains Mono", monospace; font-size: 9.6pt;">DefaultPool&nbsp;</span>constructor that takes a vanilla executor service, so, we'll write our own class:</p>
<pre style="color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#9e880d;">@AutoImplement<br></span><span style="color:#0033b3;">class </span><span style="color:#000000;">VirtualPool </span><span style="color:#0033b3;">implements </span><span style="color:#000000;">Pool </span>{<br>    <span style="color:#0033b3;">private final </span><span style="color:#000000;">ExecutorService </span><span style="color:#871094;">pool </span>= <span style="color:#000000;">Executors</span>.newVirtualThreadPerTaskExecutor()<br>    <span style="color:#0033b3;">int </span><span style="color:#00627a;">getPoolSize</span>() { <span style="color:#871094;">pool</span>.poolSize }<br>    <span style="color:#0033b3;">void </span><span style="color:#00627a;">execute</span>(<span style="color:#000000;">Runnable </span>task) { <span style="color:#871094;">pool</span>.execute(task) }<br>    <span style="color:#000000;">ExecutorService </span><span style="color:#00627a;">getExecutorService</span>() { <span style="color:#871094;">pool </span>}<br>}<br></pre>
<p>It is essentially a delegate from the GPars&nbsp;<span style="font-family: "JetBrains Mono", monospace; font-size: 9.6pt;">Pool</span>&nbsp;interface to the virtual threads executor service.</p>
<p>We'll use this in the remaining examples.</p>
<h3>Agents</h3>
<p>Agents provide a thread-safe non-blocking wrapper around an otherwise potentially mutable shared state object. They are inspired by agents in Clojure.</p>
<p>In our case we'll use an agent to "protect" a plain&nbsp;<span style="font-family: "JetBrains Mono", monospace; font-size: 9.6pt;">ArrayList</span>. For this simple case, we could have used some synchronized list, but in general, agents eliminate the need to find thread-safe implementation classes or indeed care at all about the thread safety of the underlying wrapped object.</p>
<pre style="color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#0033b3;">def </span><span style="color:#000000;">mutableState </span>= []     <span style="color:#8c8c8c;font-style:italic;">// a non-synchronized mutable list<br></span><span style="color:#0033b3;">def </span><span style="color:#000000;">agent </span>= <span style="color:#0033b3;">new </span><span style="color:#000000;">Agent</span>(<span style="color:#000000;">mutableState</span>)<br><br><span style="color:#000000;">agent</span>.attachToThreadPool(<span style="color:#0033b3;">new </span><span style="color:#000000;">VirtualPool</span>()) <span style="color:#8c8c8c;font-style:italic;">// omit line for normal threads<br></span><span style="color:#8c8c8c;font-style:italic;"><br></span><span style="color:#000000;">agent </span><span style="font-weight:bold;">{ </span>it << <span style="color:#067d17;">'Dave' </span><span style="font-weight:bold;">}    </span><span style="color:#8c8c8c;font-style:italic;">// one thread updates list<br></span><span style="color:#000000;">agent </span><span style="font-weight:bold;">{ </span>it << <span style="color:#067d17;">'Joe' </span><span style="font-weight:bold;">}     </span><span style="color:#8c8c8c;font-style:italic;">// another thread also updating<br></span><span style="color:#0033b3;">assert </span><span style="color:#000000;">agent</span>.val.size() == <span style="color:#1750eb;">2<br></span></pre>
<h3>Actors</h3>
<p>Actors allow for a message passing-based concurrency model. The actor model ensures that at most one thread processes the actor's body at any time. The GPars API and DSLs for actors are quite rich supporting many features. We'll look at a simple example here.</p>
<p>GPars manages actor thread pools in groups. Let's create one backed by virtual threads:</p>
<pre style="color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#0033b3;">def </span><span style="color:#000000;">vgroup </span>= <span style="color:#0033b3;">new </span><span style="color:#000000;">DefaultPGroup</span>(<span style="color:#0033b3;">new </span><span style="color:#000000;">VirtualPool</span>())
</pre>
<p>Now we can write an encrypting and decrypting actor pair as follows:</p>
<pre style="color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#0033b3;">def </span><span style="color:#000000;">decryptor </span>= <span style="color:#000000;">vgroup</span>.actor <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>loop <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">        </span>react <span style="font-weight:bold;">{ </span><span style="color:#000000;">String </span>message <span style="font-weight:bold;">-><br></span><span style="font-weight:bold;">            </span>reply message.reverse()<br>        <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    }<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="color:#0033b3;">def </span><span style="color:#000000;">console </span>= <span style="color:#000000;">vgroup</span>.actor <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#000000;">decryptor </span><< <span style="color:#067d17;">'lellarap si yvoorG'<br></span><span style="color:#067d17;">    </span>react <span style="font-weight:bold;">{<br></span>        println <span style="color:#067d17;">'Decrypted message: ' </span>+ it<br>    <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="color:#000000;">console</span>.join() // output: Decrypted message: Groovy is parallel</pre>
<h3>Dataflow</h3>
<p style="">Dataflow&nbsp;offers an inherently safe and robust declarative concurrency model. Dataflows are also managed via thread groups, so we'll use&nbsp;<span style="font-family: "JetBrains Mono", monospace; font-size: 14px;">vgroup</span>&nbsp;which we created earlier.</p>
<p style="">We have three logical tasks which can run in parallel and perform their work. The tasks need to exchange data and they do so using <i>dataflow variables</i>. Think of dataflow variables as one-shot channels safely and reliably transferring data from producers to their consumers.<br></p>
<pre style="color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#0033b3;">def </span><span style="color:#000000;">df </span>= <span style="color:#0033b3;">new </span><span style="color:#000000;">Dataflows</span>()<br><br><span style="color:#000000;">vgroup</span>.task <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#000000;">df</span>.z = <span style="color:#000000;">df</span>.x + <span style="color:#000000;">df</span>.y<br><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="color:#000000;">vgroup</span>.task <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#000000;">df</span>.x = <span style="color:#1750eb;">10<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="color:#000000;">vgroup</span>.task <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#000000;">df</span>.y = <span style="color:#1750eb;">5<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="color:#0033b3;">assert </span><span style="color:#000000;">df</span>.z == <span style="color:#1750eb;">15<br></span></pre>
<p>The dataflow framework works out how to schedule the individual tasks and ensures that<br />
a task's input variables are ready when needed.</p>
<h3>Conclusion</h3>
<p>We have had a quick glimpse at using virtual threads with Groovy and GPars.<br />
It is very early days, so expect much more to emerge in this space once virtual<br />
threads are released in preview in production versions of JDK19 and eventually beyond a preview feature.</p>

  </div><a class="u-url" href="/groovy/entry/gpars-meets-virtual-threads" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
