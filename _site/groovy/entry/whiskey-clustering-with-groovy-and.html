<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Whiskey Clustering with Groovy and Apache Ignite | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Whiskey Clustering with Groovy and Apache Ignite" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In a previous blog post, we looked at using Apache Wayang&nbsp;(incubating) and Apache Spark to scale up the k-means clustering algorithm. Let&#39;s look at another useful technology for scaling up this problem, Apache Ignite. They recently released a new version, but earlier versions are also fine for our example. Before we start, a quick reminder of the problem. Whiskey Clustering This problem looks at the quest of finding the perfect&nbsp;single-malt Scotch whiskey. The whiskies produced from&nbsp;86 distilleries&nbsp;have been ranked by expert tasters according to 12 criteria (Body, Sweetness, Malty, Smoky, Fruity, etc.). We&#39;ll use a K-means algorithm to calculate the centroids. K-means is a standard data-science clustering technique. In our case, it groups whiskies with similar characteristics (according to the 12 criteria) into clusters. If we have a favourite whiskey, chances are we can find something similar by looking at other instances in the same cluster. If we are feeling like a change, we can look for a whiskey in some other cluster. The centroid is the notional &quot;point&quot; in the middle of the cluster. For us it reflects the typical measure of each criteria for a whiskey in that cluster. Apache Ignite Apache Ignite is a distributed database for high-performance computing with in-memory speed. It makes a cluster (or grid) of nodes appear like an in-memory cache. This explanation drastically simplifies Ignite&#39;s feature set. Ignite can be used as: an in-memory cache with special features like SQL querying and transactional properties an in-memory data-grid with advanced read-through &amp; write-through capabilities on top of one or more distributed databases an ultra-fast and horizontally scalable in-memory database a high-performance computing engine for custom or built-in tasks including machine learning It is mostly this last capability that we will use. Ignite&#39;s Machine Learning API has purpose built, cluster-aware machine learning and deep learning algorithms for Classification, Regression, Clustering, and Recommendation among others. We&#39;ll use the distributed K-means Clustering algorithm from their library. Implementation Details Apache Ignite has special capabilities for reading data into the cache. We could use IgniteDataStreamer or IgniteCache.loadCache() and load data from files, stream sources, various database sources and so forth. This is particularly relevant when using a cluster. For our little example, our data is in a relatively small CSV file and we will be using a single node, so we&#39;ll just read our data using&nbsp;Apache Commons CSV: var file = getClass().classLoader.getResource(&#39;whiskey.csv&#39;).file as Filevar rows = file.withReader {r -&gt; RFC4180.parse(r).records*.toList() }var data = rows[1..-1].collect{ it[2..-1]*.toDouble() } as double[][] We&#39;ll configure our single node Ignite data cache using code (but we could place the details in a configuration file in more complex scenarios): var cfg = new IgniteConfiguration( peerClassLoadingEnabled: true, discoverySpi: new TcpDiscoverySpi( ipFinder: new TcpDiscoveryMulticastIpFinder( addresses: [&#39;127.0.0.1:47500..47509&#39;] ) )) We&#39;ll create a few helper variables: var features = [&#39;Body&#39;, &#39;Sweetness&#39;, &#39;Smoky&#39;, &#39;Medicinal&#39;, &#39;Tobacco&#39;, &#39;Honey&#39;, &#39;Spicy&#39;, &#39;Winey&#39;, &#39;Nutty&#39;, &#39;Malty&#39;, &#39;Fruity&#39;, &#39;Floral&#39;]var pretty = this.&amp;sprintf.curry(&#39;%.4f&#39;)var dist = new EuclideanDistance()var vectorizer = new DoubleArrayVectorizer().labeled(FIRST) Now we start the node, populate the cache, run our k-means algorithm, and print the result. Ignition.start(cfg).withCloseable { ignite -&gt; println &quot;&gt;&gt;&gt; Ignite grid started for data: ${data.size()} rows X ${data[0].size()} cols&quot; var dataCache = ignite.createCache(new CacheConfiguration&lt;Integer, double[]&gt;( name: &quot;TEST_${UUID.randomUUID()}&quot;, affinity: new RendezvousAffinityFunction(false, 10))) data.indices.each { int i -&gt; dataCache.put(i, data[i]) } var trainer = new KMeansTrainer().withDistance(dist).withAmountOfClusters(5) var mdl = trainer.fit(ignite, dataCache, vectorizer) println &quot;&gt;&gt;&gt; KMeans centroids:\n${features.join(&#39;, &#39;)}&quot; var centroids = mdl.centers*.all() centroids.each { c -&gt; println c*.get().collect(pretty).join(&#39;, &#39;) } dataCache.destroy()} Results Here is the output: [18:13:11] __________ ________________ [18:13:11] / _/ ___/ |/ / _/_ __/ __/ [18:13:11] _/ // (7 7 // / / / / _/ [18:13:11] /___/\___/_/|_/___/ /_/ /x___/ [18:13:11] [18:13:11] ver. 2.14.0#20220929-sha1:951e8deb [18:13:11] 2022 Copyright(C) Apache Software Foundation ... [18:13:11] Configured plugins: [18:13:11] ^-- ml-inference-plugin 1.0.0 [18:13:14] Ignite node started OK (id=f731e4ab) ... &gt;&gt;&gt; Ignite grid started for data: 86 rows X 13 cols &gt;&gt;&gt; KMeans centroids Body, Sweetness, Smoky, Medicinal, Tobacco, Honey, Spicy, Winey, Nutty, Malty, Fruity, Floral 2.7037, 2.4444, 1.4074, 0.0370, 0.0000, 1.8519, 1.6667, 1.8519, 1.8889, 2.0370, 2.1481, 1.6667 1.8500, 1.9000, 2.0000, 0.9500, 0.1500, 1.1000, 1.5000, 0.6000, 1.5500, 1.7000, 1.3000, 1.5000 1.2667, 2.1333, 0.9333, 0.1333, 0.0000, 1.0667, 0.8000, 0.5333, 1.8000, 1.7333, 2.2667, 2.2667 3.6667, 1.5000, 3.6667, 3.3333, 0.6667, 0.1667, 1.6667, 0.5000, 1.1667, 1.3333, 1.1667, 0.1667 1.5000, 2.8889, 1.0000, 0.2778, 0.1667, 1.0000, 1.2222, 0.6111, 0.5556, 1.7778, 1.6667, 2.0000 [18:13:15] Ignite node stopped OK [uptime=00:00:00.663] We can plot the centroid characteristics in a spider plot. More Information &lt;/p&gt; Repo containing the source code: WhiskeyIgnite Repo containing similar examples using a variety of libraries including Apache Commons CSV, Weka, Smile, Tribuo and others: Whiskey A similar example using Apache Spark directly but with a built-in parallelized k-means from the spark-mllib library rather than a hand-crafted algorithm: WhiskeySpark" />
<meta property="og:description" content="In a previous blog post, we looked at using Apache Wayang&nbsp;(incubating) and Apache Spark to scale up the k-means clustering algorithm. Let&#39;s look at another useful technology for scaling up this problem, Apache Ignite. They recently released a new version, but earlier versions are also fine for our example. Before we start, a quick reminder of the problem. Whiskey Clustering This problem looks at the quest of finding the perfect&nbsp;single-malt Scotch whiskey. The whiskies produced from&nbsp;86 distilleries&nbsp;have been ranked by expert tasters according to 12 criteria (Body, Sweetness, Malty, Smoky, Fruity, etc.). We&#39;ll use a K-means algorithm to calculate the centroids. K-means is a standard data-science clustering technique. In our case, it groups whiskies with similar characteristics (according to the 12 criteria) into clusters. If we have a favourite whiskey, chances are we can find something similar by looking at other instances in the same cluster. If we are feeling like a change, we can look for a whiskey in some other cluster. The centroid is the notional &quot;point&quot; in the middle of the cluster. For us it reflects the typical measure of each criteria for a whiskey in that cluster. Apache Ignite Apache Ignite is a distributed database for high-performance computing with in-memory speed. It makes a cluster (or grid) of nodes appear like an in-memory cache. This explanation drastically simplifies Ignite&#39;s feature set. Ignite can be used as: an in-memory cache with special features like SQL querying and transactional properties an in-memory data-grid with advanced read-through &amp; write-through capabilities on top of one or more distributed databases an ultra-fast and horizontally scalable in-memory database a high-performance computing engine for custom or built-in tasks including machine learning It is mostly this last capability that we will use. Ignite&#39;s Machine Learning API has purpose built, cluster-aware machine learning and deep learning algorithms for Classification, Regression, Clustering, and Recommendation among others. We&#39;ll use the distributed K-means Clustering algorithm from their library. Implementation Details Apache Ignite has special capabilities for reading data into the cache. We could use IgniteDataStreamer or IgniteCache.loadCache() and load data from files, stream sources, various database sources and so forth. This is particularly relevant when using a cluster. For our little example, our data is in a relatively small CSV file and we will be using a single node, so we&#39;ll just read our data using&nbsp;Apache Commons CSV: var file = getClass().classLoader.getResource(&#39;whiskey.csv&#39;).file as Filevar rows = file.withReader {r -&gt; RFC4180.parse(r).records*.toList() }var data = rows[1..-1].collect{ it[2..-1]*.toDouble() } as double[][] We&#39;ll configure our single node Ignite data cache using code (but we could place the details in a configuration file in more complex scenarios): var cfg = new IgniteConfiguration( peerClassLoadingEnabled: true, discoverySpi: new TcpDiscoverySpi( ipFinder: new TcpDiscoveryMulticastIpFinder( addresses: [&#39;127.0.0.1:47500..47509&#39;] ) )) We&#39;ll create a few helper variables: var features = [&#39;Body&#39;, &#39;Sweetness&#39;, &#39;Smoky&#39;, &#39;Medicinal&#39;, &#39;Tobacco&#39;, &#39;Honey&#39;, &#39;Spicy&#39;, &#39;Winey&#39;, &#39;Nutty&#39;, &#39;Malty&#39;, &#39;Fruity&#39;, &#39;Floral&#39;]var pretty = this.&amp;sprintf.curry(&#39;%.4f&#39;)var dist = new EuclideanDistance()var vectorizer = new DoubleArrayVectorizer().labeled(FIRST) Now we start the node, populate the cache, run our k-means algorithm, and print the result. Ignition.start(cfg).withCloseable { ignite -&gt; println &quot;&gt;&gt;&gt; Ignite grid started for data: ${data.size()} rows X ${data[0].size()} cols&quot; var dataCache = ignite.createCache(new CacheConfiguration&lt;Integer, double[]&gt;( name: &quot;TEST_${UUID.randomUUID()}&quot;, affinity: new RendezvousAffinityFunction(false, 10))) data.indices.each { int i -&gt; dataCache.put(i, data[i]) } var trainer = new KMeansTrainer().withDistance(dist).withAmountOfClusters(5) var mdl = trainer.fit(ignite, dataCache, vectorizer) println &quot;&gt;&gt;&gt; KMeans centroids:\n${features.join(&#39;, &#39;)}&quot; var centroids = mdl.centers*.all() centroids.each { c -&gt; println c*.get().collect(pretty).join(&#39;, &#39;) } dataCache.destroy()} Results Here is the output: [18:13:11] __________ ________________ [18:13:11] / _/ ___/ |/ / _/_ __/ __/ [18:13:11] _/ // (7 7 // / / / / _/ [18:13:11] /___/\___/_/|_/___/ /_/ /x___/ [18:13:11] [18:13:11] ver. 2.14.0#20220929-sha1:951e8deb [18:13:11] 2022 Copyright(C) Apache Software Foundation ... [18:13:11] Configured plugins: [18:13:11] ^-- ml-inference-plugin 1.0.0 [18:13:14] Ignite node started OK (id=f731e4ab) ... &gt;&gt;&gt; Ignite grid started for data: 86 rows X 13 cols &gt;&gt;&gt; KMeans centroids Body, Sweetness, Smoky, Medicinal, Tobacco, Honey, Spicy, Winey, Nutty, Malty, Fruity, Floral 2.7037, 2.4444, 1.4074, 0.0370, 0.0000, 1.8519, 1.6667, 1.8519, 1.8889, 2.0370, 2.1481, 1.6667 1.8500, 1.9000, 2.0000, 0.9500, 0.1500, 1.1000, 1.5000, 0.6000, 1.5500, 1.7000, 1.3000, 1.5000 1.2667, 2.1333, 0.9333, 0.1333, 0.0000, 1.0667, 0.8000, 0.5333, 1.8000, 1.7333, 2.2667, 2.2667 3.6667, 1.5000, 3.6667, 3.3333, 0.6667, 0.1667, 1.6667, 0.5000, 1.1667, 1.3333, 1.1667, 0.1667 1.5000, 2.8889, 1.0000, 0.2778, 0.1667, 1.0000, 1.2222, 0.6111, 0.5556, 1.7778, 1.6667, 2.0000 [18:13:15] Ignite node stopped OK [uptime=00:00:00.663] We can plot the centroid characteristics in a spider plot. More Information &lt;/p&gt; Repo containing the source code: WhiskeyIgnite Repo containing similar examples using a variety of libraries including Apache Commons CSV, Weka, Smile, Tribuo and others: Whiskey A similar example using Apache Spark directly but with a built-in parallelized k-means from the spark-mllib library rather than a hand-crafted algorithm: WhiskeySpark" />
<link rel="canonical" href="http://localhost:4000/groovy/entry/whiskey-clustering-with-groovy-and" />
<meta property="og:url" content="http://localhost:4000/groovy/entry/whiskey-clustering-with-groovy-and" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-10-27T11:21:29-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Whiskey Clustering with Groovy and Apache Ignite" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-10-27T11:21:29-04:00","datePublished":"2022-10-27T11:21:29-04:00","description":"In a previous blog post, we looked at using Apache Wayang&nbsp;(incubating) and Apache Spark to scale up the k-means clustering algorithm. Let&#39;s look at another useful technology for scaling up this problem, Apache Ignite. They recently released a new version, but earlier versions are also fine for our example. Before we start, a quick reminder of the problem. Whiskey Clustering This problem looks at the quest of finding the perfect&nbsp;single-malt Scotch whiskey. The whiskies produced from&nbsp;86 distilleries&nbsp;have been ranked by expert tasters according to 12 criteria (Body, Sweetness, Malty, Smoky, Fruity, etc.). We&#39;ll use a K-means algorithm to calculate the centroids. K-means is a standard data-science clustering technique. In our case, it groups whiskies with similar characteristics (according to the 12 criteria) into clusters. If we have a favourite whiskey, chances are we can find something similar by looking at other instances in the same cluster. If we are feeling like a change, we can look for a whiskey in some other cluster. The centroid is the notional &quot;point&quot; in the middle of the cluster. For us it reflects the typical measure of each criteria for a whiskey in that cluster. Apache Ignite Apache Ignite is a distributed database for high-performance computing with in-memory speed. It makes a cluster (or grid) of nodes appear like an in-memory cache. This explanation drastically simplifies Ignite&#39;s feature set. Ignite can be used as: an in-memory cache with special features like SQL querying and transactional properties an in-memory data-grid with advanced read-through &amp; write-through capabilities on top of one or more distributed databases an ultra-fast and horizontally scalable in-memory database a high-performance computing engine for custom or built-in tasks including machine learning It is mostly this last capability that we will use. Ignite&#39;s Machine Learning API has purpose built, cluster-aware machine learning and deep learning algorithms for Classification, Regression, Clustering, and Recommendation among others. We&#39;ll use the distributed K-means Clustering algorithm from their library. Implementation Details Apache Ignite has special capabilities for reading data into the cache. We could use IgniteDataStreamer or IgniteCache.loadCache() and load data from files, stream sources, various database sources and so forth. This is particularly relevant when using a cluster. For our little example, our data is in a relatively small CSV file and we will be using a single node, so we&#39;ll just read our data using&nbsp;Apache Commons CSV: var file = getClass().classLoader.getResource(&#39;whiskey.csv&#39;).file as Filevar rows = file.withReader {r -&gt; RFC4180.parse(r).records*.toList() }var data = rows[1..-1].collect{ it[2..-1]*.toDouble() } as double[][] We&#39;ll configure our single node Ignite data cache using code (but we could place the details in a configuration file in more complex scenarios): var cfg = new IgniteConfiguration( peerClassLoadingEnabled: true, discoverySpi: new TcpDiscoverySpi( ipFinder: new TcpDiscoveryMulticastIpFinder( addresses: [&#39;127.0.0.1:47500..47509&#39;] ) )) We&#39;ll create a few helper variables: var features = [&#39;Body&#39;, &#39;Sweetness&#39;, &#39;Smoky&#39;, &#39;Medicinal&#39;, &#39;Tobacco&#39;, &#39;Honey&#39;, &#39;Spicy&#39;, &#39;Winey&#39;, &#39;Nutty&#39;, &#39;Malty&#39;, &#39;Fruity&#39;, &#39;Floral&#39;]var pretty = this.&amp;sprintf.curry(&#39;%.4f&#39;)var dist = new EuclideanDistance()var vectorizer = new DoubleArrayVectorizer().labeled(FIRST) Now we start the node, populate the cache, run our k-means algorithm, and print the result. Ignition.start(cfg).withCloseable { ignite -&gt; println &quot;&gt;&gt;&gt; Ignite grid started for data: ${data.size()} rows X ${data[0].size()} cols&quot; var dataCache = ignite.createCache(new CacheConfiguration&lt;Integer, double[]&gt;( name: &quot;TEST_${UUID.randomUUID()}&quot;, affinity: new RendezvousAffinityFunction(false, 10))) data.indices.each { int i -&gt; dataCache.put(i, data[i]) } var trainer = new KMeansTrainer().withDistance(dist).withAmountOfClusters(5) var mdl = trainer.fit(ignite, dataCache, vectorizer) println &quot;&gt;&gt;&gt; KMeans centroids:\\n${features.join(&#39;, &#39;)}&quot; var centroids = mdl.centers*.all() centroids.each { c -&gt; println c*.get().collect(pretty).join(&#39;, &#39;) } dataCache.destroy()} Results Here is the output: [18:13:11] __________ ________________ [18:13:11] / _/ ___/ |/ / _/_ __/ __/ [18:13:11] _/ // (7 7 // / / / / _/ [18:13:11] /___/\\___/_/|_/___/ /_/ /x___/ [18:13:11] [18:13:11] ver. 2.14.0#20220929-sha1:951e8deb [18:13:11] 2022 Copyright(C) Apache Software Foundation ... [18:13:11] Configured plugins: [18:13:11] ^-- ml-inference-plugin 1.0.0 [18:13:14] Ignite node started OK (id=f731e4ab) ... &gt;&gt;&gt; Ignite grid started for data: 86 rows X 13 cols &gt;&gt;&gt; KMeans centroids Body, Sweetness, Smoky, Medicinal, Tobacco, Honey, Spicy, Winey, Nutty, Malty, Fruity, Floral 2.7037, 2.4444, 1.4074, 0.0370, 0.0000, 1.8519, 1.6667, 1.8519, 1.8889, 2.0370, 2.1481, 1.6667 1.8500, 1.9000, 2.0000, 0.9500, 0.1500, 1.1000, 1.5000, 0.6000, 1.5500, 1.7000, 1.3000, 1.5000 1.2667, 2.1333, 0.9333, 0.1333, 0.0000, 1.0667, 0.8000, 0.5333, 1.8000, 1.7333, 2.2667, 2.2667 3.6667, 1.5000, 3.6667, 3.3333, 0.6667, 0.1667, 1.6667, 0.5000, 1.1667, 1.3333, 1.1667, 0.1667 1.5000, 2.8889, 1.0000, 0.2778, 0.1667, 1.0000, 1.2222, 0.6111, 0.5556, 1.7778, 1.6667, 2.0000 [18:13:15] Ignite node stopped OK [uptime=00:00:00.663] We can plot the centroid characteristics in a spider plot. More Information &lt;/p&gt; Repo containing the source code: WhiskeyIgnite Repo containing similar examples using a variety of libraries including Apache Commons CSV, Weka, Smile, Tribuo and others: Whiskey A similar example using Apache Spark directly but with a built-in parallelized k-means from the spark-mllib library rather than a hand-crafted algorithm: WhiskeySpark","headline":"Whiskey Clustering with Groovy and Apache Ignite","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/groovy/entry/whiskey-clustering-with-groovy-and"},"url":"http://localhost:4000/groovy/entry/whiskey-clustering-with-groovy-and"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Whiskey Clustering with Groovy and Apache Ignite</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-10-27T11:21:29-04:00" itemprop="datePublished">Oct 27, 2022
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Paul King", "login"=>"paulk", "email"=>"paulk@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>In a previous <a href="https://blogs.apache.org/groovy/entry/using-groovy-with-apache-wayang" target="_blank">blog post</a>, <img src="https://ignite.apache.org/img/logo.svg" align="right"> we looked at using <a href="https://wayang.apache.org/" target="_blank" style="background-color: rgb(255, 255, 255);">Apache Wayang</a>&nbsp;(incubating) and <a href="https://spark.apache.org/" target="_blank">Apache Spark</a> to scale up the <a href="https://en.wikipedia.org/wiki/K-means_clustering" target="_blank">k-means</a> clustering algorithm. Let's look at another useful technology for scaling up this problem, <a href="https://ignite.apache.org/" target="_blank">Apache Ignite</a>. They recently released a <a href="https://ignite.apache.org/releases/2.14.0/release_notes.html" target="_blank">new version</a>, but earlier versions are also fine for our example. Before we start, a quick reminder of the problem.</p>
<h2>Whiskey Clustering</h2>
<p><img src="https://blogs.apache.org/groovy/mediaresource/c5ba5e59-737e-4ebf-91c9-08fa67dc8f70" align="right" alt="groovy.png" style="width: 15%;">This problem looks at the quest of finding the perfect&nbsp;single-malt Scotch whiskey. The whiskies produced from&nbsp;<a href="https://www.niss.org/sites/default/files/ScotchWhisky01.txt" rel="nofollow" style="transition: color 80ms cubic-bezier(0.33, 1, 0.68, 1) 0s, background-color 0s ease 0s, box-shadow 0s ease 0s, border-color 0s ease 0s;">86 distilleries</a>&nbsp;have been ranked by expert tasters according to 12 criteria (Body, Sweetness, Malty, Smoky, Fruity, etc.). We'll use a K-means algorithm to calculate the centroids.</p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/8d458e7c-8993-470a-8afd-44a46cd2b500" alt="whiskey_bottles.jpg"></p>
<p>K-means is a standard data-science clustering technique. In our case, it groups whiskies with similar characteristics (according to the 12 criteria) into clusters. If we have a favourite whiskey, chances are we can find something similar by looking at other instances in the same cluster. If we are feeling like a change, we can look for a whiskey in some other cluster. The centroid is the notional "point" in the middle of the cluster. For us it reflects the typical measure of each criteria for a whiskey in that cluster.</p>
<h2>Apache Ignite</h2>
<p>Apache Ignite is a distributed database for high-performance computing with in-memory speed. It makes a cluster (or <i>grid</i>) of nodes appear like an in-memory cache.</p>
<p>This explanation drastically simplifies Ignite's feature set. Ignite can be used as:</p>
<ul>
<li>an in-memory cache with special features like SQL querying and transactional properties</li>
<li>an in-memory data-grid with advanced read-through &amp; write-through capabilities on top of one or more distributed databases</li>
<li>an ultra-fast and horizontally scalable in-memory database</li>
<li>a high-performance computing engine for custom or built-in tasks including machine learning</li>
</ul>
<p>It is mostly this last capability that we will use. Ignite's <i>Machine Learning API</i> has purpose built, cluster-aware machine learning and deep learning algorithms for Classification, Regression, Clustering, and Recommendation among others. We'll use the distributed <a href="https://ignite.apache.org/docs/latest/machine-learning/clustering/k-means-clustering" target="_blank">K-means Clustering</a> algorithm from their library.</p>
<p><img src="https://blogs.apache.org/groovy/mediaresource/abe5bcc8-f8cd-470c-8087-30693ed4a5dc" style="width:50%" alt="2022-10-27 21_17_19-Machine Learning _ Ignite Documentation.png"></p>
<h2>Implementation Details</h2>
<p>Apache Ignite has special capabilities for reading data into the cache. We could use <code>IgniteDataStreamer</code> or <code>IgniteCache.loadCache()</code> and load data from files, stream sources, various database sources and so forth. This is particularly relevant when using a cluster.</p>
<p>For our little example, our data is in a relatively small CSV file and we will be using a single node, so we'll just read our data using&nbsp;<a href="https://commons.apache.org/csv/" target="_blank" style="background-color: rgb(255, 255, 255);">Apache Commons CSV</a>:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>file = getClass().<span style="color:#9876aa;">classLoader</span>.getResource(<span style="color:#6a8759;">'whiskey.csv'</span>).<span style="color:#9876aa;">file </span><span style="color:#cc7832;">as </span>File<br><span style="color:#cc7832;">var </span>rows = file.withReader <span style="font-weight:bold;">{</span>r <span style="font-weight:bold;">-> </span><span style="color:#9876aa;font-style:italic;">RFC4180</span>.parse(r).<span style="color:#9876aa;">records</span>*.toList() <span style="font-weight:bold;">}<br></span><span style="color:#cc7832;">var </span>data = rows[<span style="color:#6897bb;">1</span>..-<span style="color:#6897bb;">1</span>].collect<span style="font-weight:bold;">{ </span>it[<span style="color:#6897bb;">2</span>..-<span style="color:#6897bb;">1</span>]*.toDouble() <span style="font-weight:bold;">} </span><span style="color:#cc7832;">as double</span>[][]</pre>
<p>We'll configure our single node Ignite data cache using code (but we could place the details in a configuration file in more complex scenarios):</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>cfg = <span style="color:#cc7832;">new </span>IgniteConfiguration(<br>        <span style="color:#6a8759;">peerClassLoadingEnabled</span>: <span style="color:#cc7832;">true</span>,<br>        <span style="color:#6a8759;">discoverySpi</span>: <span style="color:#cc7832;">new </span>TcpDiscoverySpi(<br>                <span style="color:#6a8759;">ipFinder</span>: <span style="color:#cc7832;">new </span>TcpDiscoveryMulticastIpFinder(<br>                        <span style="color:#6a8759;">addresses</span>: [<span style="color:#6a8759;">'127.0.0.1:47500..47509'</span>]<br>                )<br>        )<br>)<br></pre>
<p>We'll create a few helper variables:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>features = [<span style="color:#6a8759;">'Body'</span>, <span style="color:#6a8759;">'Sweetness'</span>, <span style="color:#6a8759;">'Smoky'</span>, <span style="color:#6a8759;">'Medicinal'</span>, <span style="color:#6a8759;">'Tobacco'</span>,<br>                <span style="color:#6a8759;">'Honey'</span>, <span style="color:#6a8759;">'Spicy'</span>, <span style="color:#6a8759;">'Winey'</span>, <span style="color:#6a8759;">'Nutty'</span>, <span style="color:#6a8759;">'Malty'</span>, <span style="color:#6a8759;">'Fruity'</span>, <span style="color:#6a8759;">'Floral'</span>]<br><span style="color:#cc7832;">var </span>pretty = <span style="color:#cc7832;">this</span>.&amp;sprintf.curry(<span style="color:#6a8759;">'%.4f'</span>)<br><span style="color:#cc7832;">var </span>dist = <span style="color:#cc7832;">new </span>EuclideanDistance()<br><span style="color:#cc7832;">var </span>vectorizer = <span style="color:#cc7832;">new </span>DoubleArrayVectorizer().labeled(<span style="color:#9876aa;font-style:italic;">FIRST</span>)</pre>
<p>Now we start the node, populate the cache, run our k-means algorithm, and print the result.</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">Ignition.<span style="color:#9876aa;font-style:italic;">start</span>(cfg).withCloseable <span style="font-weight:bold;">{ </span>ignite <span style="font-weight:bold;">-><br></span><span style="font-weight:bold;">    </span>println <span style="color:#6a8759;">">>> Ignite grid started for data: </span>$<span style="font-weight:bold;">{</span>data.size()<span style="font-weight:bold;">}</span><span style="color:#6a8759;"> rows X </span>$<span style="font-weight:bold;">{</span>data[<span style="color:#6897bb;">0</span>].size()<span style="font-weight:bold;">}</span><span style="color:#6a8759;"> cols"<br></span><span style="color:#6a8759;">    </span><span style="color:#cc7832;">var </span>dataCache = ignite.createCache(<span style="color:#cc7832;">new </span>CacheConfiguration<Integer, <span style="color:#cc7832;">double</span>[]>(<br>          <span style="color:#6a8759;">name</span>: <span style="color:#6a8759;">"TEST_</span>$<span style="font-weight:bold;">{</span>UUID.<span style="color:#9876aa;font-style:italic;">randomUUID</span>()<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"</span>,<br>          <span style="color:#6a8759;">affinity</span>: <span style="color:#cc7832;">new </span>RendezvousAffinityFunction(<span style="color:#cc7832;">false</span>, <span style="color:#6897bb;">10</span>)))<br>    data.<span style="color:#9876aa;">indices</span>.each <span style="font-weight:bold;">{ </span><span style="color:#cc7832;">int </span>i <span style="font-weight:bold;">-> </span>dataCache.put(i, data[i]) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">var </span>trainer = <span style="color:#cc7832;">new </span>KMeansTrainer().withDistance(dist).withAmountOfClusters(<span style="color:#6897bb;">5</span>)<br>    <span style="color:#cc7832;">var </span>mdl = trainer.fit(ignite, dataCache, vectorizer)<br>    println <span style="color:#6a8759;">">>> KMeans centroids:</span><span style="color:#cc7832;">\n</span>$<span style="font-weight:bold;">{</span>features.join(<span style="color:#6a8759;">', '</span>)<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span><span style="color:#cc7832;">var </span>centroids = mdl.<span style="color:#9876aa;">centers</span>*.all()<br>    centroids.each <span style="font-weight:bold;">{ </span>c <span style="font-weight:bold;">-> </span>println c*.get().collect(pretty).join(<span style="color:#6a8759;">', '</span>) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span>dataCache.destroy()<br><span style="font-weight:bold;">}</span></pre>
<h2>Results</h2>
<p>Here is the output:</p>
<pre>[18:13:11]    __________  ________________
[18:13:11]   /  _/ ___/ |/ /  _/_  __/ __/
[18:13:11]  _/ // (7 7    // /  / / / _/
[18:13:11] /___/\___/_/|_/___/ /_/ /x___/
[18:13:11]
[18:13:11] ver. 2.14.0#20220929-sha1:951e8deb
[18:13:11] 2022 Copyright(C) Apache Software Foundation
...
[18:13:11] Configured plugins:
[18:13:11]   ^-- ml-inference-plugin 1.0.0
[18:13:14] Ignite node started OK (id=f731e4ab)
...
>>> Ignite grid started for data: 86 rows X 13 cols
>>> KMeans centroids
Body, Sweetness, Smoky, Medicinal, Tobacco, Honey, Spicy, Winey, Nutty, Malty, Fruity, Floral
2.7037, 2.4444, 1.4074, 0.0370, 0.0000, 1.8519, 1.6667, 1.8519, 1.8889, 2.0370, 2.1481, 1.6667
1.8500, 1.9000, 2.0000, 0.9500, 0.1500, 1.1000, 1.5000, 0.6000, 1.5500, 1.7000, 1.3000, 1.5000
1.2667, 2.1333, 0.9333, 0.1333, 0.0000, 1.0667, 0.8000, 0.5333, 1.8000, 1.7333, 2.2667, 2.2667
3.6667, 1.5000, 3.6667, 3.3333, 0.6667, 0.1667, 1.6667, 0.5000, 1.1667, 1.3333, 1.1667, 0.1667
1.5000, 2.8889, 1.0000, 0.2778, 0.1667, 1.0000, 1.2222, 0.6111, 0.5556, 1.7778, 1.6667, 2.0000
[18:13:15] Ignite node stopped OK [uptime=00:00:00.663]
</pre>
<p>We can plot the centroid characteristics in a spider plot.</p>
<p><img style="width:50%" src="https://blogs.apache.org/groovy/mediaresource/9a73886e-9cf6-4937-a70d-e366a784c21c" alt="2022-10-27 20_42_01-Whiskey clusters with Apache Ignite.png"><br></p>
<p><br></p>
<h2>More Information</h2></p>
<ul>
<li>Repo containing the source code:<br />
<a href="https://github.com/paulk-asert/groovy-data-science/tree/master/subprojects/WhiskeyIgnite" style="background-color: rgb(255, 255, 255);">WhiskeyIgnite</a><br></li>
<li>Repo containing similar examples using a variety of libraries including Apache Commons CSV,<br />
Weka, Smile, Tribuo and others:<br />
<a href="https://github.com/paulk-asert/groovy-data-science/tree/master/subprojects/Whiskey" style="background-color: rgb(255, 255, 255);">Whiskey</a><br></li>
<li>A similar example using Apache Spark directly but with a built-in parallelized k-means from the spark-mllib library rather than a hand-crafted algorithm:<br />
<a href="https://github.com/paulk-asert/groovy-data-science/tree/master/subprojects/WhiskeySpark" style="background-color: rgb(255, 255, 255);">WhiskeySpark</a><br></li>
</ul>

  </div><a class="u-url" href="/groovy/entry/whiskey-clustering-with-groovy-and" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
