<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>JVM Hello World with Groovy | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="JVM Hello World with Groovy" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="For those that haven&#39;t seen it yet, the JVM Advent folks posted a great Groovy and Data Science blog post several days ago as part of the 2022 JVM Advent series. If you have an interest in Data Science, we recommend you check that out before continuing with this post. Today&#39;s post in the JVM Advent series is looking at the world of bytecode libraries on the JVM. Let&#39;s look at creating the same hello world example from that post using Groovy with the ProGuardCORE, ASM, and Byte Buddy libraries. First, we highly recommend you read the previously mentioned JVM Advent post first for more background. After all, it&#39;s easy to create a simple hello world class file example directly as a Java source file (as that post shows) or as a Groovy source file like this: println &#39;Hello world&#39; The examples shown in this blog post illustrate how you could create the equivalent class file using libraries which let you manipulate the generated bytecode directly. It&#39;s a bit of a deep dive if you want to know more about JVM internals and can also be handy for numerous use cases like building tools or&nbsp;modifying Java classes on the fly. I suggest you read the web sites for those libraries if you want further details or additional motivation. ProGuardCORE The ProGuardCORE library lets you&nbsp;read, analyze, modify, and write Java class files. Here&#39;s how we could use it to write a hello world class file: var name = &#39;HelloProGuardCORE&#39;var superclass = &#39;java/lang/Object&#39;var classBuilder = new ClassBuilder(CLASS_VERSION_1_8, PUBLIC, name, superclass).tap { addMethod(PUBLIC | STATIC, &#39;main&#39;, &#39;([Ljava/lang/String;)V&#39;, 100, builder -&gt; builder .getstatic(&#39;java/lang/System&#39;, &#39;out&#39;, &#39;Ljava/io/PrintStream;&#39;) .ldc(&quot;Hello from $name&quot;) .invokevirtual(&#39;java/io/PrintStream&#39;, &#39;println&#39;, &#39;(Ljava/lang/String;)V&#39;) .return_() )}new File(&quot;${name}.class&quot;).withDataOutputStream { dos -&gt; classBuilder.programClass.accept(new ProgramClassWriter(dos))} This is essentially the &quot;Groovified&quot; version of the example in the JVM Advent blog post. We are using the libraries ClassBuilder class, adding a method, then adding four bytecode statements as the body of the method. If you haven&#39;t seen method and type descriptor syntax before, a few parts might seem a little strange but you possibly won&#39;t be surprised that it seems to be referencing a System.out.println call and passing it a constant String. When we run this script, a HelloProGuardCORE class file is produced. We can invoke that class file in the normal way: $ java HelloProGuardCORE Hello from HelloProGuardCORE We encourage you to read the JVM Advent post or the library documentation if you want more details. ASM ASM is an all purpose Java bytecode manipulation and analysis framework. In fact, it&#39;s the one that Groovy uses in its parser and some of its tools. Here is how to use it to generate more or less the same class as previously: var name = &#39;HelloASM&#39;var superclass = &#39;java/lang/Object&#39;var cw = new ClassWriter(0)cw.visit(V1_8, ACC_PUBLIC + ACC_SUPER, name, null, superclass, null)cw.visitMethod(ACC_PUBLIC + ACC_STATIC, &#39;main&#39;, &#39;([Ljava/lang/String;)V&#39;, null, null).with { visitCode() visitFieldInsn(GETSTATIC, &#39;java/lang/System&#39;, &#39;out&#39;, &#39;Ljava/io/PrintStream;&#39;) visitLdcInsn(&#39;Hello from &#39; + name) visitMethodInsn(INVOKEVIRTUAL, &#39;java/io/PrintStream&#39;, &#39;println&#39;, &#39;(Ljava/lang/String;)V&#39;, false) visitInsn(RETURN) visitMaxs(3, 3) visitEnd()}cw.visitEnd()new File(&quot;${name}.class&quot;).withDataOutputStream { dos -&gt; dos.write(cw.toByteArray())} After running this script, a HelloASM class file is produced, and here is the output when running that class file: $ java HelloASM Hello from HelloASM Parts of the code should look familiar to the previous example. Byte Buddy Byte Buddy is a code generation and manipulation library for creating and modifying Java classes. It&#39;s strengths lie in its ability to create and modify classes dynamically. So, its power is perhaps not needed for our simple example. A nice aspect of this library however, is that it hides some of the low-level details like type and method descriptors behind its fluent API. Here is our example: var name = &#39;HelloByteBuddy&#39;new ByteBuddy() .subclass(Object) .name(name) .defineMethod(&#39;main&#39;, Void.TYPE, PUBLIC | STATIC) .withParameter(String[]) .intercept(MethodCall.invoke( PrintStream.getMethod(&#39;println&#39;, String)) .onField(System.getField(&#39;out&#39;)) .with(&#39;Hello from &#39; + name)) .make() .saveIn(&#39;.&#39; as File) Like the other scripts, this also produces a class file which we can invoke as shown here: $ java HelloByteBuddy Hello from HelloByteBuddy That wraps up our examples using the three libraries, but we have one more fun alternative to cover! Using Groovy ASTs Groovy is a very extensible language. It provides among other things, a compile-time metaprogramming mechanism called AST Transforms (Abstract Syntax Tree Transformations). This mechanism uses annotations to indicate to the compiler that special processing is required during compilation. A now somewhat outdated AST transform, @Bytecode, experimented with allowing you to write bytecode instructions directly in your Groovy code. Let&#39;s look at using that AST transform here: @CompileStatic @POJOclass HelloAST { @Bytecode static void main(args) { getstatic &#39;java/lang/System.out&#39;, &#39;Ljava/io/PrintStream;&#39; ldc &#39;Hello from HelloAST&#39; invokevirtual &#39;java/io/PrintStream.println&#39;, &#39;(Ljava/lang/String;)V&#39; return }} We are writing directly the instructions that the Java or Groovy compiler (with static compilation enabled) would produce. For this example, we don&#39;t run the script to produce the class file, we just compile it using the Groovy compiler. We definitely don&#39;t recommend relying on the @Bytecode AST transform for any production code but it can be fun to play with. We&#39;ve also used the @CompileStatic and @POJO AST transforms to tell the compiler that we aren&#39;t using any Groovy dynamic features, so that it should write Java-like code whenever possible and avoid calling the Groovy runtime. We can examine the bytecode using javap and indeed it has bytecode similar to that produced by the other libraries: public static void main(java.lang.String...); descriptor: ([Ljava/lang/String;)V flags: (0x0089) ACC_PUBLIC, ACC_STATIC, ACC_VARARGS Code: stack=2, locals=1, args_size=1 0: getstatic #21 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #23 // String Hello from HelloAST 5: invokevirtual #29 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LocalVariableTable: Start Length Slot Name Signature 0 9 0 args Ljava/lang/Object; Because the code is not calling the Groovy runtime, we can invoke it directly without the Groovy jar: $ java HelloAST Hello from HelloAST That wraps up our little tour of bytecode libraries. I hope you have learnt some additional JVM details! Further information Github repo of the above examples A draft JEP for what might become an official API for parsing, generating, and transforming Java class files Social media:&nbsp;@ApacheGroovy @ApacheGroovy@fosstodon.org" />
<meta property="og:description" content="For those that haven&#39;t seen it yet, the JVM Advent folks posted a great Groovy and Data Science blog post several days ago as part of the 2022 JVM Advent series. If you have an interest in Data Science, we recommend you check that out before continuing with this post. Today&#39;s post in the JVM Advent series is looking at the world of bytecode libraries on the JVM. Let&#39;s look at creating the same hello world example from that post using Groovy with the ProGuardCORE, ASM, and Byte Buddy libraries. First, we highly recommend you read the previously mentioned JVM Advent post first for more background. After all, it&#39;s easy to create a simple hello world class file example directly as a Java source file (as that post shows) or as a Groovy source file like this: println &#39;Hello world&#39; The examples shown in this blog post illustrate how you could create the equivalent class file using libraries which let you manipulate the generated bytecode directly. It&#39;s a bit of a deep dive if you want to know more about JVM internals and can also be handy for numerous use cases like building tools or&nbsp;modifying Java classes on the fly. I suggest you read the web sites for those libraries if you want further details or additional motivation. ProGuardCORE The ProGuardCORE library lets you&nbsp;read, analyze, modify, and write Java class files. Here&#39;s how we could use it to write a hello world class file: var name = &#39;HelloProGuardCORE&#39;var superclass = &#39;java/lang/Object&#39;var classBuilder = new ClassBuilder(CLASS_VERSION_1_8, PUBLIC, name, superclass).tap { addMethod(PUBLIC | STATIC, &#39;main&#39;, &#39;([Ljava/lang/String;)V&#39;, 100, builder -&gt; builder .getstatic(&#39;java/lang/System&#39;, &#39;out&#39;, &#39;Ljava/io/PrintStream;&#39;) .ldc(&quot;Hello from $name&quot;) .invokevirtual(&#39;java/io/PrintStream&#39;, &#39;println&#39;, &#39;(Ljava/lang/String;)V&#39;) .return_() )}new File(&quot;${name}.class&quot;).withDataOutputStream { dos -&gt; classBuilder.programClass.accept(new ProgramClassWriter(dos))} This is essentially the &quot;Groovified&quot; version of the example in the JVM Advent blog post. We are using the libraries ClassBuilder class, adding a method, then adding four bytecode statements as the body of the method. If you haven&#39;t seen method and type descriptor syntax before, a few parts might seem a little strange but you possibly won&#39;t be surprised that it seems to be referencing a System.out.println call and passing it a constant String. When we run this script, a HelloProGuardCORE class file is produced. We can invoke that class file in the normal way: $ java HelloProGuardCORE Hello from HelloProGuardCORE We encourage you to read the JVM Advent post or the library documentation if you want more details. ASM ASM is an all purpose Java bytecode manipulation and analysis framework. In fact, it&#39;s the one that Groovy uses in its parser and some of its tools. Here is how to use it to generate more or less the same class as previously: var name = &#39;HelloASM&#39;var superclass = &#39;java/lang/Object&#39;var cw = new ClassWriter(0)cw.visit(V1_8, ACC_PUBLIC + ACC_SUPER, name, null, superclass, null)cw.visitMethod(ACC_PUBLIC + ACC_STATIC, &#39;main&#39;, &#39;([Ljava/lang/String;)V&#39;, null, null).with { visitCode() visitFieldInsn(GETSTATIC, &#39;java/lang/System&#39;, &#39;out&#39;, &#39;Ljava/io/PrintStream;&#39;) visitLdcInsn(&#39;Hello from &#39; + name) visitMethodInsn(INVOKEVIRTUAL, &#39;java/io/PrintStream&#39;, &#39;println&#39;, &#39;(Ljava/lang/String;)V&#39;, false) visitInsn(RETURN) visitMaxs(3, 3) visitEnd()}cw.visitEnd()new File(&quot;${name}.class&quot;).withDataOutputStream { dos -&gt; dos.write(cw.toByteArray())} After running this script, a HelloASM class file is produced, and here is the output when running that class file: $ java HelloASM Hello from HelloASM Parts of the code should look familiar to the previous example. Byte Buddy Byte Buddy is a code generation and manipulation library for creating and modifying Java classes. It&#39;s strengths lie in its ability to create and modify classes dynamically. So, its power is perhaps not needed for our simple example. A nice aspect of this library however, is that it hides some of the low-level details like type and method descriptors behind its fluent API. Here is our example: var name = &#39;HelloByteBuddy&#39;new ByteBuddy() .subclass(Object) .name(name) .defineMethod(&#39;main&#39;, Void.TYPE, PUBLIC | STATIC) .withParameter(String[]) .intercept(MethodCall.invoke( PrintStream.getMethod(&#39;println&#39;, String)) .onField(System.getField(&#39;out&#39;)) .with(&#39;Hello from &#39; + name)) .make() .saveIn(&#39;.&#39; as File) Like the other scripts, this also produces a class file which we can invoke as shown here: $ java HelloByteBuddy Hello from HelloByteBuddy That wraps up our examples using the three libraries, but we have one more fun alternative to cover! Using Groovy ASTs Groovy is a very extensible language. It provides among other things, a compile-time metaprogramming mechanism called AST Transforms (Abstract Syntax Tree Transformations). This mechanism uses annotations to indicate to the compiler that special processing is required during compilation. A now somewhat outdated AST transform, @Bytecode, experimented with allowing you to write bytecode instructions directly in your Groovy code. Let&#39;s look at using that AST transform here: @CompileStatic @POJOclass HelloAST { @Bytecode static void main(args) { getstatic &#39;java/lang/System.out&#39;, &#39;Ljava/io/PrintStream;&#39; ldc &#39;Hello from HelloAST&#39; invokevirtual &#39;java/io/PrintStream.println&#39;, &#39;(Ljava/lang/String;)V&#39; return }} We are writing directly the instructions that the Java or Groovy compiler (with static compilation enabled) would produce. For this example, we don&#39;t run the script to produce the class file, we just compile it using the Groovy compiler. We definitely don&#39;t recommend relying on the @Bytecode AST transform for any production code but it can be fun to play with. We&#39;ve also used the @CompileStatic and @POJO AST transforms to tell the compiler that we aren&#39;t using any Groovy dynamic features, so that it should write Java-like code whenever possible and avoid calling the Groovy runtime. We can examine the bytecode using javap and indeed it has bytecode similar to that produced by the other libraries: public static void main(java.lang.String...); descriptor: ([Ljava/lang/String;)V flags: (0x0089) ACC_PUBLIC, ACC_STATIC, ACC_VARARGS Code: stack=2, locals=1, args_size=1 0: getstatic #21 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #23 // String Hello from HelloAST 5: invokevirtual #29 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LocalVariableTable: Start Length Slot Name Signature 0 9 0 args Ljava/lang/Object; Because the code is not calling the Groovy runtime, we can invoke it directly without the Groovy jar: $ java HelloAST Hello from HelloAST That wraps up our little tour of bytecode libraries. I hope you have learnt some additional JVM details! Further information Github repo of the above examples A draft JEP for what might become an official API for parsing, generating, and transforming Java class files Social media:&nbsp;@ApacheGroovy @ApacheGroovy@fosstodon.org" />
<link rel="canonical" href="http://localhost:4000/groovy/entry/jvm-hello-world-with-groovy" />
<meta property="og:url" content="http://localhost:4000/groovy/entry/jvm-hello-world-with-groovy" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-12-22T14:24:07-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="JVM Hello World with Groovy" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-12-22T14:24:07-05:00","datePublished":"2022-12-22T14:24:07-05:00","description":"For those that haven&#39;t seen it yet, the JVM Advent folks posted a great Groovy and Data Science blog post several days ago as part of the 2022 JVM Advent series. If you have an interest in Data Science, we recommend you check that out before continuing with this post. Today&#39;s post in the JVM Advent series is looking at the world of bytecode libraries on the JVM. Let&#39;s look at creating the same hello world example from that post using Groovy with the ProGuardCORE, ASM, and Byte Buddy libraries. First, we highly recommend you read the previously mentioned JVM Advent post first for more background. After all, it&#39;s easy to create a simple hello world class file example directly as a Java source file (as that post shows) or as a Groovy source file like this: println &#39;Hello world&#39; The examples shown in this blog post illustrate how you could create the equivalent class file using libraries which let you manipulate the generated bytecode directly. It&#39;s a bit of a deep dive if you want to know more about JVM internals and can also be handy for numerous use cases like building tools or&nbsp;modifying Java classes on the fly. I suggest you read the web sites for those libraries if you want further details or additional motivation. ProGuardCORE The ProGuardCORE library lets you&nbsp;read, analyze, modify, and write Java class files. Here&#39;s how we could use it to write a hello world class file: var name = &#39;HelloProGuardCORE&#39;var superclass = &#39;java/lang/Object&#39;var classBuilder = new ClassBuilder(CLASS_VERSION_1_8, PUBLIC, name, superclass).tap { addMethod(PUBLIC | STATIC, &#39;main&#39;, &#39;([Ljava/lang/String;)V&#39;, 100, builder -&gt; builder .getstatic(&#39;java/lang/System&#39;, &#39;out&#39;, &#39;Ljava/io/PrintStream;&#39;) .ldc(&quot;Hello from $name&quot;) .invokevirtual(&#39;java/io/PrintStream&#39;, &#39;println&#39;, &#39;(Ljava/lang/String;)V&#39;) .return_() )}new File(&quot;${name}.class&quot;).withDataOutputStream { dos -&gt; classBuilder.programClass.accept(new ProgramClassWriter(dos))} This is essentially the &quot;Groovified&quot; version of the example in the JVM Advent blog post. We are using the libraries ClassBuilder class, adding a method, then adding four bytecode statements as the body of the method. If you haven&#39;t seen method and type descriptor syntax before, a few parts might seem a little strange but you possibly won&#39;t be surprised that it seems to be referencing a System.out.println call and passing it a constant String. When we run this script, a HelloProGuardCORE class file is produced. We can invoke that class file in the normal way: $ java HelloProGuardCORE Hello from HelloProGuardCORE We encourage you to read the JVM Advent post or the library documentation if you want more details. ASM ASM is an all purpose Java bytecode manipulation and analysis framework. In fact, it&#39;s the one that Groovy uses in its parser and some of its tools. Here is how to use it to generate more or less the same class as previously: var name = &#39;HelloASM&#39;var superclass = &#39;java/lang/Object&#39;var cw = new ClassWriter(0)cw.visit(V1_8, ACC_PUBLIC + ACC_SUPER, name, null, superclass, null)cw.visitMethod(ACC_PUBLIC + ACC_STATIC, &#39;main&#39;, &#39;([Ljava/lang/String;)V&#39;, null, null).with { visitCode() visitFieldInsn(GETSTATIC, &#39;java/lang/System&#39;, &#39;out&#39;, &#39;Ljava/io/PrintStream;&#39;) visitLdcInsn(&#39;Hello from &#39; + name) visitMethodInsn(INVOKEVIRTUAL, &#39;java/io/PrintStream&#39;, &#39;println&#39;, &#39;(Ljava/lang/String;)V&#39;, false) visitInsn(RETURN) visitMaxs(3, 3) visitEnd()}cw.visitEnd()new File(&quot;${name}.class&quot;).withDataOutputStream { dos -&gt; dos.write(cw.toByteArray())} After running this script, a HelloASM class file is produced, and here is the output when running that class file: $ java HelloASM Hello from HelloASM Parts of the code should look familiar to the previous example. Byte Buddy Byte Buddy is a code generation and manipulation library for creating and modifying Java classes. It&#39;s strengths lie in its ability to create and modify classes dynamically. So, its power is perhaps not needed for our simple example. A nice aspect of this library however, is that it hides some of the low-level details like type and method descriptors behind its fluent API. Here is our example: var name = &#39;HelloByteBuddy&#39;new ByteBuddy() .subclass(Object) .name(name) .defineMethod(&#39;main&#39;, Void.TYPE, PUBLIC | STATIC) .withParameter(String[]) .intercept(MethodCall.invoke( PrintStream.getMethod(&#39;println&#39;, String)) .onField(System.getField(&#39;out&#39;)) .with(&#39;Hello from &#39; + name)) .make() .saveIn(&#39;.&#39; as File) Like the other scripts, this also produces a class file which we can invoke as shown here: $ java HelloByteBuddy Hello from HelloByteBuddy That wraps up our examples using the three libraries, but we have one more fun alternative to cover! Using Groovy ASTs Groovy is a very extensible language. It provides among other things, a compile-time metaprogramming mechanism called AST Transforms (Abstract Syntax Tree Transformations). This mechanism uses annotations to indicate to the compiler that special processing is required during compilation. A now somewhat outdated AST transform, @Bytecode, experimented with allowing you to write bytecode instructions directly in your Groovy code. Let&#39;s look at using that AST transform here: @CompileStatic @POJOclass HelloAST { @Bytecode static void main(args) { getstatic &#39;java/lang/System.out&#39;, &#39;Ljava/io/PrintStream;&#39; ldc &#39;Hello from HelloAST&#39; invokevirtual &#39;java/io/PrintStream.println&#39;, &#39;(Ljava/lang/String;)V&#39; return }} We are writing directly the instructions that the Java or Groovy compiler (with static compilation enabled) would produce. For this example, we don&#39;t run the script to produce the class file, we just compile it using the Groovy compiler. We definitely don&#39;t recommend relying on the @Bytecode AST transform for any production code but it can be fun to play with. We&#39;ve also used the @CompileStatic and @POJO AST transforms to tell the compiler that we aren&#39;t using any Groovy dynamic features, so that it should write Java-like code whenever possible and avoid calling the Groovy runtime. We can examine the bytecode using javap and indeed it has bytecode similar to that produced by the other libraries: public static void main(java.lang.String...); descriptor: ([Ljava/lang/String;)V flags: (0x0089) ACC_PUBLIC, ACC_STATIC, ACC_VARARGS Code: stack=2, locals=1, args_size=1 0: getstatic #21 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #23 // String Hello from HelloAST 5: invokevirtual #29 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LocalVariableTable: Start Length Slot Name Signature 0 9 0 args Ljava/lang/Object; Because the code is not calling the Groovy runtime, we can invoke it directly without the Groovy jar: $ java HelloAST Hello from HelloAST That wraps up our little tour of bytecode libraries. I hope you have learnt some additional JVM details! Further information Github repo of the above examples A draft JEP for what might become an official API for parsing, generating, and transforming Java class files Social media:&nbsp;@ApacheGroovy @ApacheGroovy@fosstodon.org","headline":"JVM Hello World with Groovy","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/groovy/entry/jvm-hello-world-with-groovy"},"url":"http://localhost:4000/groovy/entry/jvm-hello-world-with-groovy"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">JVM Hello World with Groovy</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-12-22T14:24:07-05:00" itemprop="datePublished">Dec 22, 2022
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Paul King", "login"=>"paulk", "email"=>"paulk@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>For those that haven't seen it yet, the <a href="https://www.javaadvent.com/" target="_blank">JVM Advent</a> <a href="https://twitter.com/JavaAdvent" target="_blank">folks</a> posted a great <a href="https://www.javaadvent.com/2022/12/groovy-and-data-science.html" target="_blank">Groovy and Data Science blog post</a> several days ago as part of the 2022 JVM Advent series. If you have an interest in Data Science, we recommend you check that out before continuing with this post.</p>
<p><a href="https://www.javaadvent.com/2022/12/jvm-hello-world.html" target="_blank">Today's post</a> in the JVM Advent series is looking at the world of bytecode libraries on the JVM. Let's look at creating the same hello world example from that post using <a href="http://groovy-lang.org/index.html" target="_blank">Groovy</a> with the <a href="https://github.com/Guardsquare/proguard-core" target="_blank">ProGuardCORE</a>, <a href="https://asm.ow2.io/" target="_blank">ASM</a>, and <a href="https://bytebuddy.net/" target="_blank">Byte Buddy</a> libraries.</p>
<p>First, we highly recommend you read the previously mentioned <a href="https://www.javaadvent.com/2022/12/jvm-hello-world.html" target="_blank">JVM Advent post</a> first for more background. After all, it's easy to create a simple hello world class file example directly as a Java source file (as that post shows) or as a Groovy source file like this:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">println <span style="color:#6a8759;">'Hello world'<br></span></pre>
<p>The examples shown in this blog post illustrate how you could create the equivalent class file using libraries which let you manipulate the generated bytecode directly. It's a bit of a deep dive if you want to know more about JVM internals and can also be handy for numerous use cases like building tools or&nbsp;modifying Java classes on the fly. I suggest you read the web sites for those libraries if you want further details or additional motivation.</p>
<h3>ProGuardCORE</h3>
<p>The ProGuardCORE library lets you&nbsp;read, analyze, modify, and write Java class files. Here's how we could use it to write a hello world class file:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>name = <span style="color:#6a8759;">'HelloProGuardCORE'<br></span><span style="color:#cc7832;">var </span>superclass = <span style="color:#6a8759;">'java/lang/Object'<br></span><span style="color:#cc7832;">var </span>classBuilder = <span style="color:#cc7832;">new </span>ClassBuilder(<span style="color:#9876aa;font-style:italic;">CLASS_VERSION_1_8</span>, <span style="color:#9876aa;font-style:italic;">PUBLIC</span>, name, superclass).tap <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>addMethod(<span style="color:#9876aa;font-style:italic;">PUBLIC </span>| <span style="color:#9876aa;font-style:italic;">STATIC</span>, <span style="color:#6a8759;">'main'</span>, <span style="color:#6a8759;">'([Ljava/lang/String;)V'</span>, <span style="color:#6897bb;">100</span>, builder -><br>        builder<br>            .getstatic(<span style="color:#6a8759;">'java/lang/System'</span>, <span style="color:#6a8759;">'out'</span>, <span style="color:#6a8759;">'Ljava/io/PrintStream;'</span>)<br>            .ldc(<span style="color:#6a8759;">"Hello from </span>$name<span style="color:#6a8759;">"</span>)<br>            .invokevirtual(<span style="color:#6a8759;">'java/io/PrintStream'</span>, <span style="color:#6a8759;">'println'</span>, <span style="color:#6a8759;">'(Ljava/lang/String;)V'</span>)<br>            .return_()<br>    )<br><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span><span style="color:#cc7832;">new </span>File(<span style="color:#6a8759;">"</span>$<span style="font-weight:bold;">{</span>name<span style="font-weight:bold;">}</span><span style="color:#6a8759;">.class"</span>).withDataOutputStream <span style="font-weight:bold;">{ </span>dos <span style="font-weight:bold;">-><br></span><span style="font-weight:bold;">    </span>classBuilder.<span style="color:#9876aa;">programClass</span>.accept(<span style="color:#cc7832;">new </span>ProgramClassWriter(dos))<br><span style="font-weight:bold;">}<br></span></pre>
<p>This is essentially the "<i>Groovified</i>" version of the example in the JVM Advent blog post. We are using the libraries <code>ClassBuilder</code> class, adding a method, then adding four bytecode statements as the body of the method. If you haven't seen method and type descriptor syntax before, a few parts might seem a little strange but you possibly won't be surprised that it seems to be referencing a <code>System.out.println</code> call and passing it a constant String.</p>
<p>When we run this script, a <code>HelloProGuardCORE</code> class file is produced. We can invoke that class file in the normal way:</p>
<pre>$ java HelloProGuardCORE
Hello from HelloProGuardCORE
</pre>
<p>We encourage you to read the JVM Advent post or the library documentation if you want more details.</p>
<h3>ASM</h3>
<p><a href="https://asm.ow2.io/" target="_blank">ASM</a> is an all purpose Java bytecode manipulation and analysis framework. In fact, it's the one that Groovy uses in its parser and some of its tools. Here is how to use it to generate more or less the same class as previously:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>name = <span style="color:#6a8759;">'HelloASM'<br></span><span style="color:#cc7832;">var </span>superclass = <span style="color:#6a8759;">'java/lang/Object'<br></span><span style="color:#cc7832;">var </span>cw = <span style="color:#cc7832;">new </span>ClassWriter(<span style="color:#6897bb;">0</span>)<br>cw.visit(<span style="color:#9876aa;font-style:italic;">V1_8</span>, <span style="color:#9876aa;font-style:italic;">ACC_PUBLIC </span>+ <span style="color:#9876aa;font-style:italic;">ACC_SUPER</span>, name, <span style="color:#cc7832;">null</span>, superclass, <span style="color:#cc7832;">null</span>)<br>cw.visitMethod(<span style="color:#9876aa;font-style:italic;">ACC_PUBLIC </span>+ <span style="color:#9876aa;font-style:italic;">ACC_STATIC</span>, <span style="color:#6a8759;">'main'</span>, <span style="color:#6a8759;">'([Ljava/lang/String;)V'</span>, <span style="color:#cc7832;">null</span>, <span style="color:#cc7832;">null</span>).with <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>visitCode()<br>    visitFieldInsn(<span style="color:#9876aa;font-style:italic;">GETSTATIC</span>, <span style="color:#6a8759;">'java/lang/System'</span>, <span style="color:#6a8759;">'out'</span>, <span style="color:#6a8759;">'Ljava/io/PrintStream;'</span>)<br>    visitLdcInsn(<span style="color:#6a8759;">'Hello from ' </span>+ name)<br>    visitMethodInsn(<span style="color:#9876aa;font-style:italic;">INVOKEVIRTUAL</span>, <span style="color:#6a8759;">'java/io/PrintStream'</span>, <span style="color:#6a8759;">'println'</span>, <span style="color:#6a8759;">'(Ljava/lang/String;)V'</span>, <span style="color:#cc7832;">false</span>)<br>    visitInsn(<span style="color:#9876aa;font-style:italic;">RETURN</span>)<br>    visitMaxs(<span style="color:#6897bb;">3</span>, <span style="color:#6897bb;">3</span>)<br>    visitEnd()<br><span style="font-weight:bold;">}<br></span>cw.visitEnd()<br><br><span style="color:#cc7832;">new </span>File(<span style="color:#6a8759;">"</span>$<span style="font-weight:bold;">{</span>name<span style="font-weight:bold;">}</span><span style="color:#6a8759;">.class"</span>).withDataOutputStream <span style="font-weight:bold;">{ </span>dos <span style="font-weight:bold;">-><br></span><span style="font-weight:bold;">    </span>dos.write(cw.toByteArray())<br><span style="font-weight:bold;">}<br></span></pre>
<p>After running this script, a <code>HelloASM</code> class file is produced, and here is the output when running that class file:</p>
<pre>$ java HelloASM
Hello from HelloASM
</pre>
<p>Parts of the code should look familiar to the previous example.</p>
<h3>Byte Buddy</h3>
<p><a href="https://bytebuddy.net/" target="_blank">Byte Buddy</a> is a code generation and manipulation library for creating and modifying Java classes. It's strengths lie in its ability to create and modify classes dynamically. So, its power is perhaps not needed for our simple example. A nice aspect of this library however, is that it hides some of the low-level details like type and method descriptors behind its fluent API. Here is our example:<br></p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>name = <span style="color:#6a8759;">'HelloByteBuddy'<br></span><span style="color:#cc7832;">new </span>ByteBuddy()<br>    .subclass(Object)<br>    .name(name)<br>    .defineMethod(<span style="color:#6a8759;">'main'</span>, Void.<span style="color:#9876aa;font-style:italic;">TYPE</span>, <span style="color:#9876aa;font-style:italic;">PUBLIC </span>| <span style="color:#9876aa;font-style:italic;">STATIC</span>)<br>    .withParameter(String[])<br>    .intercept(MethodCall.<span style="color:#9876aa;font-style:italic;">invoke</span>(<br>        PrintStream.getMethod(<span style="color:#6a8759;">'println'</span>, String))<br>        .onField(System.getField(<span style="color:#6a8759;">'out'</span>))<br>        .with(<span style="color:#6a8759;">'Hello from ' </span>+ name))<br>    .make()<br>    .saveIn(<span style="color:#6a8759;">'.' </span><span style="color:#cc7832;">as </span>File)<br></pre>
<p>Like the other scripts, this also produces a class file which we can invoke as shown here:</p>
<pre>$ java HelloByteBuddy
Hello from HelloByteBuddy
</pre>
<p>That wraps up our examples using the three libraries, but we have one more fun<br />
alternative to cover!</p>
<h3>Using Groovy ASTs</h3>
<p>Groovy is a very extensible language. It provides among other things, a compile-time<br />
metaprogramming mechanism called AST Transforms (Abstract Syntax Tree Transformations). This mechanism uses annotations to indicate to the compiler that special processing is required during compilation. A now somewhat outdated AST transform, <a href="https://github.com/melix/groovy-bytecode-ast" target="_blank">@Bytecode</a>, experimented with allowing you to write bytecode instructions directly in your Groovy code. Let's look at using that AST transform here:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#bbb529;">@CompileStatic @POJO<br></span><span style="color:#cc7832;">class </span>HelloAST {<br>    <span style="color:#bbb529;">@Bytecode<br></span><span style="color:#bbb529;">    </span><span style="color:#cc7832;">static void </span>main(args) {<br>        getstatic <span style="color:#6a8759;">'java/lang/System.out'</span>, <span style="color:#6a8759;">'Ljava/io/PrintStream;'<br></span><span style="color:#6a8759;">        </span>ldc <span style="color:#6a8759;">'Hello from HelloAST'<br></span><span style="color:#6a8759;">        </span>invokevirtual <span style="color:#6a8759;">'java/io/PrintStream.println'</span>, <span style="color:#6a8759;">'(Ljava/lang/String;)V'<br></span><span style="color:#6a8759;">        </span><span style="color:#cc7832;">return<br></span><span style="color:#cc7832;">    </span>}<br>}<br></pre>
<p>We are writing directly the instructions that the Java or Groovy compiler (with static compilation enabled) would produce. For this example, we don't run the script to produce the class file, we just compile it using the Groovy compiler.</p>
<p>We definitely don't recommend relying on the <code>@Bytecode</code> AST transform for any production code but it can be fun to play with. We've also used the <code>@CompileStatic</code> and <code>@POJO</code> AST transforms to tell the compiler that we aren't using any Groovy dynamic features, so that it should write Java-like code whenever possible and avoid calling the Groovy runtime.</p>
<p>We can examine the bytecode using javap and indeed it has bytecode similar to that produced by the other libraries:</p>
<pre>  public static void main(java.lang.String...);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0089) ACC_PUBLIC, ACC_STATIC, ACC_VARARGS
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #21                 // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #23                 // String Hello from HelloAST
         5: invokevirtual #29                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  args   Ljava/lang/Object;
</pre>
<p>Because the code is not calling the Groovy runtime, we can invoke it directly without the Groovy jar:</p>
<pre>$ java HelloAST
Hello from HelloAST
</pre>
<p>That wraps up our little tour of bytecode libraries. I hope you have learnt some additional JVM details!</p>
<h3>Further information</h3>
<ul>
<li><a href="https://github.com/paulk-asert/bytecode-fun" target="_blank">Github repo</a> of the above examples</li>
<li>A <a href="https://openjdk.org/jeps/8280389" target="_blank">draft JEP</a> for what might become an official API for parsing, generating, and transforming Java class files</li>
<li>Social media:&nbsp;<a href="https://twitter.com/ApacheGroovy" target="_blank">@ApacheGroovy</a> <a href="https://fosstodon.org/@ApacheGroovy" target="_blank">@ApacheGroovy@fosstodon.org</a></li>
</ul>

  </div><a class="u-url" href="/groovy/entry/jvm-hello-world-with-groovy" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
