<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Detecting objects with Groovy, the Deep Java Library (DJL), and Apache MXNet | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Detecting objects with Groovy, the Deep Java Library (DJL), and Apache MXNet" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This blog posts looks at using Apache Groovy with the Deep Java Library (DJL) and backed by the Apache MXNet engine to detect objects within an image. (Apache MXNet is an incubating project at the ASF.) Deep Learning Deep learning falls under the branches of machine learning and artificial intelligence. It involves multiple layers (hence the &quot;deep&quot;) of an artificial neural network. There are lots of ways to configure such networks and the details are beyond the scope of this blog post, but we can give some basic details. We will have four input nodes corresponding to the measurements of our four characteristics. We will have three output nodes corresponding to each possible class (species). We will also have one or more additional layers in between. Each node in this network mimics to some degree a neuron in the human brain. Again, we&#39;ll simplify the details. Each node has multiple inputs, which are given a particular weight, as well as an activation function which will determine whether our node &quot;fires&quot;. Training the model is a process which works out what the best weights should be. Deep Java Library (DJL) &amp; Apache MXNet Rather than writing your own neural networks, libraries such as DJL provide high-level abstractions which automate to some degree the creation of the necessary neural network layers. DJL is engine agnostic, so it&#39;s capable of supporting different backends including Apache MXNet, PyTorch, TensorFlow and ONNX Runtime. We&#39;ll use the default engine which for our application (at the time of writing) is Apache MXNet. Apache MXNet provides the underlying engine. It has support for imperative and symbolic execution, distributed training of your models using multi-gpu or multi-host hardware, and multiple language bindings. Groovy is fully compatible with the Java binding. Using DJL with Groovy Groovy uses the Java binding. Consider looking at the DJL beginner tutorials for Java - they will work almost unchanged for Groovy. For our example, the first thing we need to do is download the image we want to run the object detection model on: Path tempDir = Files.createTempDirectory(&quot;resnetssd&quot;)def imageName = &#39;dog-ssd.jpg&#39;Path localImage = tempDir.resolve(imageName)def url = new URL(&quot;https://s3.amazonaws.com/model-server/inputs/$imageName&quot;)DownloadUtils.download(url, localImage, new ProgressBar())Image img = ImageFactory.instance.fromFile(localImage) It happens to be a well-known already available image. We&#39;ll store a local copy of the image in a temporary directory and we&#39;ll use a utility class that comes with DJL to provide a nice progress bar while the image is downloading. DJL provides it&#39;s own image classes, so we&#39;ll create an instance using the appropriate class from the downloaded image. Next we want to configure our neural network layers: def criteria = Criteria.builder() .optApplication(Application.CV.OBJECT_DETECTION) .setTypes(Image, DetectedObjects) .optFilter(&quot;backbone&quot;, &quot;resnet50&quot;) .optEngine(Engine.defaultEngineName) .optProgress(new ProgressBar()) .build() DLJ supports numerous model applications including image classification, word recognition, sentiment analysis, linear regression, and others. We&#39;ll select object detection. This kind of application looks for the bounding box of known objects within an image. The types configuration option identifies that our input will be an image and the output will be detected objects. The filter option indicates that we will be using ResNet-50 (a 50-layers deep convolutional neural network often used as a backbone for many computer vision tasks). We set the engine to be the default engine which happens to be Apache MXNet. We also configure an optional progress bar to provide feedback of progress while our model is running. Now that we have our configuration sorted, we&#39;ll use it to load a model and then use the model to make object predictions: def detection = criteria.loadModel().withCloseable { model -&gt; model.newPredictor().predict(img)}detection.items().each { println it }img.drawBoundingBoxes(detection) For good measure, we&#39;ll draw the bounding boxes into our image. Next, we save our image into a file and display it using Groovy&#39;s SwingBuilder. Path imageSaved = tempDir.resolve(&#39;detected.png&#39;)imageSaved.withOutputStream { os -&gt; img.save(os, &#39;png&#39;) }def saved = ImageIO.read(imageSaved.toFile())new SwingBuilder().edt { frame(title: &quot;$detection.numberOfObjects detected objects&quot;, size: [saved.width, saved.height], defaultCloseOperation: DISPOSE_ON_CLOSE, show: true) { label(icon: imageIcon(image: saved)) }} Building and running our application Our code is stored on a source file called ObjectDetect.groovy. We used Gradle for our build file: apply plugin: &#39;groovy&#39;apply plugin: &#39;application&#39;repositories { mavenCentral()}application { mainClass = &#39;ObjectDetect&#39;}dependencies { implementation &quot;ai.djl:api:0.18.0&quot; implementation &quot;org.apache.groovy:groovy:4.0.4&quot; implementation &quot;org.apache.groovy:groovy-swing:4.0.4&quot; runtimeOnly &quot;ai.djl:model-zoo:0.18.0&quot; runtimeOnly &quot;ai.djl.mxnet:mxnet-engine:0.18.0&quot; runtimeOnly &quot;ai.djl.mxnet:mxnet-model-zoo:0.18.0&quot; runtimeOnly &quot;ai.djl.mxnet:mxnet-native-auto:1.8.0&quot; runtimeOnly &quot;org.apache.groovy:groovy-nio:4.0.4&quot; runtimeOnly &quot;org.slf4j:slf4j-jdk14:1.7.36&quot;} We run the application with the gradle run task: paulk@pop-os:/extra/projects/groovy-data-science$ ./gradlew DLMXNet:run &gt; Task :DeepLearningMxnet:run Downloading: 100% |████████████████████████████████████████| dog-ssd.jpg Loading: 100% |████████████████████████████████████████| ... class: &quot;car&quot;, probability: 0.99991, bounds: [x=0.611, y=0.137, width=0.293, height=0.160] class: &quot;bicycle&quot;, probability: 0.95385, bounds: [x=0.162, y=0.207, width=0.594, height=0.588] class: &quot;dog&quot;, probability: 0.93752, bounds: [x=0.168, y=0.350, width=0.274, height=0.593] The displayed image looks like this: Further Information The full source code can be found in the following repo:https://github.com/paulk-asert/groovy-data-science/subprojects/DeepLearningMxnet Conclusion We have examined using Apache Groovy, DLJ and Apache MXNet to detect objects within an image. We&#39;ve used a model based on a rich deep learning model but we didn&#39;t need to get into the details of the model or its neural network layers. DLJ and Apache MXNet did the hard lifting for us. Groovy provided a simple coding experience for building our application." />
<meta property="og:description" content="This blog posts looks at using Apache Groovy with the Deep Java Library (DJL) and backed by the Apache MXNet engine to detect objects within an image. (Apache MXNet is an incubating project at the ASF.) Deep Learning Deep learning falls under the branches of machine learning and artificial intelligence. It involves multiple layers (hence the &quot;deep&quot;) of an artificial neural network. There are lots of ways to configure such networks and the details are beyond the scope of this blog post, but we can give some basic details. We will have four input nodes corresponding to the measurements of our four characteristics. We will have three output nodes corresponding to each possible class (species). We will also have one or more additional layers in between. Each node in this network mimics to some degree a neuron in the human brain. Again, we&#39;ll simplify the details. Each node has multiple inputs, which are given a particular weight, as well as an activation function which will determine whether our node &quot;fires&quot;. Training the model is a process which works out what the best weights should be. Deep Java Library (DJL) &amp; Apache MXNet Rather than writing your own neural networks, libraries such as DJL provide high-level abstractions which automate to some degree the creation of the necessary neural network layers. DJL is engine agnostic, so it&#39;s capable of supporting different backends including Apache MXNet, PyTorch, TensorFlow and ONNX Runtime. We&#39;ll use the default engine which for our application (at the time of writing) is Apache MXNet. Apache MXNet provides the underlying engine. It has support for imperative and symbolic execution, distributed training of your models using multi-gpu or multi-host hardware, and multiple language bindings. Groovy is fully compatible with the Java binding. Using DJL with Groovy Groovy uses the Java binding. Consider looking at the DJL beginner tutorials for Java - they will work almost unchanged for Groovy. For our example, the first thing we need to do is download the image we want to run the object detection model on: Path tempDir = Files.createTempDirectory(&quot;resnetssd&quot;)def imageName = &#39;dog-ssd.jpg&#39;Path localImage = tempDir.resolve(imageName)def url = new URL(&quot;https://s3.amazonaws.com/model-server/inputs/$imageName&quot;)DownloadUtils.download(url, localImage, new ProgressBar())Image img = ImageFactory.instance.fromFile(localImage) It happens to be a well-known already available image. We&#39;ll store a local copy of the image in a temporary directory and we&#39;ll use a utility class that comes with DJL to provide a nice progress bar while the image is downloading. DJL provides it&#39;s own image classes, so we&#39;ll create an instance using the appropriate class from the downloaded image. Next we want to configure our neural network layers: def criteria = Criteria.builder() .optApplication(Application.CV.OBJECT_DETECTION) .setTypes(Image, DetectedObjects) .optFilter(&quot;backbone&quot;, &quot;resnet50&quot;) .optEngine(Engine.defaultEngineName) .optProgress(new ProgressBar()) .build() DLJ supports numerous model applications including image classification, word recognition, sentiment analysis, linear regression, and others. We&#39;ll select object detection. This kind of application looks for the bounding box of known objects within an image. The types configuration option identifies that our input will be an image and the output will be detected objects. The filter option indicates that we will be using ResNet-50 (a 50-layers deep convolutional neural network often used as a backbone for many computer vision tasks). We set the engine to be the default engine which happens to be Apache MXNet. We also configure an optional progress bar to provide feedback of progress while our model is running. Now that we have our configuration sorted, we&#39;ll use it to load a model and then use the model to make object predictions: def detection = criteria.loadModel().withCloseable { model -&gt; model.newPredictor().predict(img)}detection.items().each { println it }img.drawBoundingBoxes(detection) For good measure, we&#39;ll draw the bounding boxes into our image. Next, we save our image into a file and display it using Groovy&#39;s SwingBuilder. Path imageSaved = tempDir.resolve(&#39;detected.png&#39;)imageSaved.withOutputStream { os -&gt; img.save(os, &#39;png&#39;) }def saved = ImageIO.read(imageSaved.toFile())new SwingBuilder().edt { frame(title: &quot;$detection.numberOfObjects detected objects&quot;, size: [saved.width, saved.height], defaultCloseOperation: DISPOSE_ON_CLOSE, show: true) { label(icon: imageIcon(image: saved)) }} Building and running our application Our code is stored on a source file called ObjectDetect.groovy. We used Gradle for our build file: apply plugin: &#39;groovy&#39;apply plugin: &#39;application&#39;repositories { mavenCentral()}application { mainClass = &#39;ObjectDetect&#39;}dependencies { implementation &quot;ai.djl:api:0.18.0&quot; implementation &quot;org.apache.groovy:groovy:4.0.4&quot; implementation &quot;org.apache.groovy:groovy-swing:4.0.4&quot; runtimeOnly &quot;ai.djl:model-zoo:0.18.0&quot; runtimeOnly &quot;ai.djl.mxnet:mxnet-engine:0.18.0&quot; runtimeOnly &quot;ai.djl.mxnet:mxnet-model-zoo:0.18.0&quot; runtimeOnly &quot;ai.djl.mxnet:mxnet-native-auto:1.8.0&quot; runtimeOnly &quot;org.apache.groovy:groovy-nio:4.0.4&quot; runtimeOnly &quot;org.slf4j:slf4j-jdk14:1.7.36&quot;} We run the application with the gradle run task: paulk@pop-os:/extra/projects/groovy-data-science$ ./gradlew DLMXNet:run &gt; Task :DeepLearningMxnet:run Downloading: 100% |████████████████████████████████████████| dog-ssd.jpg Loading: 100% |████████████████████████████████████████| ... class: &quot;car&quot;, probability: 0.99991, bounds: [x=0.611, y=0.137, width=0.293, height=0.160] class: &quot;bicycle&quot;, probability: 0.95385, bounds: [x=0.162, y=0.207, width=0.594, height=0.588] class: &quot;dog&quot;, probability: 0.93752, bounds: [x=0.168, y=0.350, width=0.274, height=0.593] The displayed image looks like this: Further Information The full source code can be found in the following repo:https://github.com/paulk-asert/groovy-data-science/subprojects/DeepLearningMxnet Conclusion We have examined using Apache Groovy, DLJ and Apache MXNet to detect objects within an image. We&#39;ve used a model based on a rich deep learning model but we didn&#39;t need to get into the details of the model or its neural network layers. DLJ and Apache MXNet did the hard lifting for us. Groovy provided a simple coding experience for building our application." />
<link rel="canonical" href="http://localhost:4000/groovy/entry/detecting-objects-with-groovy-the" />
<meta property="og:url" content="http://localhost:4000/groovy/entry/detecting-objects-with-groovy-the" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-08-01T11:52:26-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Detecting objects with Groovy, the Deep Java Library (DJL), and Apache MXNet" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-08-01T11:52:26-04:00","datePublished":"2022-08-01T11:52:26-04:00","description":"This blog posts looks at using Apache Groovy with the Deep Java Library (DJL) and backed by the Apache MXNet engine to detect objects within an image. (Apache MXNet is an incubating project at the ASF.) Deep Learning Deep learning falls under the branches of machine learning and artificial intelligence. It involves multiple layers (hence the &quot;deep&quot;) of an artificial neural network. There are lots of ways to configure such networks and the details are beyond the scope of this blog post, but we can give some basic details. We will have four input nodes corresponding to the measurements of our four characteristics. We will have three output nodes corresponding to each possible class (species). We will also have one or more additional layers in between. Each node in this network mimics to some degree a neuron in the human brain. Again, we&#39;ll simplify the details. Each node has multiple inputs, which are given a particular weight, as well as an activation function which will determine whether our node &quot;fires&quot;. Training the model is a process which works out what the best weights should be. Deep Java Library (DJL) &amp; Apache MXNet Rather than writing your own neural networks, libraries such as DJL provide high-level abstractions which automate to some degree the creation of the necessary neural network layers. DJL is engine agnostic, so it&#39;s capable of supporting different backends including Apache MXNet, PyTorch, TensorFlow and ONNX Runtime. We&#39;ll use the default engine which for our application (at the time of writing) is Apache MXNet. Apache MXNet provides the underlying engine. It has support for imperative and symbolic execution, distributed training of your models using multi-gpu or multi-host hardware, and multiple language bindings. Groovy is fully compatible with the Java binding. Using DJL with Groovy Groovy uses the Java binding. Consider looking at the DJL beginner tutorials for Java - they will work almost unchanged for Groovy. For our example, the first thing we need to do is download the image we want to run the object detection model on: Path tempDir = Files.createTempDirectory(&quot;resnetssd&quot;)def imageName = &#39;dog-ssd.jpg&#39;Path localImage = tempDir.resolve(imageName)def url = new URL(&quot;https://s3.amazonaws.com/model-server/inputs/$imageName&quot;)DownloadUtils.download(url, localImage, new ProgressBar())Image img = ImageFactory.instance.fromFile(localImage) It happens to be a well-known already available image. We&#39;ll store a local copy of the image in a temporary directory and we&#39;ll use a utility class that comes with DJL to provide a nice progress bar while the image is downloading. DJL provides it&#39;s own image classes, so we&#39;ll create an instance using the appropriate class from the downloaded image. Next we want to configure our neural network layers: def criteria = Criteria.builder() .optApplication(Application.CV.OBJECT_DETECTION) .setTypes(Image, DetectedObjects) .optFilter(&quot;backbone&quot;, &quot;resnet50&quot;) .optEngine(Engine.defaultEngineName) .optProgress(new ProgressBar()) .build() DLJ supports numerous model applications including image classification, word recognition, sentiment analysis, linear regression, and others. We&#39;ll select object detection. This kind of application looks for the bounding box of known objects within an image. The types configuration option identifies that our input will be an image and the output will be detected objects. The filter option indicates that we will be using ResNet-50 (a 50-layers deep convolutional neural network often used as a backbone for many computer vision tasks). We set the engine to be the default engine which happens to be Apache MXNet. We also configure an optional progress bar to provide feedback of progress while our model is running. Now that we have our configuration sorted, we&#39;ll use it to load a model and then use the model to make object predictions: def detection = criteria.loadModel().withCloseable { model -&gt; model.newPredictor().predict(img)}detection.items().each { println it }img.drawBoundingBoxes(detection) For good measure, we&#39;ll draw the bounding boxes into our image. Next, we save our image into a file and display it using Groovy&#39;s SwingBuilder. Path imageSaved = tempDir.resolve(&#39;detected.png&#39;)imageSaved.withOutputStream { os -&gt; img.save(os, &#39;png&#39;) }def saved = ImageIO.read(imageSaved.toFile())new SwingBuilder().edt { frame(title: &quot;$detection.numberOfObjects detected objects&quot;, size: [saved.width, saved.height], defaultCloseOperation: DISPOSE_ON_CLOSE, show: true) { label(icon: imageIcon(image: saved)) }} Building and running our application Our code is stored on a source file called ObjectDetect.groovy. We used Gradle for our build file: apply plugin: &#39;groovy&#39;apply plugin: &#39;application&#39;repositories { mavenCentral()}application { mainClass = &#39;ObjectDetect&#39;}dependencies { implementation &quot;ai.djl:api:0.18.0&quot; implementation &quot;org.apache.groovy:groovy:4.0.4&quot; implementation &quot;org.apache.groovy:groovy-swing:4.0.4&quot; runtimeOnly &quot;ai.djl:model-zoo:0.18.0&quot; runtimeOnly &quot;ai.djl.mxnet:mxnet-engine:0.18.0&quot; runtimeOnly &quot;ai.djl.mxnet:mxnet-model-zoo:0.18.0&quot; runtimeOnly &quot;ai.djl.mxnet:mxnet-native-auto:1.8.0&quot; runtimeOnly &quot;org.apache.groovy:groovy-nio:4.0.4&quot; runtimeOnly &quot;org.slf4j:slf4j-jdk14:1.7.36&quot;} We run the application with the gradle run task: paulk@pop-os:/extra/projects/groovy-data-science$ ./gradlew DLMXNet:run &gt; Task :DeepLearningMxnet:run Downloading: 100% |████████████████████████████████████████| dog-ssd.jpg Loading: 100% |████████████████████████████████████████| ... class: &quot;car&quot;, probability: 0.99991, bounds: [x=0.611, y=0.137, width=0.293, height=0.160] class: &quot;bicycle&quot;, probability: 0.95385, bounds: [x=0.162, y=0.207, width=0.594, height=0.588] class: &quot;dog&quot;, probability: 0.93752, bounds: [x=0.168, y=0.350, width=0.274, height=0.593] The displayed image looks like this: Further Information The full source code can be found in the following repo:https://github.com/paulk-asert/groovy-data-science/subprojects/DeepLearningMxnet Conclusion We have examined using Apache Groovy, DLJ and Apache MXNet to detect objects within an image. We&#39;ve used a model based on a rich deep learning model but we didn&#39;t need to get into the details of the model or its neural network layers. DLJ and Apache MXNet did the hard lifting for us. Groovy provided a simple coding experience for building our application.","headline":"Detecting objects with Groovy, the Deep Java Library (DJL), and Apache MXNet","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/groovy/entry/detecting-objects-with-groovy-the"},"url":"http://localhost:4000/groovy/entry/detecting-objects-with-groovy-the"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Detecting objects with Groovy, the Deep Java Library (DJL), and Apache MXNet</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-08-01T11:52:26-04:00" itemprop="datePublished">Aug 1, 2022
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Paul King", "login"=>"paulk", "email"=>"paulk@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This blog posts looks at using <a href="https://groovy-lang.org/" target="_blank">Apache Groovy</a> with the <a href="https://djl.ai/" target="_blank">Deep Java Library (DJL)</a> and backed by the <a href="https://mxnet.incubator.apache.org/" target="_blank">Apache MXNet</a> engine to detect objects within an image. (Apache MXNet is an <a href="https://incubator.apache.org/" target="_blank">incubating project</a> at <a href="https://www.apache.org/" target="_blank">the ASF</a>.)</p>
<h3>Deep Learning</h3>
<p>Deep learning falls under the branches of <a href="https://en.wikipedia.org/wiki/Machine_learning" target="_blank">machine learning</a> and <a href="https://en.wikipedia.org/wiki/Artificial_intelligence" target="_blank">artificial intelligence</a>. It involves multiple layers (hence the "deep") of an <a href="https://en.wikipedia.org/wiki/Artificial_neural_network" target="_blank">artificial neural network</a>. There are lots of ways to configure such networks and the details are beyond the scope of this blog post, but we can give some basic details. We will have four input nodes corresponding to the measurements of our four characteristics. We will have three output nodes corresponding to each possible <i>class </i>(<i>species</i>). We will also have one or more additional layers in between.</p>
<p><a href="https://blogs.apache.org/groovy/mediaresource/2206eccb-0c50-4091-a030-e3057517d810"><img src="https://blogs.apache.org/groovy/mediaresource/2206eccb-0c50-4091-a030-e3057517d810" style="width: 50%;" alt="deep_network.png"></a></p>
<p>Each node in this network mimics to some degree a neuron in the human brain. Again, we'll simplify the details. Each node has multiple inputs, which are given a particular weight, as well as an activation function which will determine whether our node "fires". Training the model is a process which works out what the best weights should be.</p>
<p><a href="https://blogs.apache.org/groovy/mediaresource/b5d32431-a273-481d-b0b5-169b0665b385"><img src="https://blogs.apache.org/groovy/mediaresource/b5d32431-a273-481d-b0b5-169b0665b385" style="width: 50%;" alt="deep_node.png"></a></p>
<h3>Deep Java Library (DJL) &amp; Apache MXNet</h3>
<p>Rather than writing your own neural networks, libraries such as <a href="https://djl.ai/" target="_blank">DJL</a> provide high-level abstractions which automate to some degree the creation of the necessary neural network layers. DJL is engine agnostic, so it's capable of supporting different backends including Apache MXNet, PyTorch, TensorFlow and ONNX Runtime. We'll use the default engine which for our application (at the time of writing) is Apache MXNet.</p>
<p><a href="https://mxnet.apache.org/" target="_blank">Apache MXNet</a> provides the underlying engine. It has support for imperative and symbolic execution, distributed training of your models using multi-gpu or multi-host hardware, and multiple language bindings. Groovy is fully compatible with the Java binding.</p>
<h3>Using DJL with Groovy</h3>
<p>Groovy uses the Java binding. Consider looking at the DJL beginner tutorials for Java - they will work almost unchanged for Groovy.</p>
<p>For our example, the first thing we need to do is download the image we want to run the object detection model on:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">Path tempDir = Files.<span style="color:#9876aa;font-style:italic;">createTempDirectory</span>(<span style="color:#6a8759;">"resnetssd"</span>)<br><span style="color:#cc7832;">def </span>imageName = <span style="color:#6a8759;">'dog-ssd.jpg'<br></span>Path localImage = tempDir.resolve(imageName)<br><span style="color:#cc7832;">def </span>url = <span style="color:#cc7832;">new </span>URL(<span style="color:#6a8759;">"https://s3.amazonaws.com/model-server/inputs/</span>$imageName<span style="color:#6a8759;">"</span>)<br>DownloadUtils.<span style="color:#9876aa;font-style:italic;">download</span>(url, localImage, <span style="color:#cc7832;">new </span>ProgressBar())<br>Image img = ImageFactory.<span style="color:#9876aa;font-style:italic;">instance</span>.fromFile(localImage)<br></pre>
<p>It happens to be a well-known already available image. We'll store a local copy of the image in a temporary directory and we'll use a utility class that comes with DJL to provide a nice progress bar while the image is downloading. DJL provides it's own image classes, so we'll create an instance using the appropriate class from the downloaded image.</p>
<p>Next we want to configure our neural network layers:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>criteria = Criteria.<span style="color:#9876aa;font-style:italic;">builder</span>()<br>        .optApplication(Application.CV.<span style="color:#9876aa;font-style:italic;">OBJECT_DETECTION</span>)<br>        .setTypes(Image, DetectedObjects)<br>        .optFilter(<span style="color:#6a8759;">"backbone"</span>, <span style="color:#6a8759;">"resnet50"</span>)<br>        .optEngine(Engine.<span style="color:#9876aa;font-style:italic;">defaultEngineName</span>)<br>        .optProgress(<span style="color:#cc7832;">new </span>ProgressBar())<br>        .build()<br></pre>
<p>DLJ supports numerous model <i>applications</i> including image classification, word recognition, sentiment analysis, linear regression, and others. We'll select <i>object detection</i>. This kind of application looks for the bounding box of known objects within an image. The <i>types</i> configuration option identifies that our input will be an image and the output will be detected objects. The <i>filter</i> option indicates that we will be using ResNet-50 (a 50-layers deep convolutional neural network often used as a backbone for many computer vision tasks). We set the <i>engine</i> to be the default engine which happens to be Apache MXNet. We also configure an optional progress bar to provide feedback of progress while our model is running.</p>
<p>Now that we have our configuration sorted, we'll use it to load a model and then use the model to make object predictions:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>detection = criteria.loadModel().withCloseable <span style="font-weight:bold;">{ </span>model <span style="font-weight:bold;">-><br></span><span style="font-weight:bold;">    </span>model.newPredictor().predict(img)<br><span style="font-weight:bold;">}<br></span>detection.items().each <span style="font-weight:bold;">{ </span>println it <span style="font-weight:bold;">}<br></span>img.drawBoundingBoxes(detection)<br></pre>
<p>For good measure, we'll draw the bounding boxes into our image.</p>
<p>Next, we save our image into a file and display it using Groovy's SwingBuilder.</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">Path imageSaved = tempDir.resolve(<span style="color:#6a8759;">'detected.png'</span>)<br>imageSaved.withOutputStream <span style="font-weight:bold;">{ </span>os <span style="font-weight:bold;">-> </span>img.save(os, <span style="color:#6a8759;">'png'</span>) <span style="font-weight:bold;">}<br></span><span style="color:#cc7832;">def </span>saved = ImageIO.<span style="color:#9876aa;font-style:italic;">read</span>(imageSaved.toFile())<br><span style="color:#cc7832;">new </span>SwingBuilder().edt <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>frame(<span style="color:#6a8759;">title</span>: <span style="color:#6a8759;">"</span>$detection.<span style="color:#9876aa;">numberOfObjects</span><span style="color:#6a8759;"> detected objects"</span>,<br>            <span style="color:#6a8759;">size</span>: [saved.<span style="color:#9876aa;">width</span>, saved.<span style="color:#9876aa;">height</span>],<br>            <span style="color:#6a8759;">defaultCloseOperation</span>: <span style="color:#9876aa;font-style:italic;">DISPOSE_ON_CLOSE</span>,<br>            <span style="color:#6a8759;">show</span>: <span style="color:#cc7832;">true</span>) <span style="font-weight:bold;">{ </span>label(<span style="color:#6a8759;">icon</span>: imageIcon(<span style="color:#6a8759;">image</span>: saved)) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">}<br></span></pre>
<p><span style="color: inherit; font-family: inherit; font-size: 24px;">Building and running our application</span><br></p>
<p>Our code is stored on a source file called <code>ObjectDetect.groovy</code>.</p>
<p>We used <a href="https://gradle.org/" target="_blank">Gradle</a> for our build file:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">apply <span style="color:#6a8759;">plugin</span>: <span style="color:#6a8759;">'groovy'<br></span>apply <span style="color:#6a8759;">plugin</span>: <span style="color:#6a8759;">'application'<br></span><span style="color:#6a8759;"><br></span>repositories <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>mavenCentral()<br><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span>application <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>mainClass = <span style="color:#6a8759;">'ObjectDetect'</span><br><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span>dependencies <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>implementation <span style="color:#6a8759;">"ai.djl:api:0.18.0</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>implementation <span style="color:#6a8759;">"org.apache.groovy:groovy:4.0.4</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>implementation <span style="color:#6a8759;">"org.apache.groovy:groovy-swing:4.0.4</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>runtimeOnly <span style="color:#6a8759;">"ai.djl:model-zoo:0.18.0</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>runtimeOnly <span style="color:#6a8759;">"ai.djl.mxnet:mxnet-engine:0.18.0</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>runtimeOnly <span style="color:#6a8759;">"ai.djl.mxnet:mxnet-model-zoo:0.18.0</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>runtimeOnly <span style="color:#6a8759;">"ai.djl.mxnet:mxnet-native-auto:1.8.0"<br></span><span style="color:#6a8759;">    </span>runtimeOnly <span style="color:#6a8759;">"org.apache.groovy:groovy-nio:4.0.4</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>runtimeOnly <span style="color:#6a8759;">"org.slf4j:slf4j-jdk14:1.7.36</span><span style="color:#6a8759;">"<br></span><span style="font-weight:bold;">}</span></pre>
<p>We run the application with the gradle run task:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;"><span style="color:#4E9A06"><b>paulk@pop-os</b></span>:<span style="color:#3465A4"><b>/extra/projects/groovy-data-science</b></span>$ ./gradlew DLMXNet:run
<b>> Task :DeepLearningMxnet:run</b>
Downloading: 100% |████████████████████████████████████████| dog-ssd.jpg
Loading:     100% |████████████████████████████████████████|
...
class: "car", probability: 0.99991, bounds: [x=0.611, y=0.137, width=0.293, height=0.160]
class: "bicycle", probability: 0.95385, bounds: [x=0.162, y=0.207, width=0.594, height=0.588]
class: "dog", probability: 0.93752, bounds: [x=0.168, y=0.350, width=0.274, height=0.593]
</pre>
<p>The displayed image looks like this:<br><img src="https://blogs.apache.org/groovy/mediaresource/b92cafbe-1866-4335-9c91-c3371253887e" style="width:50%;" alt="2022-08-01 21_28_33-3 detected objects.png"><br></p>
<h3>Further Information</h3>
<p>The full source code can be found in the following repo:<br><a href="https://github.com/paulk-asert/groovy-data-science/tree/master/subprojects/DeepLearningMxnet" target="_blank">https://github.com/paulk-asert/groovy-data-science/subprojects/DeepLearningMxnet</a><a href="https://github.com/paulk-asert/groovy-data-science/tree/master/subprojects/DeepLearningMxnet" target="_blank"></a><br></p>
<h3>Conclusion</h3>
<p>We have examined using Apache Groovy, DLJ and Apache MXNet to detect objects within an image. We've used a model based on a rich deep learning model but we didn't need to get into the details of the model or its neural network layers. DLJ and Apache MXNet did the hard lifting for us. Groovy provided a simple coding experience for building our application.</p>

  </div><a class="u-url" href="/groovy/entry/detecting-objects-with-groovy-the" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
