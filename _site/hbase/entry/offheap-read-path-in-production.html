<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Offheap Read-Path in Production - The Alibaba story | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Offheap Read-Path in Production - The Alibaba story" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="By Yu Li (HBase Committer/Alibaba), Yu Sun (Alibaba), Anoop Sam John (HBase PMC/Intel), and Ramkrishna S Vasudevan (HBase PMC/Intel) &lt;/p&gt; Introduction HBase is the core storage system in Alibaba&rsquo;s Search Infrastructure. Critical e-commerce data about products, sellers and promotions etc. are all synced into HBase from various online databases. We query HBase to build and provide real time updates on the search index. In addition, user behavior data, such as impressions, clicks and transactions will also be streamed into HBase. They serve as feature data for our online machine learning system, which optimizes the personalized search result in real time. The whole system produces mixed workloads on HBase that includes bulkload/snapshot for full index building, batch mutation for real time index updates and streaming/continuous query for online machine learning. Our biggest HBase cluster has reached more than 1500 nodes and 200,000 regions. It routinely serves tens of millions QPS. Both latency and throughput are important for our HBase deploy. From the latency perspective, it directly affects how quickly users can search an item after it has been posted as well as how &lsquo;real-time&rsquo; we can run our inventory accounting. From the throughput perspective, it decides the speed of machine learning program processing, and thus the accuracy of recommendations made. What&rsquo;s more, since data is distributed through the cluster and accesses are balanced, applications are sensitive to latency spikes on a single node, which makes GC a critical factor in our system servicing capability. By caching more data in memory, the read latency (and throughput) can be greatly improved. If we can get our data from local cache, we save having to make a trip to HDFS. Apache HBase has two layers of data caching. There is what we call &ldquo;L1&rdquo; caching, our first caching tier &ndash; which caches data in an on heap Least Recently Used (LRU) cache -- and then there is an optional, &ldquo;L2&rdquo; second cache tier (aka Bucket Cache). Bucket Cache can be configured to keep its data in a file -- i.e. caching data in a local file on disk -- or in memory. File mode usually is able to cache more data but there will be more attendant latency reading from a file vs reading from memory. Bucket Cache can also be configured to use memory outside of the Java heap space (&lsquo;offheap&rsquo;) so users generally configurea a large L2 cache with offheap memory along with a smaller on heap L1 cache. At Alibaba we use an offheap L2 cache dedicating 12GB to Bucket Cache on each node. We also backported a patch currently in master branch only (to be shipped in the coming hbase-2.0.0) which makes it so the hbase read path runs offheap end-to-end. This combination improved our average throughput significantly. In the below sections, we&rsquo;ll first talk about why the off-heaping has to be end-to-end, then introduce how we back ported the feature from master branch to our customized 1.1.2, and at last show the performance with end-to-end read-path offheap in an A/B test and on Singles&rsquo; Day (11/11/2016). Necessity of End-to-end Off-heaping Before offheap, the QPS curve looked like below from our A/B test cluster We could see that there were dips in average throughput. Concurrently, the average latency would be high during these times. Checking RegionServer logs, we could see that there were long GC pauses happening. Further analysis indicated that when disk IO is fast enough, as on PCIe-SSD, blocks would be evicted from cache quite frequently even when there was a high cache hit ratio. The eviction rate was so high that the GC speed couldn&rsquo;t keep up bringing on frequent long GC pauses impacting throughput. Looking to improve throughput, we tried the existing Bucket Cache in 1.1.2 but found GC was still heavy. In other words, although Bucket Cache in branch-1 (branch for current stable releases) already supports using offheap memory for Bucket Cache, it tends to generate lots of garbages. To understand why end-to-end off-heaping is necessary, let&rsquo;s see how reads from Bucket cache work in branch-1. But before we do this, lets understand how bucket cache itself has been organized. The allocated offheap memory is reserved as DirectByteBuffers, each of size 4 MB. So we can say that physically the entire memory area is split into many buffers each of size 4 MB. &nbsp;Now on top of this physical layout, we impose a logical division. Each logical area is sized to accommodate different sized HFile blocks (Remember reads of HFiles happen as blocks and block by block it will get cached in L1 or L2 cache). Each logical split accommodates different sized HFile blocks from 4 KB to 512 KB (This is the default. Sizes are configurable). In each of the splits, there will be more that one slot into which we can insert a block. When caching, we find an appropriately sized split and then an empty slot within it and here we insert the block. Remember all slots are offheap. For more details on Bucket cache, refer here [4]. Refer to the HBase Reference Guide [5] for how to setup Bucket Cache. In branch-1, when the read happens out of an L2 cache, we will have to copy the entire block into a temporary onheap area. This is because the HBase read path assumes block data is backed by an onheap byte array. &nbsp;Also as per the above mentioned physical and logical split, there is a chance that one HFile block data is spread across 2 physical ByteBuffers. When a random row read happens in our system, even if the data is available in L2 cache, we will end up reading the entire block -- usually ~64k in size -- into a temporary onheap allocation for every row read. This creates lots of garbage (and please note that without the HBASE-14463 fix, this copy from offheap to onheap reduced read performance a lot). Our read workload is so high that this copy produces lots of GCs, so we had to find a way to avoid the need of copying block data from offheap cache into temp onheap arrays. How was it achieved? - Our Story The HBASE-11425 Cell/DBB end-to-end on the read-path work in the master branch, avoids the need to copy offheap block data back to onheap when reading. The entire read path is changed to work directly off the offheap Bucket Cache area and serve data directly from here to clients (see the details of this work and performance improvement details here [1], and [2]). So we decided to try this project in our custom HBase version based on 1.1.2 backporting it from the master branch. The backport cost us about 2 people months, including getting familiar with and analysis of the JIRAs to port, fix UT failures, fixing problems found in functional testing (HBASE-16609/16704), and resolving compatibility issues (HBASE-16626). We have listed the full to-back-port JIRA list here [3] and please refer to it for more details if interested. About configurations, since for tables of different applications use different block sizes -- from 4KB to 512KB -- the default bucket splits just worked for our use case. We also kept the default values for other configurations after carefully testing and even after tuning while in production. Our configs are listed below: Alibaba&rsquo;s Bucket Cache related configuration &lt;/span&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.bucketcache.combinedcache.enabled &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true &nbsp;&nbsp;&nbsp;&lt;/property&gt; &nbsp;&nbsp;&nbsp; &lt;/span&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.bucketcache.ioengine &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offheap &nbsp;&nbsp;&nbsp;&lt;/property&gt; &nbsp;&nbsp;&nbsp; &lt;/span&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.bucketcache.size &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12288 &nbsp;&nbsp;&nbsp;&lt;/property&gt; &nbsp;&nbsp;&nbsp; &lt;/span&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.bucketcache.writer.queuelength &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;64 &nbsp;&nbsp;&nbsp;&lt;/property&gt; &nbsp;&nbsp;&nbsp; &lt;/span&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.bucketcache.writer.threads &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&lt;/property&gt; How it works? - A/B Test and Singles&rsquo; Day We tested the performance on our A/B test cluster (with 450 physical machines, and each with 256G memory + 64 core) after back porting and got a better throughput as illustrated below It can be noted that now the average throughput graph is very much more linear and there are no more dips in throughput across time. The version with the offheap read path feature was released on October 10th and has been online ever since (more than 4 months). Together with the NettyRpcServer patch (HBASE-15756), we successfully made it through our 2016 Singles&rsquo; Day, with peaks at 100K QPS on a single RS. [1] https://blogs.apache.org/hbase/entry/offheaping_the_read_path_in [2] http://www.slideshare.net/HBaseCon/offheaping-the-apache-hbase-read-path [3] https://issues.apache.org/jira/browse/HBASE-17138 [4] https://issues.apache.org/jira/secure/attachment/12562209/Introduction%20of%20Bucket%20Cache.pdf [5] http://hbase.apache.org/book.html#offheap.blockcache &lt;/span&gt;" />
<meta property="og:description" content="By Yu Li (HBase Committer/Alibaba), Yu Sun (Alibaba), Anoop Sam John (HBase PMC/Intel), and Ramkrishna S Vasudevan (HBase PMC/Intel) &lt;/p&gt; Introduction HBase is the core storage system in Alibaba&rsquo;s Search Infrastructure. Critical e-commerce data about products, sellers and promotions etc. are all synced into HBase from various online databases. We query HBase to build and provide real time updates on the search index. In addition, user behavior data, such as impressions, clicks and transactions will also be streamed into HBase. They serve as feature data for our online machine learning system, which optimizes the personalized search result in real time. The whole system produces mixed workloads on HBase that includes bulkload/snapshot for full index building, batch mutation for real time index updates and streaming/continuous query for online machine learning. Our biggest HBase cluster has reached more than 1500 nodes and 200,000 regions. It routinely serves tens of millions QPS. Both latency and throughput are important for our HBase deploy. From the latency perspective, it directly affects how quickly users can search an item after it has been posted as well as how &lsquo;real-time&rsquo; we can run our inventory accounting. From the throughput perspective, it decides the speed of machine learning program processing, and thus the accuracy of recommendations made. What&rsquo;s more, since data is distributed through the cluster and accesses are balanced, applications are sensitive to latency spikes on a single node, which makes GC a critical factor in our system servicing capability. By caching more data in memory, the read latency (and throughput) can be greatly improved. If we can get our data from local cache, we save having to make a trip to HDFS. Apache HBase has two layers of data caching. There is what we call &ldquo;L1&rdquo; caching, our first caching tier &ndash; which caches data in an on heap Least Recently Used (LRU) cache -- and then there is an optional, &ldquo;L2&rdquo; second cache tier (aka Bucket Cache). Bucket Cache can be configured to keep its data in a file -- i.e. caching data in a local file on disk -- or in memory. File mode usually is able to cache more data but there will be more attendant latency reading from a file vs reading from memory. Bucket Cache can also be configured to use memory outside of the Java heap space (&lsquo;offheap&rsquo;) so users generally configurea a large L2 cache with offheap memory along with a smaller on heap L1 cache. At Alibaba we use an offheap L2 cache dedicating 12GB to Bucket Cache on each node. We also backported a patch currently in master branch only (to be shipped in the coming hbase-2.0.0) which makes it so the hbase read path runs offheap end-to-end. This combination improved our average throughput significantly. In the below sections, we&rsquo;ll first talk about why the off-heaping has to be end-to-end, then introduce how we back ported the feature from master branch to our customized 1.1.2, and at last show the performance with end-to-end read-path offheap in an A/B test and on Singles&rsquo; Day (11/11/2016). Necessity of End-to-end Off-heaping Before offheap, the QPS curve looked like below from our A/B test cluster We could see that there were dips in average throughput. Concurrently, the average latency would be high during these times. Checking RegionServer logs, we could see that there were long GC pauses happening. Further analysis indicated that when disk IO is fast enough, as on PCIe-SSD, blocks would be evicted from cache quite frequently even when there was a high cache hit ratio. The eviction rate was so high that the GC speed couldn&rsquo;t keep up bringing on frequent long GC pauses impacting throughput. Looking to improve throughput, we tried the existing Bucket Cache in 1.1.2 but found GC was still heavy. In other words, although Bucket Cache in branch-1 (branch for current stable releases) already supports using offheap memory for Bucket Cache, it tends to generate lots of garbages. To understand why end-to-end off-heaping is necessary, let&rsquo;s see how reads from Bucket cache work in branch-1. But before we do this, lets understand how bucket cache itself has been organized. The allocated offheap memory is reserved as DirectByteBuffers, each of size 4 MB. So we can say that physically the entire memory area is split into many buffers each of size 4 MB. &nbsp;Now on top of this physical layout, we impose a logical division. Each logical area is sized to accommodate different sized HFile blocks (Remember reads of HFiles happen as blocks and block by block it will get cached in L1 or L2 cache). Each logical split accommodates different sized HFile blocks from 4 KB to 512 KB (This is the default. Sizes are configurable). In each of the splits, there will be more that one slot into which we can insert a block. When caching, we find an appropriately sized split and then an empty slot within it and here we insert the block. Remember all slots are offheap. For more details on Bucket cache, refer here [4]. Refer to the HBase Reference Guide [5] for how to setup Bucket Cache. In branch-1, when the read happens out of an L2 cache, we will have to copy the entire block into a temporary onheap area. This is because the HBase read path assumes block data is backed by an onheap byte array. &nbsp;Also as per the above mentioned physical and logical split, there is a chance that one HFile block data is spread across 2 physical ByteBuffers. When a random row read happens in our system, even if the data is available in L2 cache, we will end up reading the entire block -- usually ~64k in size -- into a temporary onheap allocation for every row read. This creates lots of garbage (and please note that without the HBASE-14463 fix, this copy from offheap to onheap reduced read performance a lot). Our read workload is so high that this copy produces lots of GCs, so we had to find a way to avoid the need of copying block data from offheap cache into temp onheap arrays. How was it achieved? - Our Story The HBASE-11425 Cell/DBB end-to-end on the read-path work in the master branch, avoids the need to copy offheap block data back to onheap when reading. The entire read path is changed to work directly off the offheap Bucket Cache area and serve data directly from here to clients (see the details of this work and performance improvement details here [1], and [2]). So we decided to try this project in our custom HBase version based on 1.1.2 backporting it from the master branch. The backport cost us about 2 people months, including getting familiar with and analysis of the JIRAs to port, fix UT failures, fixing problems found in functional testing (HBASE-16609/16704), and resolving compatibility issues (HBASE-16626). We have listed the full to-back-port JIRA list here [3] and please refer to it for more details if interested. About configurations, since for tables of different applications use different block sizes -- from 4KB to 512KB -- the default bucket splits just worked for our use case. We also kept the default values for other configurations after carefully testing and even after tuning while in production. Our configs are listed below: Alibaba&rsquo;s Bucket Cache related configuration &lt;/span&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.bucketcache.combinedcache.enabled &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true &nbsp;&nbsp;&nbsp;&lt;/property&gt; &nbsp;&nbsp;&nbsp; &lt;/span&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.bucketcache.ioengine &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offheap &nbsp;&nbsp;&nbsp;&lt;/property&gt; &nbsp;&nbsp;&nbsp; &lt;/span&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.bucketcache.size &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12288 &nbsp;&nbsp;&nbsp;&lt;/property&gt; &nbsp;&nbsp;&nbsp; &lt;/span&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.bucketcache.writer.queuelength &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;64 &nbsp;&nbsp;&nbsp;&lt;/property&gt; &nbsp;&nbsp;&nbsp; &lt;/span&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.bucketcache.writer.threads &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&lt;/property&gt; How it works? - A/B Test and Singles&rsquo; Day We tested the performance on our A/B test cluster (with 450 physical machines, and each with 256G memory + 64 core) after back porting and got a better throughput as illustrated below It can be noted that now the average throughput graph is very much more linear and there are no more dips in throughput across time. The version with the offheap read path feature was released on October 10th and has been online ever since (more than 4 months). Together with the NettyRpcServer patch (HBASE-15756), we successfully made it through our 2016 Singles&rsquo; Day, with peaks at 100K QPS on a single RS. [1] https://blogs.apache.org/hbase/entry/offheaping_the_read_path_in [2] http://www.slideshare.net/HBaseCon/offheaping-the-apache-hbase-read-path [3] https://issues.apache.org/jira/browse/HBASE-17138 [4] https://issues.apache.org/jira/secure/attachment/12562209/Introduction%20of%20Bucket%20Cache.pdf [5] http://hbase.apache.org/book.html#offheap.blockcache &lt;/span&gt;" />
<link rel="canonical" href="http://localhost:4000/hbase/entry/offheap-read-path-in-production" />
<meta property="og:url" content="http://localhost:4000/hbase/entry/offheap-read-path-in-production" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-02T21:41:42-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Offheap Read-Path in Production - The Alibaba story" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2019-03-02T21:41:42-05:00","datePublished":"2019-03-02T21:41:42-05:00","description":"By Yu Li (HBase Committer/Alibaba), Yu Sun (Alibaba), Anoop Sam John (HBase PMC/Intel), and Ramkrishna S Vasudevan (HBase PMC/Intel) &lt;/p&gt; Introduction HBase is the core storage system in Alibaba&rsquo;s Search Infrastructure. Critical e-commerce data about products, sellers and promotions etc. are all synced into HBase from various online databases. We query HBase to build and provide real time updates on the search index. In addition, user behavior data, such as impressions, clicks and transactions will also be streamed into HBase. They serve as feature data for our online machine learning system, which optimizes the personalized search result in real time. The whole system produces mixed workloads on HBase that includes bulkload/snapshot for full index building, batch mutation for real time index updates and streaming/continuous query for online machine learning. Our biggest HBase cluster has reached more than 1500 nodes and 200,000 regions. It routinely serves tens of millions QPS. Both latency and throughput are important for our HBase deploy. From the latency perspective, it directly affects how quickly users can search an item after it has been posted as well as how &lsquo;real-time&rsquo; we can run our inventory accounting. From the throughput perspective, it decides the speed of machine learning program processing, and thus the accuracy of recommendations made. What&rsquo;s more, since data is distributed through the cluster and accesses are balanced, applications are sensitive to latency spikes on a single node, which makes GC a critical factor in our system servicing capability. By caching more data in memory, the read latency (and throughput) can be greatly improved. If we can get our data from local cache, we save having to make a trip to HDFS. Apache HBase has two layers of data caching. There is what we call &ldquo;L1&rdquo; caching, our first caching tier &ndash; which caches data in an on heap Least Recently Used (LRU) cache -- and then there is an optional, &ldquo;L2&rdquo; second cache tier (aka Bucket Cache). Bucket Cache can be configured to keep its data in a file -- i.e. caching data in a local file on disk -- or in memory. File mode usually is able to cache more data but there will be more attendant latency reading from a file vs reading from memory. Bucket Cache can also be configured to use memory outside of the Java heap space (&lsquo;offheap&rsquo;) so users generally configurea a large L2 cache with offheap memory along with a smaller on heap L1 cache. At Alibaba we use an offheap L2 cache dedicating 12GB to Bucket Cache on each node. We also backported a patch currently in master branch only (to be shipped in the coming hbase-2.0.0) which makes it so the hbase read path runs offheap end-to-end. This combination improved our average throughput significantly. In the below sections, we&rsquo;ll first talk about why the off-heaping has to be end-to-end, then introduce how we back ported the feature from master branch to our customized 1.1.2, and at last show the performance with end-to-end read-path offheap in an A/B test and on Singles&rsquo; Day (11/11/2016). Necessity of End-to-end Off-heaping Before offheap, the QPS curve looked like below from our A/B test cluster We could see that there were dips in average throughput. Concurrently, the average latency would be high during these times. Checking RegionServer logs, we could see that there were long GC pauses happening. Further analysis indicated that when disk IO is fast enough, as on PCIe-SSD, blocks would be evicted from cache quite frequently even when there was a high cache hit ratio. The eviction rate was so high that the GC speed couldn&rsquo;t keep up bringing on frequent long GC pauses impacting throughput. Looking to improve throughput, we tried the existing Bucket Cache in 1.1.2 but found GC was still heavy. In other words, although Bucket Cache in branch-1 (branch for current stable releases) already supports using offheap memory for Bucket Cache, it tends to generate lots of garbages. To understand why end-to-end off-heaping is necessary, let&rsquo;s see how reads from Bucket cache work in branch-1. But before we do this, lets understand how bucket cache itself has been organized. The allocated offheap memory is reserved as DirectByteBuffers, each of size 4 MB. So we can say that physically the entire memory area is split into many buffers each of size 4 MB. &nbsp;Now on top of this physical layout, we impose a logical division. Each logical area is sized to accommodate different sized HFile blocks (Remember reads of HFiles happen as blocks and block by block it will get cached in L1 or L2 cache). Each logical split accommodates different sized HFile blocks from 4 KB to 512 KB (This is the default. Sizes are configurable). In each of the splits, there will be more that one slot into which we can insert a block. When caching, we find an appropriately sized split and then an empty slot within it and here we insert the block. Remember all slots are offheap. For more details on Bucket cache, refer here [4]. Refer to the HBase Reference Guide [5] for how to setup Bucket Cache. In branch-1, when the read happens out of an L2 cache, we will have to copy the entire block into a temporary onheap area. This is because the HBase read path assumes block data is backed by an onheap byte array. &nbsp;Also as per the above mentioned physical and logical split, there is a chance that one HFile block data is spread across 2 physical ByteBuffers. When a random row read happens in our system, even if the data is available in L2 cache, we will end up reading the entire block -- usually ~64k in size -- into a temporary onheap allocation for every row read. This creates lots of garbage (and please note that without the HBASE-14463 fix, this copy from offheap to onheap reduced read performance a lot). Our read workload is so high that this copy produces lots of GCs, so we had to find a way to avoid the need of copying block data from offheap cache into temp onheap arrays. How was it achieved? - Our Story The HBASE-11425 Cell/DBB end-to-end on the read-path work in the master branch, avoids the need to copy offheap block data back to onheap when reading. The entire read path is changed to work directly off the offheap Bucket Cache area and serve data directly from here to clients (see the details of this work and performance improvement details here [1], and [2]). So we decided to try this project in our custom HBase version based on 1.1.2 backporting it from the master branch. The backport cost us about 2 people months, including getting familiar with and analysis of the JIRAs to port, fix UT failures, fixing problems found in functional testing (HBASE-16609/16704), and resolving compatibility issues (HBASE-16626). We have listed the full to-back-port JIRA list here [3] and please refer to it for more details if interested. About configurations, since for tables of different applications use different block sizes -- from 4KB to 512KB -- the default bucket splits just worked for our use case. We also kept the default values for other configurations after carefully testing and even after tuning while in production. Our configs are listed below: Alibaba&rsquo;s Bucket Cache related configuration &lt;/span&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.bucketcache.combinedcache.enabled &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true &nbsp;&nbsp;&nbsp;&lt;/property&gt; &nbsp;&nbsp;&nbsp; &lt;/span&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.bucketcache.ioengine &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offheap &nbsp;&nbsp;&nbsp;&lt;/property&gt; &nbsp;&nbsp;&nbsp; &lt;/span&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.bucketcache.size &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12288 &nbsp;&nbsp;&nbsp;&lt;/property&gt; &nbsp;&nbsp;&nbsp; &lt;/span&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.bucketcache.writer.queuelength &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;64 &nbsp;&nbsp;&nbsp;&lt;/property&gt; &nbsp;&nbsp;&nbsp; &lt;/span&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.bucketcache.writer.threads &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&lt;/property&gt; How it works? - A/B Test and Singles&rsquo; Day We tested the performance on our A/B test cluster (with 450 physical machines, and each with 256G memory + 64 core) after back porting and got a better throughput as illustrated below It can be noted that now the average throughput graph is very much more linear and there are no more dips in throughput across time. The version with the offheap read path feature was released on October 10th and has been online ever since (more than 4 months). Together with the NettyRpcServer patch (HBASE-15756), we successfully made it through our 2016 Singles&rsquo; Day, with peaks at 100K QPS on a single RS. [1] https://blogs.apache.org/hbase/entry/offheaping_the_read_path_in [2] http://www.slideshare.net/HBaseCon/offheaping-the-apache-hbase-read-path [3] https://issues.apache.org/jira/browse/HBASE-17138 [4] https://issues.apache.org/jira/secure/attachment/12562209/Introduction%20of%20Bucket%20Cache.pdf [5] http://hbase.apache.org/book.html#offheap.blockcache &lt;/span&gt;","headline":"Offheap Read-Path in Production - The Alibaba story","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/hbase/entry/offheap-read-path-in-production"},"url":"http://localhost:4000/hbase/entry/offheap-read-path-in-production"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Offheap Read-Path in Production - The Alibaba story</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-03-02T21:41:42-05:00" itemprop="datePublished">Mar 2, 2019
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Michael Stack", "login"=>"stack", "email"=>"stack@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><em><span id="docs-internal-guid-abccc65d-b199-dcf1-a299-281b06fd127f"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">By Yu Li (HBase Committer/Alibaba), Yu Sun (Alibaba), Anoop Sam John (HBase PMC/Intel), and Ramkrishna S Vasudevan (HBase PMC/Intel)</span></span> </em></p>
<p><span id="docs-internal-guid-abccc65d-b19b-a3e3-e08a-b4ed5d2d4ade"> </p>
<h1 dir="ltr" style="line-height: 1.38; margin-top: 20pt; margin-bottom: 6pt;"><span style="font-size: 20pt; font-family: Arial; background-color: transparent; font-weight: 400; vertical-align: baseline; white-space: pre-wrap;">Introduction</span></h1>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">HBase is the core storage system in Alibaba&rsquo;s Search Infrastructure. Critical e-commerce data about products, sellers and promotions etc. are all synced into HBase from various online databases. We query HBase to build and provide real time updates on the search index. In addition, user behavior data, such as impressions, clicks and transactions will also be streamed into HBase. They serve as feature data for our online machine learning system, which optimizes the personalized search result in real time. The whole system produces mixed workloads on HBase that includes bulkload/snapshot for full index building, batch mutation for real time index updates and streaming/continuous query for online machine learning. Our biggest HBase cluster has reached more than 1500 nodes and 200,000 regions. It routinely serves tens of millions QPS.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Both latency and throughput are important for our HBase deploy. From the latency perspective, it directly affects how quickly users can search an item after it has been posted as well as how &lsquo;real-time&rsquo; we can run our inventory accounting. From the throughput perspective, it decides the speed of machine learning program processing, and thus the accuracy of recommendations made. What&rsquo;s more, since data is distributed through the cluster and accesses are balanced, applications are sensitive to latency spikes on a single node, which makes GC a critical factor in our system servicing capability.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">By caching more data in memory, the read latency (and throughput) can be greatly improved. If we can get our data from local cache, we save having to make a trip to HDFS. Apache HBase has two layers of data caching. There is what we call &ldquo;L1&rdquo; caching, our first caching tier &ndash; which caches data in an on heap Least Recently Used (LRU) cache -- and then there is an optional, &ldquo;L2&rdquo; second cache tier (aka Bucket Cache).</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Bucket Cache can be configured to keep its data in a file -- i.e. caching data in a local file on disk -- or in memory. File mode usually is able to cache more data but there will be more attendant latency reading from a file vs reading from memory. Bucket Cache can also be configured to use memory outside of the Java heap space (&lsquo;offheap&rsquo;) so users generally configurea a large L2 cache with offheap memory along with a smaller on heap L1 cache.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">At Alibaba we use an offheap L2 cache dedicating 12GB to Bucket Cache on each node. We also backported a patch currently in master branch only (to be shipped in the coming hbase-2.0.0) which makes it so the hbase read path runs offheap end-to-end. This combination improved our average throughput significantly. In the below sections, we&rsquo;ll first talk about why the off-heaping has to be end-to-end, then introduce how we back ported the feature from master branch to our customized 1.1.2, and at last show the performance with end-to-end read-path offheap in an A/B test and on Singles&rsquo; Day (11/11/2016). </span></p>
<p> </p>
<h1 dir="ltr" style="line-height: 1.38; margin-top: 20pt; margin-bottom: 6pt;"><span style="font-size: 20pt; font-family: Arial; background-color: transparent; font-weight: 400; vertical-align: baseline; white-space: pre-wrap;">Necessity of End-to-end Off-heaping</span></h1>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Before offheap, the QPS curve looked like below from our A/B test cluster</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"><img src="https://lh6.googleusercontent.com/jDBhJp_Gx6gW7L7O_mmvCMx6EK2tw5Ly2zjte3ElabL_X2BLKjYtWyeguW4CJ9Wp38l5ehr8cQG5AKD7d9nBliGfLrW0y6vqPBH7vok6PVq6NW7qqkbWr08eEXvIRYzKFO9CXBr-" style="transform: rotate(0rad);" alt="Throughput_without_offheap(AB_Testing_450_nodes).png" width="624" height="93" /></span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">We could see that there were dips in average throughput. Concurrently, the average latency would be high during these times.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Checking RegionServer logs, we could see that there were long GC pauses happening. Further analysis indicated that when disk IO is fast enough, as on PCIe-SSD, blocks would be evicted from cache quite frequently even when there was a high cache hit ratio. The eviction rate was so high that the GC speed couldn&rsquo;t keep up bringing on frequent long GC pauses impacting throughput.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Looking to improve throughput, we tried the existing Bucket Cache in 1.1.2 but found GC was still heavy. In other words, although Bucket Cache in branch-1 (branch for current stable releases) already supports using offheap memory for Bucket Cache, it tends to generate lots of garbages. To understand why end-to-end off-heaping is necessary, let&rsquo;s see how reads from Bucket cache work in branch-1. But before we do this, lets understand how bucket cache itself has been organized.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">The allocated offheap memory is reserved as DirectByteBuffers, each of size 4 MB. So we can say that physically the entire memory area is split into many buffers each of size 4 MB. &nbsp;Now on top of this physical layout, we impose a logical division. Each logical area is sized to accommodate different sized HFile blocks </span><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">(Remember reads of HFiles happen as blocks and block by block it will get cached in L1 or L2 cache). </span><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Each logical split accommodates different sized HFile blocks from 4 KB to 512 KB (This is the default. Sizes are configurable). In each of the splits, there will be more that one slot into which we can insert a block. When caching, we find an appropriately sized split and then an empty slot within it and here we insert the block. Remember all slots are offheap. For more details on Bucket cache, refer here [4]. Refer to the HBase Reference Guide [5] for how to setup Bucket Cache.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">In branch-1, when the read happens out of an L2 cache, we will have to copy the entire block into a temporary onheap area. This is because the HBase read path assumes block data is backed by an onheap byte array. &nbsp;Also as per the above mentioned physical and logical split, there is a chance that one HFile block data is spread across 2 physical ByteBuffers.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">When a random row read happens in our system, even if the data is available in L2 cache, we will end up reading the entire block -- usually ~64k in size -- into a temporary onheap allocation for every row read. This creates lots of garbage (and please note that without the </span><a href="https://issues.apache.org/jira/browse/HBASE-14463"><span style="font-size: 11pt; font-family: Arial; color: #1155cc; background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">HBASE-14463</span></a><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> fix, this copy from offheap to onheap reduced read performance a lot). Our read workload is so high</span><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;"> </span><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">that this copy produces lots of GCs, so we had to find a way to avoid the need of copying block data from offheap cache into temp onheap arrays.</span></p>
<h1 dir="ltr" style="line-height: 1.38; margin-top: 20pt; margin-bottom: 6pt;"><span style="font-size: 20pt; font-family: Arial; background-color: transparent; font-weight: 400; vertical-align: baseline; white-space: pre-wrap;">How was it achieved? - Our Story</span></h1>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">The</span><a href="https://issues.apache.org/jira/browse/HBASE-11425"><span style="font-size: 11pt; font-family: Arial; color: #1155cc; background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;"> HBASE-11425 Cell/DBB end-to-end on the read-path</span></a><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> work in the master branch, avoids the need to copy offheap block data back to onheap when reading. The entire read path is changed to work directly off the offheap Bucket Cache area and serve data directly from here to clients (see the details of this work and performance improvement details here </span><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">[1], </span><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">and</span><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;"> [2]). </span><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">So we decided to try this project in our custom HBase version based on 1.1.2 backporting it from the master branch.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">The backport cost us about 2 people months, including getting familiar with and analysis of the JIRAs to port, fix UT failures, fixing problems found in functional testing (HBASE-16609/16704), and resolving compatibility issues (HBASE-16626). We have listed the full to-back-port JIRA list here [3] and please refer to it for more details if interested.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">About configurations, since for tables of different applications use different block sizes -- from 4KB to 512KB -- the default bucket splits just worked for our use case. We also kept the default values for other configurations after carefully testing and even after tuning while in production. Our configs are listed below:</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 16pt;"><span style="font-size: 15pt; font-family: Arial; color: #666666; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">Alibaba&rsquo;s Bucket Cache related configuration</span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> </span><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;">
<property></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<name>hbase.bucketcache.combinedcache.enabled</name></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<value>true</value></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;</property></span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;
<property></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<name>hbase.bucketcache.ioengine</name></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<value>offheap</value></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;</property></span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;
<property></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<name>hbase.bucketcache.size</name></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<value>12288</value></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;</property></span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;
<property></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<name>hbase.bucketcache.writer.queuelength</name></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<value>64</value></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;</property></span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;
<property></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<name>hbase.bucketcache.writer.threads</name></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<value>3</value></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;</property></span></p>
<p> </p>
<h1 dir="ltr" style="line-height: 1.38; margin-top: 20pt; margin-bottom: 6pt;"><span style="font-size: 20pt; font-family: Arial; background-color: transparent; font-weight: 400; vertical-align: baseline; white-space: pre-wrap;">How it works? - A/B Test and Singles&rsquo; Day</span></h1>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">We tested the performance on our A/B test cluster (with 450 physical machines, and each with 256G memory + 64 core) after back porting and got a better throughput as illustrated below</span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> </span><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"><img src="https://lh4.googleusercontent.com/RqP7maWg72VAMJtgwFR6kZfkVWX8fFThpzNHlaGsw4Ss4CEXMNrPqIJhbal9Epsgt73z182WyzjFnk03wTIvir9bZVsMTSus3QuZERkF8MytiR-j_Z05k-LLGXb9PSsY06ddeqv-" style="transform: rotate(0rad);" alt="Throughput_with_offheap(AB_Testing_450_nodes).png" width="624" height="93" /></span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">It can be noted that now the average throughput graph is very much more linear and there are no more dips in throughput across time.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">The version with the offheap read path feature was released on October 10</span><span style="font-size: 6.6pt; font-family: Arial; background-color: transparent; vertical-align: super; white-space: pre-wrap;">th</span><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"> and has been online ever since (more than 4 months). Together with the NettyRpcServer patch (HBASE-15756), we successfully made it through our 2016 Singles&rsquo; Day, with peaks at 100K QPS on a single RS.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"><img src="https://lh3.googleusercontent.com/5il48YVounH-R2qDd4F-IPWJ5-NcQIj6BbH_LmC0bHwVGEKRrnhAgsptIYaiBOB0T81kwYS4K2uDSPLLdXDwpo9B5ACt4dmPe8HRLRFyN5H2Zx7UGf-Ycl80yMvrzajW6R2coDRr" style="transform: rotate(0rad);" alt="1.png" width="624" height="172" /></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;"><img src="https://lh4.googleusercontent.com/jj6L1igx6xn_7Wixm0KLjg2A_z5fDXBCSKDfBnKeHZJQ54ljsJLBaIrruCe7q2v6pFmBtTWerR9EHSdR-LOeGnZae7FCNiKeuk_04h8hjBuuQakMSqBOCS6oRmSPQfqTLk9cWp-b" style="transform: rotate(0rad);" alt="2.png" width="624" height="172" /></span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">[1]</span><a href="https://blogs.apache.org/hbase/entry/offheaping_the_read_path_in"><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;"> </span><span style="font-size: 11pt; font-family: Arial; color: #1155cc; background-color: transparent; font-style: italic; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">https://blogs.apache.org/hbase/entry/offheaping_the_read_path_in</span></a></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">[2]</span><a href="http://www.slideshare.net/HBaseCon/offheaping-the-apache-hbase-read-path"><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;"> </span><span style="font-size: 11pt; font-family: Arial; color: #1155cc; background-color: transparent; font-style: italic; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">http://www.slideshare.net/HBaseCon/offheaping-the-apache-hbase-read-path</span></a></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 11pt; font-family: Arial; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;">[3]</span><a href="https://issues.apache.org/jira/browse/HBASE-17138"><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-style: italic; vertical-align: baseline; white-space: pre-wrap;"> </span><span style="font-size: 11pt; font-family: Arial; color: #1155cc; background-color: transparent; font-style: italic; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">https://issues.apache.org/jira/browse/HBASE-17138</span></a></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><em><span style="font-size: 11pt; font-family: Arial; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">[4] </span><span style="font-size: 11pt; font-family: Arial; color: #1155cc; background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;"><a href="https://issues.apache.org/jira/secure/attachment/12562209/Introduction%20of%20Bucket%20Cache.pdf">https://issues.apache.org/jira/secure/attachment/12562209/Introduction%20of%20Bucket%20Cache.pdf</a></span></em></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><em><span style="font-size: 11pt; font-family: Arial; color: #1155cc; background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;"><a href="https://issues.apache.org/jira/secure/attachment/12562209/Introduction%20of%20Bucket%20Cache.pdf"></a></span><span style="background-color: transparent; font-size: 11pt; font-family: Arial; vertical-align: baseline; white-space: pre-wrap;">[5]</span><a href="http://hbase.apache.org/book.html#offheap.blockcache"><span style="font-size: 11pt; font-family: Arial; color: #1155cc; background-color: transparent; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;"> http://hbase.apache.org/book.html#offheap.blockcache</span></a> </em></p>
<p></span></p>

  </div><a class="u-url" href="/hbase/entry/offheap-read-path-in-production" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
