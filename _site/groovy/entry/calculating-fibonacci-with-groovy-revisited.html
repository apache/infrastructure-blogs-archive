<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Calculating Fibonacci with Groovy revisited | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Calculating Fibonacci with Groovy revisited" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In a recent post, we looked at using Matrices with Groovy including using matrices to calculate Fibonacci terms. But do you need that complexity to calculate Fibonacci? Not, not at all. You can do various one-liners for that scenario (to repeat the calculation from that post): Stream.iterate([1, 1], f -&gt; [f[1], f.sum()]).limit(8).toList()*.head() The previous post was more about using matrices than Fibonacci per se, though hopefully learning that the Fibonacci matrix was a specialisation of the Leslie matrix was an added bonus. Let&#39;s have a look at a few other options to write Fibonacci methods in Groovy. Iterative style Unless you learned a functional programming language as your first language, you may have written an iterative Factorial or Fibonacci as one of your first programming learning exercises. Such an algorithm for Fibonacci could look something like this: def fib(n) { if (n &lt;= 1) return n def previous = n.valueOf(1), next = previous, sum (n-2).times { sum = previous previous = next next = sum + previous } next}assert fib(10) == 55assert fib(50L) == 12586269025Lassert fib(100G) == 354224848179261915075G The only interesting part to this solution is the use of dynamic idioms. We didn&#39;t provide an explicit type for n, so duck-typing means the method works fine for Integer, Long and BigInteger values. This implementation does all calculations using the type of the supplied n, so the user of the method controls that aspect. Groovy gives the option to also specify an explicit type like Number or use TypeChecked or CompileStatic for type inference if you wanted. We&#39;ll see an example of those options later. Recursive Once you mastered iterative programming, your next programming learning exercise may have been the recursive version of Factorial or Fibonacci. For Fibonacci, you may have coded something like this: def fib(n) { if (n &lt;= 1) return n fib(n - 1) + fib(n - 2)}assert fib(10) == 55assert fib(50L) == 12586269025Lassert fib(100G) == 354224848179261915075G This na&iuml;ve version is incredibly inefficient. Calling fib(6) ends up calculating fib(2) five times for instance: There are several ways to avoid that repetition. One option is to use the @Memoized annotation. Adding this annotation on a method causes the compiler to inject appropriate code for caching results into the method. This is ideal for pure functions like Fibonacci since they always return the same output for a given input. There are annotation attributes to adjust how big such a cache might be, but that sophistication isn&#39;t needed here. @Memoizeddef fib(n) { if (n &lt;= 1) return n fib(n - 1) + fib(n - 2)}assert fib(10) == 55assert fib(50L) == 12586269025Lassert fib(100G) == 354224848179261915075G This now runs just as quickly as the iterative method. If you happened to use a Closure instead of a method, you can call one of the memoize methods on Closure. A problem with this approach (in fact recursion in general) is that you hit a stack overflow exception for larger values of n, e.g. fib(500G). Groovy supports tail call elimination with the inclusion of the TailRecursive annotation. In this case the compiler injects an &quot;unrolled&quot; non-recursive version of the algorithm. In order for the &quot;unrolling&quot; to succeed, the algorithm needs to be re-worked so that at most one call to fib occurs in any return statement. Here is a version of the algorithm re-worked in this way: @TailRecursivestatic fib(n, a, b) { if (n == 0) return a if (n == 1) return b fib(n - 1, b, a + b)}assert fib(10, 0, 1) == 55assert fib(50L, 0L, 1L) == 12586269025Lassert fib(100G, 0G, 1G) == 354224848179261915075Gassert fib(500G, 0G, 1G) == 139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125G This is slightly more complicated to understand than the original if you haven&#39;t seen it before but now is both efficient and handles large values of n. We can compile statically for even faster speed like this: @TailRecursive@CompileStaticstatic fib(Number n, Number a, Number b) { if (n == 0) return a if (n == 1) return b fib(n - 1, b, a + b)}assert fib(10, 0, 1) == 55assert fib(50L, 0L, 1L) == 12586269025Lassert fib(100G, 0G, 1G) == 354224848179261915075Gassert fib(500G, 0G, 1G) == 139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125G If you are using a Closure, you would look at using the trampoline method on Closure to achieve a similar result. Streams We saw the Stream based &quot;one-liner&quot; solution at the start of this blog post. Let&#39;s adopt the duck-typing idioms we have used so far and define a fib method. It could look like this: def fib(n) { def zero = n.valueOf(0) def one = n.valueOf(1) Stream.iterate([zero, one], t -&gt; [t[1], t.sum()]) .skip(n.longValue()) .findFirst().get()[0]}assert fib(10) == 55assert fib(50L) == 12586269025Lassert fib(100G) == 354224848179261915075G Bytecode and AST transforms Finally, just so you know all your options, here is a version using the @Bytecode AST transform which lets you write JVM bytecode directly in your Groovy! Note this falls into the category of &quot;don&#39;t ever ever do this&quot; but just so you know you can, it is included here: @Bytecodeint fib(int i) { l0 iload 1 iconst_2 if_icmpgt l1 iconst_1 _goto l2 l1 frame SAME aload 0 iload 1 iconst_2 isub invokevirtual &#39;.fib&#39;,&#39;(I)I&#39; aload 0 iload 1 iconst_1 isub invokevirtual &#39;.fib&#39;, &#39;(I)I&#39; iadd l2 frame same1,&#39;I&#39; ireturn}assert fib(10) == 55 Please read the caveats for that transform before considering using it for anything but extreme situations. It&#39;s meant more as a fun thing to try than something anyone would want to do in production. Have fun writing your own algorithms!" />
<meta property="og:description" content="In a recent post, we looked at using Matrices with Groovy including using matrices to calculate Fibonacci terms. But do you need that complexity to calculate Fibonacci? Not, not at all. You can do various one-liners for that scenario (to repeat the calculation from that post): Stream.iterate([1, 1], f -&gt; [f[1], f.sum()]).limit(8).toList()*.head() The previous post was more about using matrices than Fibonacci per se, though hopefully learning that the Fibonacci matrix was a specialisation of the Leslie matrix was an added bonus. Let&#39;s have a look at a few other options to write Fibonacci methods in Groovy. Iterative style Unless you learned a functional programming language as your first language, you may have written an iterative Factorial or Fibonacci as one of your first programming learning exercises. Such an algorithm for Fibonacci could look something like this: def fib(n) { if (n &lt;= 1) return n def previous = n.valueOf(1), next = previous, sum (n-2).times { sum = previous previous = next next = sum + previous } next}assert fib(10) == 55assert fib(50L) == 12586269025Lassert fib(100G) == 354224848179261915075G The only interesting part to this solution is the use of dynamic idioms. We didn&#39;t provide an explicit type for n, so duck-typing means the method works fine for Integer, Long and BigInteger values. This implementation does all calculations using the type of the supplied n, so the user of the method controls that aspect. Groovy gives the option to also specify an explicit type like Number or use TypeChecked or CompileStatic for type inference if you wanted. We&#39;ll see an example of those options later. Recursive Once you mastered iterative programming, your next programming learning exercise may have been the recursive version of Factorial or Fibonacci. For Fibonacci, you may have coded something like this: def fib(n) { if (n &lt;= 1) return n fib(n - 1) + fib(n - 2)}assert fib(10) == 55assert fib(50L) == 12586269025Lassert fib(100G) == 354224848179261915075G This na&iuml;ve version is incredibly inefficient. Calling fib(6) ends up calculating fib(2) five times for instance: There are several ways to avoid that repetition. One option is to use the @Memoized annotation. Adding this annotation on a method causes the compiler to inject appropriate code for caching results into the method. This is ideal for pure functions like Fibonacci since they always return the same output for a given input. There are annotation attributes to adjust how big such a cache might be, but that sophistication isn&#39;t needed here. @Memoizeddef fib(n) { if (n &lt;= 1) return n fib(n - 1) + fib(n - 2)}assert fib(10) == 55assert fib(50L) == 12586269025Lassert fib(100G) == 354224848179261915075G This now runs just as quickly as the iterative method. If you happened to use a Closure instead of a method, you can call one of the memoize methods on Closure. A problem with this approach (in fact recursion in general) is that you hit a stack overflow exception for larger values of n, e.g. fib(500G). Groovy supports tail call elimination with the inclusion of the TailRecursive annotation. In this case the compiler injects an &quot;unrolled&quot; non-recursive version of the algorithm. In order for the &quot;unrolling&quot; to succeed, the algorithm needs to be re-worked so that at most one call to fib occurs in any return statement. Here is a version of the algorithm re-worked in this way: @TailRecursivestatic fib(n, a, b) { if (n == 0) return a if (n == 1) return b fib(n - 1, b, a + b)}assert fib(10, 0, 1) == 55assert fib(50L, 0L, 1L) == 12586269025Lassert fib(100G, 0G, 1G) == 354224848179261915075Gassert fib(500G, 0G, 1G) == 139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125G This is slightly more complicated to understand than the original if you haven&#39;t seen it before but now is both efficient and handles large values of n. We can compile statically for even faster speed like this: @TailRecursive@CompileStaticstatic fib(Number n, Number a, Number b) { if (n == 0) return a if (n == 1) return b fib(n - 1, b, a + b)}assert fib(10, 0, 1) == 55assert fib(50L, 0L, 1L) == 12586269025Lassert fib(100G, 0G, 1G) == 354224848179261915075Gassert fib(500G, 0G, 1G) == 139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125G If you are using a Closure, you would look at using the trampoline method on Closure to achieve a similar result. Streams We saw the Stream based &quot;one-liner&quot; solution at the start of this blog post. Let&#39;s adopt the duck-typing idioms we have used so far and define a fib method. It could look like this: def fib(n) { def zero = n.valueOf(0) def one = n.valueOf(1) Stream.iterate([zero, one], t -&gt; [t[1], t.sum()]) .skip(n.longValue()) .findFirst().get()[0]}assert fib(10) == 55assert fib(50L) == 12586269025Lassert fib(100G) == 354224848179261915075G Bytecode and AST transforms Finally, just so you know all your options, here is a version using the @Bytecode AST transform which lets you write JVM bytecode directly in your Groovy! Note this falls into the category of &quot;don&#39;t ever ever do this&quot; but just so you know you can, it is included here: @Bytecodeint fib(int i) { l0 iload 1 iconst_2 if_icmpgt l1 iconst_1 _goto l2 l1 frame SAME aload 0 iload 1 iconst_2 isub invokevirtual &#39;.fib&#39;,&#39;(I)I&#39; aload 0 iload 1 iconst_1 isub invokevirtual &#39;.fib&#39;, &#39;(I)I&#39; iadd l2 frame same1,&#39;I&#39; ireturn}assert fib(10) == 55 Please read the caveats for that transform before considering using it for anything but extreme situations. It&#39;s meant more as a fun thing to try than something anyone would want to do in production. Have fun writing your own algorithms!" />
<link rel="canonical" href="http://localhost:4000/groovy/entry/calculating-fibonacci-with-groovy-revisited" />
<meta property="og:url" content="http://localhost:4000/groovy/entry/calculating-fibonacci-with-groovy-revisited" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-09-08T10:59:56-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Calculating Fibonacci with Groovy revisited" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-08T10:59:56-04:00","datePublished":"2022-09-08T10:59:56-04:00","description":"In a recent post, we looked at using Matrices with Groovy including using matrices to calculate Fibonacci terms. But do you need that complexity to calculate Fibonacci? Not, not at all. You can do various one-liners for that scenario (to repeat the calculation from that post): Stream.iterate([1, 1], f -&gt; [f[1], f.sum()]).limit(8).toList()*.head() The previous post was more about using matrices than Fibonacci per se, though hopefully learning that the Fibonacci matrix was a specialisation of the Leslie matrix was an added bonus. Let&#39;s have a look at a few other options to write Fibonacci methods in Groovy. Iterative style Unless you learned a functional programming language as your first language, you may have written an iterative Factorial or Fibonacci as one of your first programming learning exercises. Such an algorithm for Fibonacci could look something like this: def fib(n) { if (n &lt;= 1) return n def previous = n.valueOf(1), next = previous, sum (n-2).times { sum = previous previous = next next = sum + previous } next}assert fib(10) == 55assert fib(50L) == 12586269025Lassert fib(100G) == 354224848179261915075G The only interesting part to this solution is the use of dynamic idioms. We didn&#39;t provide an explicit type for n, so duck-typing means the method works fine for Integer, Long and BigInteger values. This implementation does all calculations using the type of the supplied n, so the user of the method controls that aspect. Groovy gives the option to also specify an explicit type like Number or use TypeChecked or CompileStatic for type inference if you wanted. We&#39;ll see an example of those options later. Recursive Once you mastered iterative programming, your next programming learning exercise may have been the recursive version of Factorial or Fibonacci. For Fibonacci, you may have coded something like this: def fib(n) { if (n &lt;= 1) return n fib(n - 1) + fib(n - 2)}assert fib(10) == 55assert fib(50L) == 12586269025Lassert fib(100G) == 354224848179261915075G This na&iuml;ve version is incredibly inefficient. Calling fib(6) ends up calculating fib(2) five times for instance: There are several ways to avoid that repetition. One option is to use the @Memoized annotation. Adding this annotation on a method causes the compiler to inject appropriate code for caching results into the method. This is ideal for pure functions like Fibonacci since they always return the same output for a given input. There are annotation attributes to adjust how big such a cache might be, but that sophistication isn&#39;t needed here. @Memoizeddef fib(n) { if (n &lt;= 1) return n fib(n - 1) + fib(n - 2)}assert fib(10) == 55assert fib(50L) == 12586269025Lassert fib(100G) == 354224848179261915075G This now runs just as quickly as the iterative method. If you happened to use a Closure instead of a method, you can call one of the memoize methods on Closure. A problem with this approach (in fact recursion in general) is that you hit a stack overflow exception for larger values of n, e.g. fib(500G). Groovy supports tail call elimination with the inclusion of the TailRecursive annotation. In this case the compiler injects an &quot;unrolled&quot; non-recursive version of the algorithm. In order for the &quot;unrolling&quot; to succeed, the algorithm needs to be re-worked so that at most one call to fib occurs in any return statement. Here is a version of the algorithm re-worked in this way: @TailRecursivestatic fib(n, a, b) { if (n == 0) return a if (n == 1) return b fib(n - 1, b, a + b)}assert fib(10, 0, 1) == 55assert fib(50L, 0L, 1L) == 12586269025Lassert fib(100G, 0G, 1G) == 354224848179261915075Gassert fib(500G, 0G, 1G) == 139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125G This is slightly more complicated to understand than the original if you haven&#39;t seen it before but now is both efficient and handles large values of n. We can compile statically for even faster speed like this: @TailRecursive@CompileStaticstatic fib(Number n, Number a, Number b) { if (n == 0) return a if (n == 1) return b fib(n - 1, b, a + b)}assert fib(10, 0, 1) == 55assert fib(50L, 0L, 1L) == 12586269025Lassert fib(100G, 0G, 1G) == 354224848179261915075Gassert fib(500G, 0G, 1G) == 139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125G If you are using a Closure, you would look at using the trampoline method on Closure to achieve a similar result. Streams We saw the Stream based &quot;one-liner&quot; solution at the start of this blog post. Let&#39;s adopt the duck-typing idioms we have used so far and define a fib method. It could look like this: def fib(n) { def zero = n.valueOf(0) def one = n.valueOf(1) Stream.iterate([zero, one], t -&gt; [t[1], t.sum()]) .skip(n.longValue()) .findFirst().get()[0]}assert fib(10) == 55assert fib(50L) == 12586269025Lassert fib(100G) == 354224848179261915075G Bytecode and AST transforms Finally, just so you know all your options, here is a version using the @Bytecode AST transform which lets you write JVM bytecode directly in your Groovy! Note this falls into the category of &quot;don&#39;t ever ever do this&quot; but just so you know you can, it is included here: @Bytecodeint fib(int i) { l0 iload 1 iconst_2 if_icmpgt l1 iconst_1 _goto l2 l1 frame SAME aload 0 iload 1 iconst_2 isub invokevirtual &#39;.fib&#39;,&#39;(I)I&#39; aload 0 iload 1 iconst_1 isub invokevirtual &#39;.fib&#39;, &#39;(I)I&#39; iadd l2 frame same1,&#39;I&#39; ireturn}assert fib(10) == 55 Please read the caveats for that transform before considering using it for anything but extreme situations. It&#39;s meant more as a fun thing to try than something anyone would want to do in production. Have fun writing your own algorithms!","headline":"Calculating Fibonacci with Groovy revisited","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/groovy/entry/calculating-fibonacci-with-groovy-revisited"},"url":"http://localhost:4000/groovy/entry/calculating-fibonacci-with-groovy-revisited"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Calculating Fibonacci with Groovy revisited</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-09-08T10:59:56-04:00" itemprop="datePublished">Sep 8, 2022
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Paul King", "login"=>"paulk", "email"=>"paulk@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>In a <a href="https://blogs.apache.org/roller-ui/authoring/entryEdit.rol?weblog=groovy&amp;bean.id=7e7c1b79-5567-452b-ac11-0d55f765fd90" target="_blank">recent post</a>, we looked at using <a href="https://blogs.apache.org/roller-ui/authoring/entryEdit.rol?weblog=groovy&amp;bean.id=7e7c1b79-5567-452b-ac11-0d55f765fd90" target="_blank">Matrices with Groovy</a> including using matrices to calculate Fibonacci terms. But do you need that complexity to calculate Fibonacci? Not, not at all. You can do various one-liners for that scenario (to repeat the calculation from that post):</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">Stream.<span style="color:#9876aa;font-style:italic;">iterate</span>([<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">1</span>], f -> [f[<span style="color:#6897bb;">1</span>], f.sum()]).limit(<span style="color:#6897bb;">8</span>).toList()*.head()<br></pre>
<p>The previous post was more about using <i>matrices</i> than Fibonacci per se, though hopefully learning that the Fibonacci matrix was a specialisation of the Leslie matrix was an added bonus.</p>
<p>Let's have a look at a few other options to write Fibonacci methods in Groovy.</p>
<h3>Iterative style</h3>
<p>Unless you learned a functional programming language as your first language, you may have written an iterative Factorial or Fibonacci as one of your first programming learning exercises. Such an algorithm for Fibonacci could look something like this:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>fib(n) {<br>    <span style="color:#cc7832;">if </span>(n <= <span style="color:#6897bb;">1</span>) <span style="color:#cc7832;">return </span>n<br><br>    <span style="color:#cc7832;">def </span>previous = n.valueOf(<span style="color:#6897bb;">1</span>), next = previous, sum<br>    (n-<span style="color:#6897bb;">2</span>).times <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">        </span>sum = previous<br>        previous = next<br>        next = sum + previous<br>    <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span>next<br>}<br><br><span style="color:#cc7832;">assert </span>fib(<span style="color:#6897bb;">10</span>) == <span style="color:#6897bb;">55<br></span><span style="color:#cc7832;">assert </span>fib(<span style="color:#6897bb;">50L</span>) == <span style="color:#6897bb;">12586269025L<br></span><span style="color:#cc7832;">assert </span>fib(<span style="color:#6897bb;">100G</span>) == <span style="color:#6897bb;">354224848179261915075G</span><span style="color:#6a8759;"><br></span></pre>
<p>The only interesting part to this solution is the use of dynamic idioms. We didn't provide an explicit type for n, so duck-typing means the method works fine for <code>Integer</code>, <code>Long</code> and <code>BigInteger</code> values. This implementation does all calculations using the type of the supplied <code>n</code>, so the user of the method controls that aspect.</p>
<p>Groovy gives the option to also specify an explicit type like <code>Number</code> or use <code>TypeChecked</code> or <code>CompileStatic</code> for type inference if you wanted. We'll see an example of those options later.</p>
<h3>Recursive</h3>
<p>Once you mastered iterative programming, your next programming learning exercise may have been the recursive version of Factorial or Fibonacci. For Fibonacci, you may have coded something like this:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>fib(n) {<br>    <span style="color:#cc7832;">if </span>(n <= <span style="color:#6897bb;">1</span>) <span style="color:#cc7832;">return </span>n<br>    fib(n - <span style="color:#6897bb;">1</span>) + fib(n - <span style="color:#6897bb;">2</span>)<br>}<br><br><span style="color:#cc7832;">assert </span>fib(<span style="color:#6897bb;">10</span>) == <span style="color:#6897bb;">55<br></span><span style="color:#cc7832;">assert </span>fib(<span style="color:#6897bb;">50L</span>) == <span style="color:#6897bb;">12586269025L<br></span><span style="color:#cc7832;">assert </span>fib(<span style="color:#6897bb;">100G</span>) == <span style="color:#6897bb;">354224848179261915075G</span><span style="color:#6a8759;"><br></span></pre>
<p>This na&iuml;ve version is incredibly inefficient. Calling fib(6) ends up calculating fib(2) five times for instance:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a3/Call_Tree_for_Fibonacci_Number_F6.svg/750px-Call_Tree_for_Fibonacci_Number_F6.svg.png" style="width:40%"></p>
<p>There are several ways to avoid that repetition. One option is to use the <code>@Memoized</code> annotation. Adding this annotation on a method causes the compiler to inject appropriate code for caching results into the method. This is ideal for pure functions like Fibonacci since they always return the same output for a given input. There are annotation attributes to adjust how big such a cache might be, but that sophistication isn't needed here.</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#bbb529;">@Memoized<br></span><span style="color:#cc7832;">def </span>fib(n) {<br>    <span style="color:#cc7832;">if </span>(n <= <span style="color:#6897bb;">1</span>) <span style="color:#cc7832;">return </span>n<br>    fib(n - <span style="color:#6897bb;">1</span>) + fib(n - <span style="color:#6897bb;">2</span>)<br>}<br><br><span style="color:#cc7832;">assert </span>fib(<span style="color:#6897bb;">10</span>) == <span style="color:#6897bb;">55<br></span><span style="color:#cc7832;">assert </span>fib(<span style="color:#6897bb;">50L</span>) == <span style="color:#6897bb;">12586269025L<br></span><span style="color:#cc7832;">assert </span>fib(<span style="color:#6897bb;">100G</span>) == <span style="color:#6897bb;">354224848179261915075G</span><span style="color:#6a8759;"><br></span></pre>
<p>This now runs just as quickly as the iterative method. If you happened to use a <code>Closure</code> instead of a method, you can call one of the <code>memoize</code> methods on <code>Closure</code>.</p>
<p>A problem with this approach (in fact recursion in general) is that you hit a stack overflow exception for larger values of <code>n</code>, e.g. <code>fib(500G)</code>. Groovy supports tail call elimination with the inclusion of the <code>TailRecursive</code> annotation. In this case the compiler injects an "unrolled" non-recursive version of the algorithm. In order for the "unrolling" to succeed, the algorithm needs to be re-worked so that at most one call to fib occurs in any return statement. Here is a version of the algorithm re-worked in this way:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#bbb529;">@TailRecursive<br></span><span style="color:#cc7832;">static </span>fib(n, a, b) {<br>    <span style="color:#cc7832;">if </span>(n == <span style="color:#6897bb;">0</span>) <span style="color:#cc7832;">return </span>a<br>    <span style="color:#cc7832;">if </span>(n == <span style="color:#6897bb;">1</span>) <span style="color:#cc7832;">return </span>b<br>    <span style="color:#9876aa;font-style:italic;">fib</span>(n - <span style="color:#6897bb;">1</span>, b, a + b)<br>}<br><br><span style="color:#cc7832;">assert </span><span style="color:#9876aa;font-style:italic;">fib</span>(<span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">1</span>) == <span style="color:#6897bb;">55<br></span><span style="color:#cc7832;">assert </span><span style="color:#9876aa;font-style:italic;">fib</span>(<span style="color:#6897bb;">50L</span>, <span style="color:#6897bb;">0L</span>, <span style="color:#6897bb;">1L</span>) == <span style="color:#6897bb;">12586269025L<br></span><span style="color:#cc7832;">assert </span><span style="color:#9876aa;font-style:italic;">fib</span>(<span style="color:#6897bb;">100G</span>, <span style="color:#6897bb;">0G</span>, <span style="color:#6897bb;">1G</span>) == <span style="color:#6897bb;">354224848179261915075G<br></span><span style="color:#cc7832;">assert </span><span style="color:#9876aa;font-style:italic;">fib</span>(<span style="color:#6897bb;">500G</span>, <span style="color:#6897bb;">0G</span>, <span style="color:#6897bb;">1G</span>) == <span style="color:#6897bb;">139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125G<br></span></pre>
<p>This is slightly more complicated to understand than the original if you haven't seen it before but now is both efficient and handles large values of <code>n</code>. We can compile statically for even faster speed like this:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#bbb529;">@TailRecursive<br></span><span style="color:#bbb529;">@CompileStatic<br></span><span style="color:#cc7832;">static </span>fib(Number n, Number a, Number b) {<br>    <span style="color:#cc7832;">if </span>(n == <span style="color:#6897bb;">0</span>) <span style="color:#cc7832;">return </span>a<br>    <span style="color:#cc7832;">if </span>(n == <span style="color:#6897bb;">1</span>) <span style="color:#cc7832;">return </span>b<br>    <span style="color:#9876aa;font-style:italic;">fib</span>(n - <span style="color:#6897bb;">1</span>, b, a + b)<br>}<br><br><span style="color:#cc7832;">assert </span><span style="color:#9876aa;font-style:italic;">fib</span>(<span style="color:#6897bb;">10</span>, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">1</span>) == <span style="color:#6897bb;">55<br></span><span style="color:#cc7832;">assert </span><span style="color:#9876aa;font-style:italic;">fib</span>(<span style="color:#6897bb;">50L</span>, <span style="color:#6897bb;">0L</span>, <span style="color:#6897bb;">1L</span>) == <span style="color:#6897bb;">12586269025L<br></span><span style="color:#cc7832;">assert </span><span style="color:#9876aa;font-style:italic;">fib</span>(<span style="color:#6897bb;">100G</span>, <span style="color:#6897bb;">0G</span>, <span style="color:#6897bb;">1G</span>) == <span style="color:#6897bb;">354224848179261915075G<br></span><span style="color:#cc7832;">assert </span><span style="color:#9876aa;font-style:italic;">fib</span>(<span style="color:#6897bb;">500G</span>, <span style="color:#6897bb;">0G</span>, <span style="color:#6897bb;">1G</span>) == <span style="color:#6897bb;">139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125G<br></span></pre>
<p>If you are using a <code>Closure</code>, you would look at using the <code>trampoline</code> method on <code>Closure</code> to achieve a similar result.</p>
<h3>Streams</h3>
<p>We saw the Stream based "one-liner" solution at the start of this blog post. Let's adopt the duck-typing idioms we have used so far and define a fib method. It could look like this:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>fib(n) {<br>    <span style="color:#cc7832;">def </span>zero = n.valueOf(<span style="color:#6897bb;">0</span>)<br>    <span style="color:#cc7832;">def </span>one = n.valueOf(<span style="color:#6897bb;">1</span>)<br>    Stream.<span style="color:#9876aa;font-style:italic;">iterate</span>([zero, one], t -> [t[<span style="color:#6897bb;">1</span>], t.sum()])<br>    .skip(n.longValue())<br>    .findFirst().get()[<span style="color:#6897bb;">0</span>]<br>}<br><br><span style="color:#cc7832;">assert </span>fib(<span style="color:#6897bb;">10</span>) == <span style="color:#6897bb;">55<br></span><span style="color:#cc7832;">assert </span>fib(<span style="color:#6897bb;">50L</span>) == <span style="color:#6897bb;">12586269025L<br></span><span style="color:#cc7832;">assert </span>fib(<span style="color:#6897bb;">100G</span>) == <span style="color:#6897bb;">354224848179261915075G</span><span style="color:#6a8759;"><br></span></pre>
<h3>Bytecode and AST transforms</h3>
<p>Finally, just so you know all your options, here is a version using the <a href="https://github.com/melix/groovy-bytecode-ast" target="_blank">@Bytecode AST transform</a> which lets you write JVM bytecode directly in your Groovy! Note this falls into the category of "don't ever ever do this" but just so you know you can, it is included here:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#bbb529;">@Bytecode<br></span><span style="color:#cc7832;">int </span>fib(<span style="color:#cc7832;">int </span>i) {<br>    l0<br>    iload <span style="color:#6897bb;">1<br></span><span style="color:#6897bb;">    </span>iconst_2<br>    if_icmpgt l1<br>    iconst_1<br>    _goto l2<br>    l1<br>    frame SAME<br>    aload <span style="color:#6897bb;">0<br></span><span style="color:#6897bb;">    </span>iload <span style="color:#6897bb;">1<br></span><span style="color:#6897bb;">    </span>iconst_2<br>    isub<br>    invokevirtual <span style="color:#6a8759;">'.fib'</span>,<span style="color:#6a8759;">'(I)I'<br></span><span style="color:#6a8759;">    </span>aload <span style="color:#6897bb;">0<br></span><span style="color:#6897bb;">    </span>iload <span style="color:#6897bb;">1<br></span><span style="color:#6897bb;">    </span>iconst_1<br>    isub<br>    invokevirtual <span style="color:#6a8759;">'.fib'</span>, <span style="color:#6a8759;">'(I)I'<br></span><span style="color:#6a8759;">    </span>iadd<br>    l2<br>    frame same1,<span style="color:#6a8759;">'I'<br></span><span style="color:#6a8759;">    </span>ireturn<br>}<br><br><span style="color:#cc7832;">assert </span>fib(<span style="color:#6897bb;">10</span>) == <span style="color:#6897bb;">55</span><span style="color:#6a8759;"><br></span></pre>
<p>Please read the caveats for that transform before considering using it for anything but extreme situations. It's meant more as a fun thing to try than something anyone would want to do in production.</p>
<p>Have fun writing your own algorithms!</p>
<p><br></p>

  </div><a class="u-url" href="/groovy/entry/calculating-fibonacci-with-groovy-revisited" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
