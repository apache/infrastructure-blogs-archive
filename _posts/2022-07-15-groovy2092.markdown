---
layout: post
title: Testing your Java with Groovy, Spock, JUnit5, Jacoco, Jqwik and Pitest
date: '2022-07-15T08:26:15+00:00'
categories: groovy
---
<meta name="twitter:card" content="summary_large_image">
<p><img src="https://blogs.apache.org/groovy/mediaresource/694c4230-893a-4f6b-8cf5-6160be80eeed" align="right" style="width:10%;" alt="spock-main-logo.png">This blog post covers a common scenario seen in the Groovy community which is projects which use Java for their production code and Groovy for their tests. This can be a low risk way for Java shops to try out and become more familiar with Groovy. We'll write our initial tests using the <a href="https://spockframework.org/" target="_blank">Spock testing framework</a>&nbsp;and we'll use <a href="https://junit.org/junit5/" target="_blank">JUnit5</a> later with our jqwik tests. You can usually use your favorite Java testing libraries if you switch to Groovy.</p><p><span style="color: inherit; font-family: inherit; font-size: 24px;">The system under test</span><br></p>
<p>For illustrative purposes, we will test a Java mathematics utility function <code>sumBiggestPair</code>. Given three numbers, it finds the two biggest and then adds them up. An initial stab at the code for this might look something like this:</p><pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#0033b3;">public class </span><span style="color:#000000;">MathUtil </span>{<br><br><b>    <span style="color:#0033b3;">public static int </span><span style="color:#00627a;">sumBiggestPair</span>(<span style="color:#0033b3;">int </span>a, <span style="color:#0033b3;">int </span>b, <span style="color:#0033b3;">int </span>c) {<br>        <span style="color:#0033b3;">int </span>op1 = a;<br>        <span style="color:#0033b3;">int </span>op2 = b;<br>        <span style="color:#0033b3;">if </span>(c &gt; a) {<br>            op1 = c;<br>        } <span style="color:#0033b3;">else if </span>(c &gt; b) {<br>            op2 = c;<br>        }<br>        <span style="color:#0033b3;">return </span>op1 + op2;<br>    }</b><br><br>    <span style="color:#0033b3;">private </span><span style="color:#00627a;">MathUtil</span>(){}<br>}<br></pre>
<h3>Testing with Spock</h3>
<p>An initial test could look like this:<br></p><pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#0033b3;">class </span><span style="color:#000000;">MathUtilSpec </span><span style="color:#0033b3;">extends </span><span style="color:#000000;">Specification </span>{<br><b>    <span style="color:#0033b3;">def </span><span style="color:#067d17;">"sum of two biggest numbers"</span>() {<br>        expect:<br>        <span style="color:#000000;">MathUtil</span>.<span style="font-style:italic;">sumBiggestPair</span>(<span style="color:#1750eb;">2</span>, <span style="color:#1750eb;">5</span>, <span style="color:#1750eb;">3</span>) == <span style="color:#1750eb;">8<br></span><span style="color:#1750eb;">    </span>}<br></b>}<br></pre>
<p>When we run this test, all tests pass:</p><p><img src="https://blogs.apache.org/groovy/mediaresource/49da872c-562d-4137-9875-cfa76b932f72" style="width:50%;" alt="test result success image"><br>But if we look at the coverage report, generated with <a href="https://github.com/jacoco/jacoco" target="_blank">Jacoco</a>, we see that our test hasn't covered all lines of code:</p><p><img src="https://blogs.apache.org/groovy/mediaresource/814b3355-c3b7-4a03-9396-f790c606540d" style="width:50%;" alt="incomplete coverage image"><br></p><p>We'll swap to use Spock's data-driven feature and include an additional testcase:</p><pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">    <span style="color:#0033b3;">def </span><span style="color:#067d17;">"sum of two biggest numbers"</span>(<span style="color:#0033b3;">int </span>a, <span style="color:#0033b3;">int </span>b, <span style="color:#0033b3;">int </span>c, <span style="color:#0033b3;">int </span>d) {<br>        expect:<br>        <span style="color:#000000;">MathUtil</span>.<span style="font-style:italic;">sumBiggestPair</span>(a, b, c) == d<br><br>        where:<br>        a | b | c | d<br>        <span style="color:#1750eb;">2 </span>| <span style="color:#1750eb;">5 </span>| <span style="color:#1750eb;">3 </span>| <span style="color:#1750eb;">8<br></span><span style="color:#1750eb;">        <b>5 </b></span><b>| <span style="color:#1750eb;">2 </span>| <span style="color:#1750eb;">3 </span>| <span style="color:#1750eb;">8</span></b><span style="color:#8c8c8c;font-style:italic;"><br></span><span style="color:#8c8c8c;font-style:italic;">    </span>}<br></pre>
<p>We can check our coverage again:</p><p><img src="https://blogs.apache.org/groovy/mediaresource/a1cba09e-a217-4832-a7f3-b3e35d8969f4" style="width:50%;" alt="2022-07-14 22_35_22-MathUtil.java.png"><br></p><p>That is a little better. We now have 100% line coverage but not 100% branch coverage. Let's add one more testcase:</p><pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">    <span style="color:#0033b3;">def </span><span style="color:#067d17;">"sum of two biggest numbers"</span>(<span style="color:#0033b3;">int </span>a, <span style="color:#0033b3;">int </span>b, <span style="color:#0033b3;">int </span>c, <span style="color:#0033b3;">int </span>d) {<br>        expect:<br>        <span style="color:#000000;">MathUtil</span>.<span style="font-style:italic;">sumBiggestPair</span>(a, b, c) == d<br><br>        where:<br>        a | b | c | d<br>        <span style="color:#1750eb;">2 </span>| <span style="color:#1750eb;">5 </span>| <span style="color:#1750eb;">3 </span>| <span style="color:#1750eb;">8<br></span><span style="color:#1750eb;">        5 </span>| <span style="color:#1750eb;">2 </span>| <span style="color:#1750eb;">3 </span>| <span style="color:#1750eb;">8</span><span style="color:#8c8c8c;font-style:italic;"><br></span><span style="color:#8c8c8c;font-style:italic;">        </span><b><span style="color:#1750eb;">5 </span>| <span style="color:#1750eb;">4 </span>| <span style="color:#1750eb;">1 </span>| <span style="color:#1750eb;">9</span></b><span style="color:#8c8c8c;font-style:italic;"><br></span><span style="color:#8c8c8c;font-style:italic;">    </span>}<br></pre><p>And now we can see that we have reached 100% line coverage and 100% branch coverage:</p><p><img src="https://blogs.apache.org/groovy/mediaresource/22c09cd7-88d6-4ae6-bf65-076d90d10f56" style="width:50%;" alt="2022-07-14 22_33_45-MathUtil.java.png"><br></p><p>At this point, we might be very confident in our code and ready to ship it to production. Before we do, we'll add one more testcase:</p><pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#0033b3;">def </span><span style="color:#067d17;">"sum of two biggest numbers"</span>(<span style="color:#0033b3;">int </span>a, <span style="color:#0033b3;">int </span>b, <span style="color:#0033b3;">int </span>c, <span style="color:#0033b3;">int </span>d) {<br>    expect:<br>    <span style="color:#000000;">MathUtil</span>.<span style="font-style:italic;">sumBiggestPair</span>(a, b, c) == d<br><br>    where:<br>    a | b | c | d<br>    <span style="color:#1750eb;">2 </span>| <span style="color:#1750eb;">5 </span>| <span style="color:#1750eb;">3 </span>| <span style="color:#1750eb;">8<br></span><span style="color:#1750eb;">    5 </span>| <span style="color:#1750eb;">2 </span>| <span style="color:#1750eb;">3 </span>| <span style="color:#1750eb;">8</span><span style="color:#8c8c8c;font-style:italic;"><br></span><span style="color:#8c8c8c;font-style:italic;">    </span><span style="color:#1750eb;">5 </span>| <span style="color:#1750eb;">4 </span>| <span style="color:#1750eb;">1 </span>| <span style="color:#1750eb;">9</span><span style="color:#8c8c8c;font-style:italic;"><br></span><span style="color:#8c8c8c;font-style:italic;">    </span><b><span style="color:#1750eb;">3 </span>| <span style="color:#1750eb;">2 </span>| <span style="color:#1750eb;">6 </span>| </b><span style="color:#1750eb;"><b>9</b></span><span style="color:#8c8c8c;font-style:italic;"><br></span>}<br></pre><p>When we re-run our tests, we discover that the last testcase failed!:</p><p><img src="https://blogs.apache.org/groovy/mediaresource/91bfb3b8-ae49-4822-8c97-1224529f8359" style="width:50%" alt="2022-07-14 22_49_23-Test results - MathUtilSpec.png"><br></p><p>And examining the testcase, we can indeed see that there is a flaw in our algorithm. Basically, having the <code>else</code> logic doesn't cater for when <code>c</code> is greater than both <code>a</code> and <code>b</code>!</p><p><img src="https://blogs.apache.org/groovy/mediaresource/34bd7414-c1f0-4cdf-906c-be53ae6d7c44" style="width:50%;" alt="2022-07-14 22_49_58-Test results - MathUtilSpec.png"><br></p><p>We succumbed to faulty expectations of what 100% coverage would give us.</p><p><img src="https://blogs.apache.org/groovy/mediaresource/00a2e70b-914d-4549-8d34-5c5c6fcb4433" style="width:25%;" title="A 100% code coverage example (Image credit: https://pedrorijo.com/blog/intro-mutation/)" alt="A 100% code coverage example"><br></p><p>The good news is that we can fix this. Here is an updated algorithm:</p><pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#0033b3;">public static int </span><span style="color:#00627a;">sumBiggestPair</span>(<span style="color:#0033b3;">int </span>a, <span style="color:#0033b3;">int </span>b, <span style="color:#0033b3;">int </span>c) {<br>    <span style="color:#0033b3;">int </span>op1 = a;<br>    <span style="color:#0033b3;">int </span>op2 = b;<br>    <span style="color:#0033b3;">if </span>(c &gt; <span style="color:#000000;">Math</span>.<span style="font-style:italic;">min</span>(a, b)) {<br>        op1 = c;<br>        op2 = <span style="color:#000000;">Math</span>.<span style="font-style:italic;">max</span>(a, b);<br>    }<br>    <span style="color:#0033b3;">return </span>op1 + op2;<br>}<br></pre><p>With this new algorithm, all 4 testcases now pass and we again have 100% line and branch coverage.</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.8pt;"><b>&gt; Task :SumBiggestPairPitest:test</b>
<span style="color:#4E9A06;">✔</span> Test sum of two biggest numbers [Tests: 4/<span style="color:#4E9A06;">4</span>/<span style="color:#CC0000;">0</span>/<span style="color:#C4A000;">0</span>] [Time: 0.317 s]
<span style="color:#4E9A06;">✔</span> Test util.MathUtilSpec [Tests: 4/<span style="color:#4E9A06;">4</span>/<span style="color:#CC0000;">0</span>/<span style="color:#C4A000;">0</span>] [Time: 0.320 s]
<span style="color:#4E9A06;">✔</span> Test Gradle Test Run :SumBiggestPairPitest:test [Tests: 4/<span style="color:#4E9A06">4</span>/<span style="color:#CC0000">0</span>/<span style="color:#C4A000;">0</span>]
</pre>
<p>But haven't we been here before? How can we be sure there isn't some additional test cases that might reveal another flaw in our algorithm? We could keep writing lots more testcases but we'll look at two other techniques that can help.</p><h3>Mutation testing with Pitest</h3><p>An interesting but not widely used technique is mutation testing. It probably deserves to be more widely used. It can test the quality of a testsuite but has the drawback of sometimes being quite resource intensive. It modifies (mutates) production code and re-runs your testsuite. If your test suite still passes with modified code, it possibly indicates that your testsuite is lacking sufficient coverage. Earlier, we had an algorithm with a flaw and our testsuite didn't initially pick it up. You can think of mutation testing as adding a deliberate flaw and seeing whether your testsuite is good enough to detect that flaw.</p><p>If your a fan of test-driven development (TDD), it espouses a rule that not a single line of production code should be added unless a failing test forces that line to be added. A corollary is that if you change a single line of production code in any meaningful way, that some test should fail.</p><p>So, let's have a look at what mutation testing says about our initial flawed algorithm. We'll use <a href="https://pitest.org/" target="_blank">Pitest</a>&nbsp;(also known as PIT). We'll go back to our initial algorithm and the point where we erroneously thought we had 100% coverage. When we run Pitest, we get the following result:</p><p><img src="https://blogs.apache.org/groovy/mediaresource/8f04888a-6951-4b50-b76b-65aea7f8d4e4" style="width:50%;" alt="2022-07-14 23_57_17-index.html.png"><br></p><p>And looking at the code we see:</p><p><img src="https://blogs.apache.org/groovy/mediaresource/45c1e5e6-e64c-4471-b595-10d1523030b2" style="width:50%;" alt="2022-07-14 23_53_51-MathUtil.java.html.png"><br></p><p>With output including some statistics:<br></p><pre>================================================================================
- Statistics
================================================================================
&gt;&gt; Line Coverage: 7/8 (88%)
&gt;&gt; Generated 6 mutations Killed 4 (67%)
&gt;&gt; Mutations with no coverage 0. Test strength 67%
&gt;&gt; Ran 26 tests (4.33 tests per mutation)</pre>
<p>What is this telling us? Pitest mutated our code in ways that you might expect to break it but our testsuite passed (survived) in a couple of instances. That means one of two things. Either, there are multiple valid implementations of our algorithm and Pitest found one of those equivalent solutions, or our testsuite is lacking some key testcases. In our case, we know that the testsuite was insufficient.</p><p>Let's run it again but this time with all of our tests and the corrected algorithm.</p><p><img src="https://blogs.apache.org/groovy/mediaresource/39323c78-9c95-4ec0-9882-e242f16a20b1" style="width:50%;" alt="2022-07-15 00_11_21-MathUtil.java.html.png"><br></p><p>The output when running the test has also changed slightly:</p>
<pre>================================================================================
- Statistics
================================================================================
&gt;&gt; Line Coverage: 6/7 (86%)
&gt;&gt; Generated 4 mutations Killed 3 (75%)
&gt;&gt; Mutations with no coverage 0. Test strength 75%
&gt;&gt; Ran 25 tests (6.25 tests per mutation)</pre>
<p>Our warnings from Pitest have reduced but not gone completely away and our test strength has gone up but is still not 100%. It does mean that we are in better shape than before. But should we be concerned?</p><p>It turns out in this case, we don't need to worry (too much). As an example, an equally valid algorithm for our function under test would be to replace the conditional with "<code>c &gt;= Math.min(a, b)</code>". Note the <i>greater-than-equals</i> operator rather than just <i>greater-than</i>. For this algorithm, a different path would be taken for the case when&nbsp;<code>c</code> equals&nbsp;<code>a</code> or <code>b</code>, but the end result would be the same. So, that would be an inconsequential or <i>equivalent</i> mutation. In such a case, there may be no additional testcase that we can write to keep Pitest happy. We have to be aware of this possible outcome when using this technique.</p><p>Finally, let's look at our build file that ran Spock, Jacoco and Pitest:<br></p>
<pre style="background-color: rgb(255, 255, 255);"><font color="#080808" face="JetBrains Mono, monospace"><span style="font-size: 9.6pt;">plugins </span></font><span style="color: rgb(8, 8, 8); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt; font-weight: bold;">{<br></span><span style="color: rgb(8, 8, 8); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt; font-weight: bold;">    </span><font color="#080808" face="JetBrains Mono, monospace"><span style="font-size: 9.6pt;">id </span></font><span style="color: rgb(6, 125, 23); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;">'info.solidsoft.pitest' </span><font color="#080808" face="JetBrains Mono, monospace"><span style="font-size: 9.6pt;">version </span></font><span style="color: rgb(6, 125, 23); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;">'1.7.4'<br></span><span style="color: rgb(8, 8, 8); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt; font-weight: bold;">}<br></span><font color="#080808" face="JetBrains Mono, monospace"><span style="font-size: 9.6pt;">apply </span></font><span style="color: rgb(6, 125, 23); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;">plugin</span><font color="#080808" face="JetBrains Mono, monospace"><span style="font-size: 9.6pt;">: </span></font><span style="color: rgb(6, 125, 23); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;">'groovy'<br></span><span style="color: rgb(6, 125, 23); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;"><br></span><font color="#080808" face="JetBrains Mono, monospace"><span style="font-size: 9.6pt;">repositories </span></font><span style="color: rgb(8, 8, 8); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt; font-weight: bold;">{<br></span><span style="color: rgb(8, 8, 8); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt; font-weight: bold;">    </span><font color="#080808" face="JetBrains Mono, monospace"><span style="font-size: 9.6pt;">mavenCentral()<br></span></font><span style="color: rgb(8, 8, 8); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt; font-weight: bold;">}<br></span><span style="color: rgb(8, 8, 8); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt; font-weight: bold;"><br></span><font color="#080808" face="JetBrains Mono, monospace"><span style="font-size: 9.6pt;">dependencies </span></font><span style="color: rgb(8, 8, 8); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt; font-weight: bold;">{<br></span><span style="color: rgb(8, 8, 8); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt; font-weight: bold;">    </span><font color="#080808" face="JetBrains Mono, monospace"><span style="font-size: 9.6pt;">implementation </span></font><span style="color: rgb(6, 125, 23); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;">"org.apache.groovy:groovy-test-junit5:4.0.3</span><span style="color: rgb(6, 125, 23); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;">"<br></span><span style="color: rgb(6, 125, 23); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;">    </span><font color="#080808" face="JetBrains Mono, monospace"><span style="font-size: 9.6pt;">testImplementation(</span></font><span style="color: rgb(6, 125, 23); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.6pt;">"org.spockframework:spock-core:2.2-M3-groovy-4.0"</span><span style="font-size: 9.6pt;">) </span><span style="font-size: 9.6pt; font-weight: bold;">{</span><br><span style="font-weight:bold;">        </span>transitive = <span style="color:#0033b3;">false<br></span><span style="color:#0033b3;">    </span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span>pitest <span style="font-weight:bold;">{
</span><span style="font-weight:bold;">    </span>junit5PluginVersion = <span style="color:#067d17;">'1.0.0'
</span><span style="font-weight:bold;">    </span>pitestVersion = <span style="color:#067d17;">'1.9.2'
</span><span style="color:#067d17;">    </span>timestampedReports = <span style="color:#0033b3;">false<br></span><span style="color:#0033b3;">    </span>targetClasses = [<span style="color:#067d17;">'util.*'</span>]<br><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span>tasks.named(<span style="color:#067d17;">'test'</span>) <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>useJUnitPlatform()<br><span style="font-weight:bold;">}<br></span></pre>
<p>The astute reader might note some subtle hints which show that the latest Spock versions run on top of the JUnit 5 platform.</p><h3>Using Property-based Testing</h3><p>Property-based testing is another technology which probably deserves much more attention. Here we'll use <a href="https://jqwik.net/" target="_blank">jqwik</a>&nbsp;which runs on top of JUnit5 but you might also like to consider <a href="https://github.com/Bijnagte/spock-genesis" target="_blank">Genesis</a> which provides random generators and especially targets Spock.</p><p>Earlier, we looked at writing <i>more</i> tests to make our coverage stronger. Property-based testing can often lead to writing <i>less</i> tests. Instead, we generate many random tests automatically and see whether certain properties hold.</p><p>Previously, we fed in the inputs and the expected output. For property-based testing, the inputs are typically randomly-generated values, we don't know the output. So, instead of testing directly against some known output, we'll just check various properties of the answer.<br></p><p>As an example, here is a test we could use:</p><pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#9e880d;">@Property<br></span><span style="color:#0033b3;">void </span><span style="color:#067d17;">"result should be bigger than any individual and smaller than sum of all"</span>(<br>        <span style="color:#9e880d;">@ForAll @IntRange</span>(min = <span style="color:#1750eb;">0</span>, max = <span style="color:#1750eb;">1000</span>) <span style="color:#000000;">Integer </span>a,<br>        <span style="color:#9e880d;">@ForAll @IntRange</span>(min = <span style="color:#1750eb;">0</span>, max = <span style="color:#1750eb;">1000</span>) <span style="color:#000000;">Integer </span>b,<br>        <span style="color:#9e880d;">@ForAll @IntRange</span>(min = <span style="color:#1750eb;">0</span>, max = <span style="color:#1750eb;">1000</span>) <span style="color:#000000;">Integer </span>c) {<br>    <span style="color:#0033b3;">def </span><span style="color:#000000;">result </span>= <span style="font-style:italic;">sumBiggestPair</span>(a, b, c)<br>    <span style="color:#0033b3;">assert </span><b>[a, b, c].every { individual -&gt; <span style="color:#000000;">result </span>&gt;= individual }<br></b><span style="font-weight:bold;">    </span><span style="color:#0033b3;">assert </span><b><span style="color:#000000;">result </span>&lt;= a + b + c</b><br>}</pre><p>The&nbsp;<code>@ForAll</code>&nbsp;annotations indicate places where jqwik will insert random values. The&nbsp;<code>@IntRange</code>&nbsp;annotation indicates that we want the random values to be contained between 0 and 1000.</p><p>Here we are checking that (at least for small positive numbers) adding the two biggest numbers should be greater than or equal to any individual number and should be less than or equal to adding all three of the numbers. These are necessary but insufficient properties to ensure our system works.<br></p><p>When we run this we see the following output in the logs:</p><pre><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |--------------------jqwik--------------------
tries = 1000&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | # of calls to property
checks = 1000&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| # of not rejected calls
generation = RANDOMIZED&nbsp; &nbsp; &nbsp; &nbsp;| parameters are randomly generated
after-failure = PREVIOUS_SEED | use the previous seed
when-fixed-seed = ALLOW&nbsp; &nbsp; &nbsp; &nbsp;| fixing the random seed is allowed
edge-cases#mode = MIXIN&nbsp; &nbsp; &nbsp; &nbsp;| edge cases are mixed in
edge-cases#total = 125&nbsp; &nbsp; &nbsp; &nbsp; | # of all combined edge cases
edge-cases#tried = 117&nbsp; &nbsp; &nbsp; &nbsp; | # of edge cases tried in current run
seed = -311315135281003183&nbsp; &nbsp; | random seed to reproduce generated values</p></pre><p>So, we wrote 1 test and 1000 testcases were executed. The number of tests run is configurable. We won't go into the details here. This looks great at first glance. It turns out however, that this particular property is not very discriminating in terms of the bugs it can find. This test passes for both our original flawed algorithm as well as the fixed one. Let's try a different property:</p><pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#9e880d;">@Property<br></span><span style="color:#0033b3;">void </span><span style="color:#067d17;">"sum of any pair should not be greater than result"</span>(<br>        <span style="color:#9e880d;">@ForAll @IntRange</span>(min = <span style="color:#1750eb;">0</span>, max = <span style="color:#1750eb;">1000</span>) <span style="color:#000000;">Integer </span>a,<br>        <span style="color:#9e880d;">@ForAll @IntRange</span>(min = <span style="color:#1750eb;">0</span>, max = <span style="color:#1750eb;">1000</span>) <span style="color:#000000;">Integer </span>b,<br>        <span style="color:#9e880d;">@ForAll @IntRange</span>(min = <span style="color:#1750eb;">0</span>, max = <span style="color:#1750eb;">1000</span>) <span style="color:#000000;">Integer </span>c) {<br>    <span style="color:#0033b3;">def </span><span style="color:#000000;">result </span>= <span style="font-style:italic;">sumBiggestPair</span>(a, b, c)<br>    <span style="color:#0033b3;">assert </span><b>[a + b, b + c, c + a].every { sumOfPair -&gt; <span style="color:#000000;">result </span>&gt;= sumOfPair }<br></b>}<br></pre><p>If we calculate the biggest pair, then surely it must be greater than or equal to any arbitrary pair. Trying this on our flawed algorithm gives:&nbsp;</p><pre>org.codehaus.groovy.runtime.powerassert.PowerAssertionError:
&nbsp; &nbsp; assert [a + b, b + c, c + a].every { sumOfPair -&gt; result &gt;= sumOfPair }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | | |&nbsp; | | |&nbsp; | | |&nbsp; |
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 1 0&nbsp; 0 2 2&nbsp; 2 3 1&nbsp; false<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |--------------------jqwik--------------------
tries = 12&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | # of calls to property
checks = 12&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| # of not rejected calls
generation = RANDOMIZED&nbsp; &nbsp; &nbsp; &nbsp;| parameters are randomly generated
after-failure = PREVIOUS_SEED | use the previous seed
when-fixed-seed = ALLOW&nbsp; &nbsp; &nbsp; &nbsp;| fixing the random seed is allowed
edge-cases#mode = MIXIN&nbsp; &nbsp; &nbsp; &nbsp;| edge cases are mixed in
edge-cases#total = 125&nbsp; &nbsp; &nbsp; &nbsp; | # of all combined edge cases
edge-cases#tried = 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | # of edge cases tried in current run
seed = 4830696361996686755&nbsp; &nbsp; | random seed to reproduce generated values
</p><p>Shrunk Sample (6 steps)
-----------------------
&nbsp; arg0: 1
&nbsp; arg1: 0
&nbsp; arg2: 2
</p><p>Original Sample
---------------
&nbsp; arg0: 247
&nbsp; arg1: 32
&nbsp; arg2: 267</p><p>&nbsp; Original Error
&nbsp; --------------
&nbsp; org.codehaus.groovy.runtime.powerassert.PowerAssertionError:
&nbsp; &nbsp; assert [a + b, b + c, c + a].every { sumOfPair -&gt; result &gt;= sumOfPair }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | | |&nbsp; | | |&nbsp; | | |&nbsp; |
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | | 32 32| 267| | |&nbsp; false
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 279&nbsp; &nbsp; 299&nbsp; | | 247
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 247&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 514
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 267<span style="background-color: rgb(245, 245, 245);">
</span></p></pre>
<p>Not only did it find a case which highlighted the flaw, but it <i>shrunk</i> it down to a very simple example. On our fixed algorithm, the 1000 tests pass!</p><p>The previous property can be refactored a little to not only calculate all three pairs but then find the maximum of those. This simplifies the condition somewhat:</p><pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#9e880d;">@Property<br></span><span style="color:#0033b3;">void </span><span style="color:#067d17;">"result should be the same as alternative oracle implementation"</span>(<br>        <span style="color:#9e880d;">@ForAll @IntRange</span>(min = <span style="color:#1750eb;">0</span>, max = <span style="color:#1750eb;">1000</span>) <span style="color:#000000;">Integer </span>a,<br>        <span style="color:#9e880d;">@ForAll @IntRange</span>(min = <span style="color:#1750eb;">0</span>, max = <span style="color:#1750eb;">1000</span>) <span style="color:#000000;">Integer </span>b,<br>        <span style="color:#9e880d;">@ForAll @IntRange</span>(min = <span style="color:#1750eb;">0</span>, max = <span style="color:#1750eb;">1000</span>) <span style="color:#000000;">Integer </span>c) {<br>    <span style="color:#0033b3;">assert </span><b><span style="font-style:italic;">sumBiggestPair</span>(a, b, c) == [a+b, a+c, b+c].max()</b><br>}<br></pre><p>This approach, where an alternative implementation is used, is known as a test <i>oracle</i>. The alternative implementation might be less efficient, so not ideal for production code, but fine for testing. When revamping or replacing some software, the oracle might be the existing system. When run on our fixed algorithm, we again have 1000 testcases passing.</p><p>Let's go one step further and remove our <code>@IntRange</code> boundaries on the Integers:</p><pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#9e880d;">@Property<br></span><span style="color:#0033b3;">void </span><span style="color:#067d17;">"result should be the same as alternative oracle implementation"</span>(<span style="color:#9e880d;">@ForAll </span><span style="color:#000000;">Integer </span>a, <span style="color:#9e880d;">@ForAll </span><span style="color:#000000;">Integer </span>b, <span style="color:#9e880d;">@ForAll </span><span style="color:#000000;">Integer </span>c) {<br>    <span style="color:#0033b3;">assert </span><span style="font-style:italic;">sumBiggestPair</span>(a, b, c) == [a+b, a+c, b+c].max()<br>}<br></pre><p>When we run the test now, we might be surprised:<br></p>
<pre>  org.codehaus.groovy.runtime.powerassert.PowerAssertionError:
    assert sumBiggestPair(a, b, c) == [a+b, a+c, b+c].max()
           |              |  |  |  |   |||  |||  |||  |
           -2147483648    0  1  |  |   0|1  0||  1||  2147483647
                                |  |    1    ||   |2147483647
                                |  false     ||   -2147483648
                                2147483647   |2147483647
                                             2147483647
Shrunk Sample (13 steps)
------------------------
  arg0: 0
  arg1: 1
  arg2: 2147483647
</pre>
<p>It fails! Is this another bug in our algorithm? Possibly? But it could equally be a bug in our property test. Further investigation is warranted.</p><p>It turns out that our algorithm suffers from Integer overflow when trying to add <code>1</code> to <code>Integer.MAX_VALUE</code>. Our test partially suffers from the same problem but when we call <code>max()</code>, the negative value will be discarded. There is no always correct answer as to what should happen in this scenario. We go back to the customer and check the real requirement. In this case, let's assume the customer was happy for the overflow to occur - since that is what would happen if performing the operation long-hand in Java. With that knowledge we should fix our test to at least pass correctly when overflow occurs.</p><p>We have a number of options to fix this. We already saw previously we can use <code>@IntRange</code>. This is one way to "avoid" the problem and we have a few similar approaches which do the same. We could use a more confined data type, e.g. <code>Short</code>:<br></p><pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#9e880d;">@Property<br></span><span style="color:#0033b3;">void </span><span style="color:#00627a;">checkShort</span>(<span style="color:#9e880d;">@ForAll </span><span style="color:#000000;">Short </span>a, <span style="color:#9e880d;">@ForAll </span><span style="color:#000000;">Short </span>b, <span style="color:#9e880d;">@ForAll </span><span style="color:#000000;">Short </span>c) {<br>    <span style="color:#0033b3;">assert </span><span style="font-style:italic;">sumBiggestPair</span>(a, b, c) == [a+b, a+c, b+c].max()<br>}<br></pre><p>Or we could use a customised provider method:</p><pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#9e880d;">@Property<br></span><span style="color:#0033b3;">void </span><span style="color:#00627a;">checkIntegerConstrainedProvider</span>(<span style="color:#9e880d;">@ForAll</span>(<span style="color:#067d17;">'halfMax'</span>) <span style="color:#000000;">Integer </span>a,<br>                                     <span style="color:#9e880d;">@ForAll</span>(<span style="color:#067d17;">'halfMax'</span>) <span style="color:#000000;">Integer </span>b,<br>                                     <span style="color:#9e880d;">@ForAll</span>(<span style="color:#067d17;">'halfMax'</span>) <span style="color:#000000;">Integer </span>c) {<br>    <span style="color:#0033b3;">assert </span><span style="font-style:italic;">sumBiggestPair</span>(a, b, c) == [a+b, a+c, b+c].max()<br>}<br><br><span style="color:#9e880d;">@Provide<br></span><span style="color:#000000;">Arbitrary</span>&lt;<span style="color:#000000;">Integer</span>&gt; <span style="color:#00627a;">halfMax</span>() {<br>    <span style="color:#0033b3;">int </span><span style="color:#000000;">halfMax </span>= <span style="color:#000000;">Integer</span>.<span style="color:#871094;font-style:italic;">MAX_VALUE </span>&gt;&gt; <span style="color:#1750eb;">1<br></span><span style="color:#1750eb;">    </span><span style="color:#0033b3;">return </span><span style="color:#000000;">Arbitraries</span>.<span style="font-style:italic;">integers</span>().between(-<span style="color:#000000;">halfMax</span>, <span style="color:#000000;">halfMax</span>)<br>}<br></pre><p>But rather than avoiding the problem, we could change our test so that it allowed for the possibility of overflow within <code>sumBiggestPair</code> but didn't compound the problem with its own overflow. E.g. we could use Long's to do our calculations within our test:</p><pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#9e880d;">@Property<br></span><span style="color:#0033b3;">void </span><span style="color:#00627a;">checkIntegerWithLongCalculations</span>(<span style="color:#9e880d;">@ForAll </span><span style="color:#000000;">Integer </span>a, <span style="color:#9e880d;">@ForAll </span><span style="color:#000000;">Integer </span>b, <span style="color:#9e880d;">@ForAll </span><span style="color:#000000;">Integer </span>c) {<br>    <span style="color:#0033b3;">def </span>(<span style="color:#000000;">al</span>, <span style="color:#000000;">bl</span>, <span style="color:#000000;">cl</span>) = [a, b, c]*.toLong()<br>    <span style="color:#0033b3;">assert </span><span style="font-style:italic;">sumBiggestPair</span>(a, b, c) == [<span style="color:#000000;">al</span>+<span style="color:#000000;">bl</span>, <span style="color:#000000;">al</span>+<span style="color:#000000;">cl</span>, <span style="color:#000000;">bl</span>+<span style="color:#000000;">cl</span>].max().toInteger()<br>}<br></pre>
<p>Finally, let's again look at our Gradle build file:<br></p><pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">apply <span style="color:#067d17;">plugin</span>: <span style="color:#067d17;">'groovy'<br></span><span style="color:#067d17;"><br></span>repositories <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>mavenCentral()<br><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span>dependencies <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>testImplementation project(<span style="color:#067d17;">':SumBiggestPair'</span>)<br>    testImplementation <span style="color:#067d17;">"org.apache.groovy:groovy-test-junit5:4.0.3</span><span style="color:#067d17;">"<br></span><span style="color:#067d17;">    </span>testImplementation <span style="color:#067d17;">"net.jqwik:jqwik:1.6.5</span><span style="color:#067d17;">"<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span>test <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>useJUnitPlatform <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">        </span>includeEngines <span style="color:#067d17;">'jqwik'<br></span><span style="color:#067d17;">    </span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">}<br></span></pre><h3>More information</h3>
<p>The examples in this blog post are excerpts from the following repo:</p><p><a href="https://github.com/paulk-asert/property-based-testing" target="_blank">https://github.com/paulk-asert/property-based-testing</a><br><br>Versions used: Gradle 7.5, Groovy 4.0.3, jqwik&nbsp;1.6.5, pitest 1.9.2, Spock&nbsp;2.2-M3-groovy-4.0, Jacoco 0.8.8. Tested with JDK 8, 11, 17, 18.<br></p><p>There are many sites with valuable information about the technologies covered here. There are also some great books. Books on Spock include:&nbsp;<a href="https://www.oreilly.com/library/view/spock-up-and/9781491923283/" target="_blank" style="background-color: rgb(255, 255, 255);">Spock: Up and Running</a>, <a href="https://www.manning.com/books/java-testing-with-spock" target="_blank" style="background-color: rgb(255, 255, 255);">Java Testing with Spock</a>, and&nbsp;<a href="https://leanpub.com/spockframeworknotebook" target="_blank" style="background-color: rgb(255, 255, 255);">Spocklight Notebook</a>. Books on Groovy include:&nbsp;<a href="https://www.manning.com/books/groovy-in-action-second-edition" target="_blank" style="background-color: rgb(255, 255, 255);">Groovy in Action</a>&nbsp;and&nbsp;<a href="https://link.springer.com/book/10.1007/978-1-4842-5058-7" target="_blank" style="background-color: rgb(255, 255, 255);">Learning Groovy 3</a>. If you want general information about using Java and Groovy together, consider&nbsp;<a href="https://www.manning.com/books/making-java-groovy" target="_blank" style="background-color: rgb(255, 255, 255);">Making Java Groovy</a>. And there's a section on mutation testing in&nbsp;<a href="http://kaczanowscy.pl/books/practical_unit_testing_junit_testng_mockito.html" target="_blank">Practical Unit Testing With Testng And Mockito</a>. The most recent book for property testing is for the <a href="https://pragprog.com/titles/fhproper/property-based-testing-with-proper-erlang-and-elixir/" target="_blank">Erlang and Elixir languages</a>.</p>
<h3>Conclusion</h3>
<p>We have looked at testing Java code using Groovy and Spock with some additional tools like Jacoco, jqwik and Pitest. Generally using Groovy to test Java is a straight-forward experience. Groovy also lends itself to writing testing DSLs which allow non-hard-core programmers to write very simple looking tests; but that's a topic for another blog!</p>
