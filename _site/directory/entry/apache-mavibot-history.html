<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Apache Mavibot history | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Apache Mavibot history" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction First of all, let me introduce Apache Mavibot: it&#39;s a MVCC B+ tree library in Java under an AL 2.0 license (MVCC stands for Multi-Version Concurrency Control). The whole idea is to have a B-tree implementation that never crashes, and does not use locks to protect the data against concurrent access (well &hellip; while reading). The B+ tree is a variant of a B-tree, where values are only stored in the leaves, not in internal nodes. Ok. Good. You don&#39;t know much about Mavibot after this introduction, so I&#39;ll dig a bit deeper in this post. Let&#39;s start with the original idea. Apache Directory, CouchDB, and some other databases... Back in 2009, I was attending the Apache Conference in Oakland. I had been working on the Apache Directory project for a bit more than a 4 years and a half. Apache Directory is a LDAP server written in Java, and we chose to store data in B-trees. There was a very limited choice back then, and the library we used - and still use as of today - was JDBM , a java avatar of GDBM. JDBM is written in Java, implements B+trees and has transactions support (experimental), but it has one big drawback: it&#39;s not a cross-B-trees transaction system. And that does not fit our requirement in LDAP. An alternative could have been Berkeley DB &tm;, which released a Java edition of its database, but its license was incompatible with the AL 2.0 license. Moreover Berkeley DB was bought by Oracle in 2006, so it was simply not an option. What&rsquo;s wrong with using JDBM? In LDAP, an update operation impacts one single entry but this entry uses many AttributeTypes, which can be indexed. In other words, an update will impact as many B-trees as we have indexes (and a bit more). In order to guarantee that an entry UPDATE is consistent, we must be sure that either all or none of the indexes have been flushed to disk: otherwise we might end with an inconsistent database, where some indexes are up to date when some other aren&#39;t. &lt;/img&gt; Even worse, in the event of a crash, we might simply not be able to restart the server because the database gets corrupted (and sadly, we are experiencing this problem today...). So in Oakland, I went to the Apache Couch-DB presentation (sadly, the slides are not anymore available), and was struck by the idea behind their database: MVCC. Crucially when you start to use the database at a given revision, you always see everything associated with this revision, up to the point you are done. Sounds like Git or Subversion &hellip; actually, it&#39;s pretty much the same mechanism. Being able to process some read operations on a specific version of the database guarantees that no update will ever corrupt the data being processed. And every time we want to access the database, the very first thing it will do is to select the latest available version: this is all we will see during the operation processing. Perfect when you don&#39;t really care about having a fresh view of the stored data at any time, which is the case in LDAP. But Apache CouchDB was written in Erlang :/ Anyway, the discussion we had with the Directory team was really about moving to a MVCC database. Transactions Transactions are another big missing feature in LDAP. This is not something that was in the air back then: it was specified only one year later. Of course, the original specifications said that every operation is atomic, but there is no requirement for multiple operations to be atomic (and we often need to update two entries in LDAP, and to guarantee that those two operations are either completed, or roll-backed). Think about user/group management... Alex Karasulu always had in mind that we needed a transactional database in Apache Directory, too. And his point was proved correct when years later, we faced the first database corruptions. It&#39;s a bit sad that we ignored this aspect for so long :/ Anyway, we needed (a) transactions and (b) a rock solid database that could resist any type of crash. Locks For some time, we tried to mitigate the consistency problems we had by adding tons of locks. As we weren&#39;t able to protect the database against concurrent reads and writes we made them exclusive (i.e. when some write is processed, no read can be processed). This was slightly better, but it came at a huge cost: a major slowdown when writes were done. Also it was not good enough: long-lasting searches were just killing us, as there were no solution to guarantee that an entry for which we had a reference would still be present in the database when we needed to fetch it. In such cases, we simply ended up by discarding the entry.&nbsp; Last, not least, a crash in the middle of an update operation would leave the database in a potential inconsistent state, which would make it impossible to start again (this was somehow mitigated by adding a &#39;repair&#39; mode lately, but this is just an horrible hack). Mavibot first steps So we needed something better, which turned out to be Mavibot. We started working on Mavibot in June 2012 (Jun 13 00:04:10 2012, exactly). The funny thing is that OpenLDAP started to work on the exact same kind of database 1 year before (LMDB) - even if the discussion about the need for such a database started in 2009. Parallel discussions, parallel developments, we have always shared a lot! The very first released version of Mavibot was out one year later, in June 2013, followed by 7 other versions (all of them milestones). At some point, we added a MVBT partition in ApacheDS, in 2.0.0-M13 (and it was using a SNAPSHOT!!! Mavibot 1.0.0-M1 was used in ApacheDS 2.0.0-M15). This was &#39;good enough&#39; to have the LDAP&lt;/b&lt; server working (and it was 2 to 5 times faster than JDBM, too ;-), but it didn&#39;t offer all we wanted to add: typically, we didn&#39;t have transaction support.&lt;/p&gt; So why isn&rsquo;t Mavibot the Apache Directory Server backend of choice today? Well, we don&#39;t have cross B-tree transactions, so we are pretty much in the same situation as with JDBM (except that it&#39;s faster, and we also have a bulk-loader for Mavibot). Adding cross-B-trees transaction is not a piece of cake, and it requires some thinking. Sadly, it arrived at a moment where the team had less time to work on it (new jobs, family, you name it). So in 2017, the effort has been rebooted, and we do expect to have a working version soon enough! I&#39;ll blog later on about various technical aspects on Apache Mavibot, so keep tuned !" />
<meta property="og:description" content="Introduction First of all, let me introduce Apache Mavibot: it&#39;s a MVCC B+ tree library in Java under an AL 2.0 license (MVCC stands for Multi-Version Concurrency Control). The whole idea is to have a B-tree implementation that never crashes, and does not use locks to protect the data against concurrent access (well &hellip; while reading). The B+ tree is a variant of a B-tree, where values are only stored in the leaves, not in internal nodes. Ok. Good. You don&#39;t know much about Mavibot after this introduction, so I&#39;ll dig a bit deeper in this post. Let&#39;s start with the original idea. Apache Directory, CouchDB, and some other databases... Back in 2009, I was attending the Apache Conference in Oakland. I had been working on the Apache Directory project for a bit more than a 4 years and a half. Apache Directory is a LDAP server written in Java, and we chose to store data in B-trees. There was a very limited choice back then, and the library we used - and still use as of today - was JDBM , a java avatar of GDBM. JDBM is written in Java, implements B+trees and has transactions support (experimental), but it has one big drawback: it&#39;s not a cross-B-trees transaction system. And that does not fit our requirement in LDAP. An alternative could have been Berkeley DB &tm;, which released a Java edition of its database, but its license was incompatible with the AL 2.0 license. Moreover Berkeley DB was bought by Oracle in 2006, so it was simply not an option. What&rsquo;s wrong with using JDBM? In LDAP, an update operation impacts one single entry but this entry uses many AttributeTypes, which can be indexed. In other words, an update will impact as many B-trees as we have indexes (and a bit more). In order to guarantee that an entry UPDATE is consistent, we must be sure that either all or none of the indexes have been flushed to disk: otherwise we might end with an inconsistent database, where some indexes are up to date when some other aren&#39;t. &lt;/img&gt; Even worse, in the event of a crash, we might simply not be able to restart the server because the database gets corrupted (and sadly, we are experiencing this problem today...). So in Oakland, I went to the Apache Couch-DB presentation (sadly, the slides are not anymore available), and was struck by the idea behind their database: MVCC. Crucially when you start to use the database at a given revision, you always see everything associated with this revision, up to the point you are done. Sounds like Git or Subversion &hellip; actually, it&#39;s pretty much the same mechanism. Being able to process some read operations on a specific version of the database guarantees that no update will ever corrupt the data being processed. And every time we want to access the database, the very first thing it will do is to select the latest available version: this is all we will see during the operation processing. Perfect when you don&#39;t really care about having a fresh view of the stored data at any time, which is the case in LDAP. But Apache CouchDB was written in Erlang :/ Anyway, the discussion we had with the Directory team was really about moving to a MVCC database. Transactions Transactions are another big missing feature in LDAP. This is not something that was in the air back then: it was specified only one year later. Of course, the original specifications said that every operation is atomic, but there is no requirement for multiple operations to be atomic (and we often need to update two entries in LDAP, and to guarantee that those two operations are either completed, or roll-backed). Think about user/group management... Alex Karasulu always had in mind that we needed a transactional database in Apache Directory, too. And his point was proved correct when years later, we faced the first database corruptions. It&#39;s a bit sad that we ignored this aspect for so long :/ Anyway, we needed (a) transactions and (b) a rock solid database that could resist any type of crash. Locks For some time, we tried to mitigate the consistency problems we had by adding tons of locks. As we weren&#39;t able to protect the database against concurrent reads and writes we made them exclusive (i.e. when some write is processed, no read can be processed). This was slightly better, but it came at a huge cost: a major slowdown when writes were done. Also it was not good enough: long-lasting searches were just killing us, as there were no solution to guarantee that an entry for which we had a reference would still be present in the database when we needed to fetch it. In such cases, we simply ended up by discarding the entry.&nbsp; Last, not least, a crash in the middle of an update operation would leave the database in a potential inconsistent state, which would make it impossible to start again (this was somehow mitigated by adding a &#39;repair&#39; mode lately, but this is just an horrible hack). Mavibot first steps So we needed something better, which turned out to be Mavibot. We started working on Mavibot in June 2012 (Jun 13 00:04:10 2012, exactly). The funny thing is that OpenLDAP started to work on the exact same kind of database 1 year before (LMDB) - even if the discussion about the need for such a database started in 2009. Parallel discussions, parallel developments, we have always shared a lot! The very first released version of Mavibot was out one year later, in June 2013, followed by 7 other versions (all of them milestones). At some point, we added a MVBT partition in ApacheDS, in 2.0.0-M13 (and it was using a SNAPSHOT!!! Mavibot 1.0.0-M1 was used in ApacheDS 2.0.0-M15). This was &#39;good enough&#39; to have the LDAP&lt;/b&lt; server working (and it was 2 to 5 times faster than JDBM, too ;-), but it didn&#39;t offer all we wanted to add: typically, we didn&#39;t have transaction support.&lt;/p&gt; So why isn&rsquo;t Mavibot the Apache Directory Server backend of choice today? Well, we don&#39;t have cross B-tree transactions, so we are pretty much in the same situation as with JDBM (except that it&#39;s faster, and we also have a bulk-loader for Mavibot). Adding cross-B-trees transaction is not a piece of cake, and it requires some thinking. Sadly, it arrived at a moment where the team had less time to work on it (new jobs, family, you name it). So in 2017, the effort has been rebooted, and we do expect to have a working version soon enough! I&#39;ll blog later on about various technical aspects on Apache Mavibot, so keep tuned !" />
<link rel="canonical" href="http://localhost:4000/directory/entry/apache-mavibot-history" />
<meta property="og:url" content="http://localhost:4000/directory/entry/apache-mavibot-history" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-02-17T05:06:40-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Apache Mavibot history" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2017-02-17T05:06:40-05:00","datePublished":"2017-02-17T05:06:40-05:00","description":"Introduction First of all, let me introduce Apache Mavibot: it&#39;s a MVCC B+ tree library in Java under an AL 2.0 license (MVCC stands for Multi-Version Concurrency Control). The whole idea is to have a B-tree implementation that never crashes, and does not use locks to protect the data against concurrent access (well &hellip; while reading). The B+ tree is a variant of a B-tree, where values are only stored in the leaves, not in internal nodes. Ok. Good. You don&#39;t know much about Mavibot after this introduction, so I&#39;ll dig a bit deeper in this post. Let&#39;s start with the original idea. Apache Directory, CouchDB, and some other databases... Back in 2009, I was attending the Apache Conference in Oakland. I had been working on the Apache Directory project for a bit more than a 4 years and a half. Apache Directory is a LDAP server written in Java, and we chose to store data in B-trees. There was a very limited choice back then, and the library we used - and still use as of today - was JDBM , a java avatar of GDBM. JDBM is written in Java, implements B+trees and has transactions support (experimental), but it has one big drawback: it&#39;s not a cross-B-trees transaction system. And that does not fit our requirement in LDAP. An alternative could have been Berkeley DB &tm;, which released a Java edition of its database, but its license was incompatible with the AL 2.0 license. Moreover Berkeley DB was bought by Oracle in 2006, so it was simply not an option. What&rsquo;s wrong with using JDBM? In LDAP, an update operation impacts one single entry but this entry uses many AttributeTypes, which can be indexed. In other words, an update will impact as many B-trees as we have indexes (and a bit more). In order to guarantee that an entry UPDATE is consistent, we must be sure that either all or none of the indexes have been flushed to disk: otherwise we might end with an inconsistent database, where some indexes are up to date when some other aren&#39;t. &lt;/img&gt; Even worse, in the event of a crash, we might simply not be able to restart the server because the database gets corrupted (and sadly, we are experiencing this problem today...). So in Oakland, I went to the Apache Couch-DB presentation (sadly, the slides are not anymore available), and was struck by the idea behind their database: MVCC. Crucially when you start to use the database at a given revision, you always see everything associated with this revision, up to the point you are done. Sounds like Git or Subversion &hellip; actually, it&#39;s pretty much the same mechanism. Being able to process some read operations on a specific version of the database guarantees that no update will ever corrupt the data being processed. And every time we want to access the database, the very first thing it will do is to select the latest available version: this is all we will see during the operation processing. Perfect when you don&#39;t really care about having a fresh view of the stored data at any time, which is the case in LDAP. But Apache CouchDB was written in Erlang :/ Anyway, the discussion we had with the Directory team was really about moving to a MVCC database. Transactions Transactions are another big missing feature in LDAP. This is not something that was in the air back then: it was specified only one year later. Of course, the original specifications said that every operation is atomic, but there is no requirement for multiple operations to be atomic (and we often need to update two entries in LDAP, and to guarantee that those two operations are either completed, or roll-backed). Think about user/group management... Alex Karasulu always had in mind that we needed a transactional database in Apache Directory, too. And his point was proved correct when years later, we faced the first database corruptions. It&#39;s a bit sad that we ignored this aspect for so long :/ Anyway, we needed (a) transactions and (b) a rock solid database that could resist any type of crash. Locks For some time, we tried to mitigate the consistency problems we had by adding tons of locks. As we weren&#39;t able to protect the database against concurrent reads and writes we made them exclusive (i.e. when some write is processed, no read can be processed). This was slightly better, but it came at a huge cost: a major slowdown when writes were done. Also it was not good enough: long-lasting searches were just killing us, as there were no solution to guarantee that an entry for which we had a reference would still be present in the database when we needed to fetch it. In such cases, we simply ended up by discarding the entry.&nbsp; Last, not least, a crash in the middle of an update operation would leave the database in a potential inconsistent state, which would make it impossible to start again (this was somehow mitigated by adding a &#39;repair&#39; mode lately, but this is just an horrible hack). Mavibot first steps So we needed something better, which turned out to be Mavibot. We started working on Mavibot in June 2012 (Jun 13 00:04:10 2012, exactly). The funny thing is that OpenLDAP started to work on the exact same kind of database 1 year before (LMDB) - even if the discussion about the need for such a database started in 2009. Parallel discussions, parallel developments, we have always shared a lot! The very first released version of Mavibot was out one year later, in June 2013, followed by 7 other versions (all of them milestones). At some point, we added a MVBT partition in ApacheDS, in 2.0.0-M13 (and it was using a SNAPSHOT!!! Mavibot 1.0.0-M1 was used in ApacheDS 2.0.0-M15). This was &#39;good enough&#39; to have the LDAP&lt;/b&lt; server working (and it was 2 to 5 times faster than JDBM, too ;-), but it didn&#39;t offer all we wanted to add: typically, we didn&#39;t have transaction support.&lt;/p&gt; So why isn&rsquo;t Mavibot the Apache Directory Server backend of choice today? Well, we don&#39;t have cross B-tree transactions, so we are pretty much in the same situation as with JDBM (except that it&#39;s faster, and we also have a bulk-loader for Mavibot). Adding cross-B-trees transaction is not a piece of cake, and it requires some thinking. Sadly, it arrived at a moment where the team had less time to work on it (new jobs, family, you name it). So in 2017, the effort has been rebooted, and we do expect to have a working version soon enough! I&#39;ll blog later on about various technical aspects on Apache Mavibot, so keep tuned !","headline":"Apache Mavibot history","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/directory/entry/apache-mavibot-history"},"url":"http://localhost:4000/directory/entry/apache-mavibot-history"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Apache Mavibot history</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-02-17T05:06:40-05:00" itemprop="datePublished">Feb 17, 2017
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Emmanuel Lécharny", "login"=>"elecharny", "email"=>"elecharny@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1>Introduction</h1>
<p>
First of all, let me introduce <b>Apache Mavibot</b>: it's a <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">MVCC</a> <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+<br />
tree</a> library in Java under an <a href="https://www.apache.org/licenses/LICENSE-2.0">AL 2.0 license</a> (<b>MVCC</b> stands for<br />
<em>Multi-Version Concurrency Control</em>). The whole idea is to have a B-tree<br />
implementation that never crashes, and does not use locks to protect the<br />
data against concurrent access (well &hellip; while reading).</p>
<p>
The B+ tree is a variant of a B-tree, where values are only stored in<br />
the leaves, not in internal nodes.</p>
<p>
Ok. Good. You don't know much about Mavibot after this introduction, so<br />
I'll dig a bit deeper in this post. Let's start with the original idea.</p>
<h2>Apache Directory, CouchDB, and some other databases...</h2>
<p>
Back in 2009, I was attending the <a href="http://archive.apachecon.com/c/acus2009/">Apache Conference in Oakland</a>. I had been<br />
working on the <a href="http://directory.apache.org">Apache Directory project</a> for a bit more than a 4 years<br />
and a half. <em>Apache Directory</em> is a <b>LDAP</b> server written in Java, and we<br />
chose to store data in B-trees. There was a very limited choice back<br />
then, and the library we used - and still use as of today - was <a href="http://jdbm.sourceforge.net/">JDBM<br />
</a>, a java avatar of <a href="http://www.gnu.org.ua/software/gdbm/">GDBM</a>.</p>
<p>
<b>JDBM</b> is written in Java, implements <b>B+trees</b> and has transactions support<br />
(experimental), but it has one big drawback: it's not a cross-B-trees<br />
transaction system. And that does not fit our requirement in <b>LDAP</b>.</p>
<p>
An alternative could have been <b>Berkeley DB &tm;</b>, which released a Java<br />
edition of its database, but its license was incompatible with the AL<br />
2.0 license. Moreover Berkeley DB was bought by <b>Oracle</b> in 2006, so it was<br />
simply not an option.</p>
<h2>What&rsquo;s wrong with using JDBM?</h2>
<p>
In <b>LDAP</b>, an update operation impacts one single entry but this entry<br />
uses many <em>AttributeTypes</em>, which can be indexed. In other words, an<br />
update will impact as many B-trees as we have indexes (and a bit more).<br />
In order to guarantee that an entry UPDATE is consistent, we must be<br />
sure that either all or none of the indexes have been flushed to disk:<br />
otherwise we might end with an inconsistent database, where some indexes<br />
are up to date when some other aren't.</p>
<p><a href="https://blogs.apache.org/directory/mediaresource/847a2aa6-dce8-4d6f-9a65-79c74219d785"><img src="https://blogs.apache.org/directory/mediaresource/847a2aa6-dce8-4d6f-9a65-79c74219d785" alt="indexeldap.png" height="50%" width="50%"></img></a></p>
<p>
Even worse, in the event of a crash, we might simply not be able<br />
to restart the server because the database gets corrupted (and<br />
sadly, we are experiencing this problem today...).</p>
<p>
So in <b>Oakland</b>, I went to the <a href="http://couchdb.apache.org/">Apache Couch-DB</a> presentation (sadly,<br />
the slides are not anymore available), and was struck by the idea behind<br />
their database: <b>MVCC</b>. Crucially when you start to use the<br />
database at a given revision, you always see everything associated with<br />
this revision, up to the point you are done. Sounds like <b>Git</b> or<br />
<b>Subversion</b> &hellip; actually, it's pretty much the same mechanism.</p>
<p>
Being able to process some read operations on a specific version of the<br />
database guarantees that no update will ever corrupt the data being<br />
processed. And every time we want to access the database, the very first<br />
thing it will do is to select the latest available version: this is<br />
all we will see during the operation processing. Perfect when you don't really care about having a fresh view of the stored data at any time, which is the case in <b>LDAP</b>.</p>
<p>
But <b>Apache CouchDB</b> was written in <b>Erlang</b> :/ Anyway, the discussion we<br />
had with the Directory team was really about moving to a <b>MVCC</b> database.</p>
<h2>Transactions</h2>
<p>
Transactions are another big missing feature in <b>LDAP</b>. This is not something that was<br />
in the air back then: it was specified only <a href="https://tools.ietf.org/html/rfc5805">one year later</a>. Of course, the original specifications said that every operation is atomic, but there is no requirement for multiple operations to be atomic (and we often need to update two entries in <b>LDAP</b>, and to guarantee that those two operations are either completed, or<br />
roll-backed). Think about user/group management...</p>
<p>
<b>Alex Karasulu</b> always had in mind that we needed a transactional database<br />
in Apache Directory, too. And his point was proved correct when years<br />
later, we faced the first database corruptions. It's a bit sad that we<br />
ignored this aspect for so long :/</p>
<p>
Anyway, we needed (a) transactions and (b) a rock solid database that could<br />
resist any type of crash.</p>
<h2>Locks</h2>
<p>
For some time, we tried to mitigate the consistency problems we had by<br />
adding tons of locks. As we weren't able to protect the database against<br />
concurrent reads and writes we made them exclusive (i.e.<br />
when some write is processed, no read can be processed). This was<br />
slightly better, but it came at a huge cost: a major slowdown when<br />
writes were done. Also it was not good enough: long-lasting searches<br />
were just killing us, as there were no solution to guarantee that an<br />
entry for which we had a reference would still be present in the database<br />
when we needed to fetch it. In such cases, we simply ended up by<br />
discarding the entry.&nbsp; Last, not least, a crash in the middle of an<br />
update operation would leave the database in a potential inconsistent<br />
state, which would make it impossible to start again (this was somehow<br />
mitigated by adding a 'repair' mode lately, but this is just an horrible<br />
hack).</p>
<h2>Mavibot first steps</h2>
<p>
So we needed something better, which turned out to be <b>Mavibot</b>. We started working<br />
on Mavibot in June 2012 (<a href="http://svn.apache.org/viewvc/labs/mavibot/README.txt?revision=1349589&view=markup&pathrev=1349589">Jun 13 00:04:10 2012, exactly</a>).</p>
<p>
The funny thing is that <b>OpenLDAP</b> started to work on the exact same kind<br />
of database 1 year before (<a href="http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=commit;h=d620d4368a7ee17d60f2b381d4c80b22c68ba8e2">LMDB</a>) - even if the <a href="http://marc.info/?l=openldap-devel&m=124253456912512">discussion about the<br />
need for such a database started in 2009</a>. Parallel discussions,<br />
parallel developments, we have always shared a lot!</p>
<p>
The very first released version of <b>Mavibot</b> was out one year later, in<br />
June 2013, followed by 7 other versions (all of them milestones). At<br />
some point, we added a <b>MVBT</b> partition in <b>ApacheDS</b>, in 2.0.0-M13 (and it<br />
was using a SNAPSHOT!!! Mavibot 1.0.0-M1 was used in <b>ApacheDS</b><br />
2.0.0-M15). This was 'good enough' to have the <b>LDAP</b< server working (and<br />
it was 2 to 5 times faster than <b>JDBM</b>, too ;-), but it didn't offer all<br />
we wanted to add: typically, we didn't have transaction support.</p>
<p>
So why isn&rsquo;t <b>Mavibot</b> the <b>Apache Directory Server</b> backend of choice today?</p>
<p>
Well, we don't have cross B-tree transactions, so we are pretty much in<br />
the same situation as with <b>JDBM</b> (except that it's faster, and we also<br />
have a bulk-loader for <b>Mavibot</b>). Adding cross-B-trees transaction is not<br />
a piece of cake, and it requires some thinking. Sadly, it arrived at a<br />
moment where the team had less time to work on it (new jobs, family,<br />
you name it).</p>
<p>
So in 2017, the effort has been rebooted, and we do expect to have a<br />
working version soon enough!</p>
<p>
I'll blog later on about various technical aspects on <b>Apache Mavibot</b>, so keep tuned !</p>

  </div><a class="u-url" href="/directory/entry/apache-mavibot-history" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
