<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Encryption and decryption with Groovy | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Encryption and decryption with Groovy" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Inspired by this recent blog entry, here is an example showing how to encrypt and decrypt with Groovy. Using the JDK crypto classes First, we need some text to encrypt. We&#39;ll use an excerpt of the one from the aforementioned blog post: var text = &#39;Contrary to popular belief, Lorem Ipsum is not simply random text.\ It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old.&#39; Next, we&#39;ll create a factory for our cipher instance, generate a key, and set up an initialization vector. First, the cipher factory: var factory = { Cipher.getInstance(&#39;AES/CBC/PKCS5Padding&#39;) } For our cipher algorithm, we are using the Advanced Encryption Standard (AES) algorithm, in Cipher Block Chaining (CBC) mode, with PKCS5 padding. We&#39;ll look at other options later. Next we generate our secret key. Our secret key is our password. Only someone who has the password will be able to decrypt the encrypted message. We could use any random bits for our key, but like passwords, we want to choose a strong key rather than a weak one. Cryptographic libraries provide classes to generate such keys. We just need to provide the key size. AES supports 128, 192 and 256 bit keys. We&#39;ll choose 192 here: var key = generateKey(&#39;AES&#39;, 192) Our code uses this helper method: def generateKey(String algorithm, Integer size) { var generator = KeyGenerator.getInstance(algorithm) generator.init(size) generator.generateKey()} Next, we generate an initialization vector: var ivParameterSpec = randomParameterSpec(factory) It uses this helper method (we&#39;re using the algorithm block size for our initialization vector size): def randomParameterSpec(Closure factory) { var block = new byte[factory().blockSize] SecureRandom.instanceStrong.nextBytes(block) new IvParameterSpec(block)}&lt;/pre&gt; An&nbsp;initialization vector&nbsp;is used to introduce some additional randomness to avoid repeating patterns in the input leading to repeating patterns in the encrypted bytes. With all these things in place, we are almost ready to encrypt or decrypt, but first, let&#39;s define two more helper methods: def encrypt(byte[] bytes, Key key, IvParameterSpec spec, Closure factory) { var cipher = factory() cipher.init(ENCRYPT_MODE, key, spec) cipher.doFinal(bytes)}def decrypt(byte[] bytes, Key key, IvParameterSpec spec, Closure factory) { var cipher = factory() cipher.init(DECRYPT_MODE, key, spec) cipher.doFinal(bytes)}&lt;/pre&gt; &lt;/div&gt; And here is how we encrypt and decrypt: var encrypted = encrypt(text.bytes, key, ivParameterSpec, factory)println &quot;Encrypted bytes : $encrypted&quot;println &quot;Encrypted text : ${new String(encrypted)}&quot;var decrypted = decrypt(encrypted, key, ivParameterSpec, factory)println &quot;Decrypted bytes : $decrypted&quot;println &quot;Decrypted text : ${new String(decrypted)}&quot; Which has this output: Encrypted bytes : [-117, 36, 18, 69, -101, -8, 35, 93, -102, -49, -12, ..., -19, -100] Encrypted text : &lsaquo;$E&rsaquo;&oslash;#]&scaron;&Iuml;&ocirc;&aelig;&rdquo;&Aacute;&tilde;&ccedil;p^&micro;&amp;sup3;=L(&Ouml;^_&OElig;C&gt;CI&Euml;&bdquo;&ouml;,1&Eacute;8&AElig;&Yuml;.&Scaron;?v&szlig;G,&Egrave;w&permil;&aring;&amp;frac14;z&Uuml;f&gt;?&micro;&rsaquo;D&amp;sup1;&eacute;&AElig;k&euro; &deg;&tilde;2&ecirc;&Ocirc;}&iacute;&copy;&agrave;hl$&gt;?&amp;sup1;&iexcl;K&aring;3&Ocirc;O?&plusmn;&amp;&hellip;&ecirc;&icirc;&para;&Ecirc;&ndash;&amp;frac34;&deg;&reg;q&reg;&agrave;&mdash;0&uacute;&lsquo;&Ocirc;hO&lt;H&brvbar;&ccedil;&reg;&Ccedil;&rdquo;&Egrave;hA&euml;j&oacute; QPy&fnof;y6&Auml;&curren;*&acute;un&amp;frac14;&iuml;&macr;m&uml;&acute;&Ugrave;jeJt&euml;&ordm;\&oacute;6&AElig;&ordf;K&ordf;&oelig;&iacute;&oelig; Decrypted bytes : [67, 111, 110, 116, 114, 97, 114, 121, 32, 116, 111, 32, ..., 100, 46] Decrypted text : Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. We can see that everything worked as expected, since the final output matches our original input text. Using the Bouncy Castle library We can alternatively, swap algorithms. There are numerous algorithms and modes supported by the JDK and others supported by third-party libraries. A nice summary can be found here. We&#39;ll swap to use the CAST5 (CAST-128) algorithm which supports up to a 128-bit key. We&#39;ll use HMAC-SHA1 to generate our key. import org.bouncycastle.jce.provider.BouncyCastleProvidervar bc = new BouncyCastleProvider()factory = { Cipher.getInstance(&#39;CAST5&#39;, bc) }key = generateKey(&#39;HmacSHA1&#39;, 128)ivParameterSpec = randomParameterSpec(factory) CAST5 is the default algorithm used in some versions of GPG and PGP. It isn&#39;t included by default in the JDK, so for this we&#39;ll use the Bouncy Castle library. [Just as a note. If you are wanting to encrypt or decrypt GPG/PGP files, don&#39;t use the above code. Libraries like Bouncy Castle have dedicated classes for such scenarios.] We now encrypt and decrypt as before: encrypted = encrypt(text.bytes, key, ivParameterSpec, factory)println &quot;Encrypted text : ${new String(encrypted)}&quot;decrypted = decrypt(encrypted, key, ivParameterSpec, factory)println &quot;Decrypted text : ${new String(decrypted)}&quot; Which has this output: Encrypted text : M&ordf;&aacute;?r?v9&pound;&divide;~4&micro;T&#39;&rsaquo;&Ugrave;&Yacute;&Aacute;l&iquest;&THORN;g&amp;frac34;0&ntilde;≈Ω&iexcl;?&Uuml;=&amp;sup3;9Q&not;&raquo;3&laquo;&Ouml;&Aacute;&iexcl;&micro; &amp;frac34;@4&divide;`F&ntilde;&Ugrave;&Scaron;f&oslash;7&yen;#&rsaquo;v&curren;&Iacute;&ndash;&permil;&amp;frac14;&Uuml;&cent;&fnof;E6&ocirc;≈ΩT&Ugrave;l&aelig;&Iuml;z&gt;o?&agrave;L&rsaquo;&iexcl;&cent;z1n&Ouml;o9]&scaron;O&Ocirc;&amp;frac14;S&Ocirc;O&Iacute;#&Yacute;7L&oelig;&Agrave;&icirc;}&oacute;5m%q&bull;&raquo;l% /AWT&acute;&cent;zH#t&igrave;&dagger;&plusmn;l&para;&pound;&mdash;&OElig; &laquo;&copy;w&circ;&Atilde;&reg;&gt;&reg;&Uuml;6&euml;r-E Decrypted text : Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. Other useful functionality Passing around binary data like our secret key or the encrypted data, has its own problems. Groovy provides extension methods to encode such data (and corresponding decode methods). For example, we can encode our secret key in various ways: var keyBytes = key.encodedprintln keyBytes.encodeHex()println keyBytes.encodeBase64()println keyBytes.encodeBase64Url() Which has this output (the key is random, so the output will differ for each run): 85a0d3f0ce0cbe6402dc9579fbffcf1d haDT8M4MvmQC3JV5+//PHQ== haDT8M4MvmQC3JV5-__PHQ Groovy also provides extension methods for various checksums (but you might want to look at stronger checksum algorithms in security sensitive scenarios): println &quot;SHA256 : ${text.sha256()}&quot;println &quot;MD5 : ${text.md5()}&quot; Which has this output: SHA256 : ccb184e35e4c32bafc730d84ec924ea2980035ea5fadb012e3b2b31abf4323c9 MD5 : 46c61a174c2dc99204521ca89f09f63c If you are encrypting and decrypting entire files, the JDK has special classes for that too which are also easy to use from Groovy. That&#39;s all for now. References Comparison of cryptography libraries&nbsp;(Wikipedia) How to encrypt and decrypt data in java&nbsp;(also on medium.com) Bouncy castle in maven central AES Encryption and Decryption&nbsp;in Java (Baeldung) Initialization Vector for Encryption in Java (Baeldung) 3DES in Java (Baeldung) Conclusion We have taken a brief look at encrypting and decrypting with Apache Groovy." />
<meta property="og:description" content="Inspired by this recent blog entry, here is an example showing how to encrypt and decrypt with Groovy. Using the JDK crypto classes First, we need some text to encrypt. We&#39;ll use an excerpt of the one from the aforementioned blog post: var text = &#39;Contrary to popular belief, Lorem Ipsum is not simply random text.\ It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old.&#39; Next, we&#39;ll create a factory for our cipher instance, generate a key, and set up an initialization vector. First, the cipher factory: var factory = { Cipher.getInstance(&#39;AES/CBC/PKCS5Padding&#39;) } For our cipher algorithm, we are using the Advanced Encryption Standard (AES) algorithm, in Cipher Block Chaining (CBC) mode, with PKCS5 padding. We&#39;ll look at other options later. Next we generate our secret key. Our secret key is our password. Only someone who has the password will be able to decrypt the encrypted message. We could use any random bits for our key, but like passwords, we want to choose a strong key rather than a weak one. Cryptographic libraries provide classes to generate such keys. We just need to provide the key size. AES supports 128, 192 and 256 bit keys. We&#39;ll choose 192 here: var key = generateKey(&#39;AES&#39;, 192) Our code uses this helper method: def generateKey(String algorithm, Integer size) { var generator = KeyGenerator.getInstance(algorithm) generator.init(size) generator.generateKey()} Next, we generate an initialization vector: var ivParameterSpec = randomParameterSpec(factory) It uses this helper method (we&#39;re using the algorithm block size for our initialization vector size): def randomParameterSpec(Closure factory) { var block = new byte[factory().blockSize] SecureRandom.instanceStrong.nextBytes(block) new IvParameterSpec(block)}&lt;/pre&gt; An&nbsp;initialization vector&nbsp;is used to introduce some additional randomness to avoid repeating patterns in the input leading to repeating patterns in the encrypted bytes. With all these things in place, we are almost ready to encrypt or decrypt, but first, let&#39;s define two more helper methods: def encrypt(byte[] bytes, Key key, IvParameterSpec spec, Closure factory) { var cipher = factory() cipher.init(ENCRYPT_MODE, key, spec) cipher.doFinal(bytes)}def decrypt(byte[] bytes, Key key, IvParameterSpec spec, Closure factory) { var cipher = factory() cipher.init(DECRYPT_MODE, key, spec) cipher.doFinal(bytes)}&lt;/pre&gt; &lt;/div&gt; And here is how we encrypt and decrypt: var encrypted = encrypt(text.bytes, key, ivParameterSpec, factory)println &quot;Encrypted bytes : $encrypted&quot;println &quot;Encrypted text : ${new String(encrypted)}&quot;var decrypted = decrypt(encrypted, key, ivParameterSpec, factory)println &quot;Decrypted bytes : $decrypted&quot;println &quot;Decrypted text : ${new String(decrypted)}&quot; Which has this output: Encrypted bytes : [-117, 36, 18, 69, -101, -8, 35, 93, -102, -49, -12, ..., -19, -100] Encrypted text : &lsaquo;$E&rsaquo;&oslash;#]&scaron;&Iuml;&ocirc;&aelig;&rdquo;&Aacute;&tilde;&ccedil;p^&micro;&amp;sup3;=L(&Ouml;^_&OElig;C&gt;CI&Euml;&bdquo;&ouml;,1&Eacute;8&AElig;&Yuml;.&Scaron;?v&szlig;G,&Egrave;w&permil;&aring;&amp;frac14;z&Uuml;f&gt;?&micro;&rsaquo;D&amp;sup1;&eacute;&AElig;k&euro; &deg;&tilde;2&ecirc;&Ocirc;}&iacute;&copy;&agrave;hl$&gt;?&amp;sup1;&iexcl;K&aring;3&Ocirc;O?&plusmn;&amp;&hellip;&ecirc;&icirc;&para;&Ecirc;&ndash;&amp;frac34;&deg;&reg;q&reg;&agrave;&mdash;0&uacute;&lsquo;&Ocirc;hO&lt;H&brvbar;&ccedil;&reg;&Ccedil;&rdquo;&Egrave;hA&euml;j&oacute; QPy&fnof;y6&Auml;&curren;*&acute;un&amp;frac14;&iuml;&macr;m&uml;&acute;&Ugrave;jeJt&euml;&ordm;\&oacute;6&AElig;&ordf;K&ordf;&oelig;&iacute;&oelig; Decrypted bytes : [67, 111, 110, 116, 114, 97, 114, 121, 32, 116, 111, 32, ..., 100, 46] Decrypted text : Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. We can see that everything worked as expected, since the final output matches our original input text. Using the Bouncy Castle library We can alternatively, swap algorithms. There are numerous algorithms and modes supported by the JDK and others supported by third-party libraries. A nice summary can be found here. We&#39;ll swap to use the CAST5 (CAST-128) algorithm which supports up to a 128-bit key. We&#39;ll use HMAC-SHA1 to generate our key. import org.bouncycastle.jce.provider.BouncyCastleProvidervar bc = new BouncyCastleProvider()factory = { Cipher.getInstance(&#39;CAST5&#39;, bc) }key = generateKey(&#39;HmacSHA1&#39;, 128)ivParameterSpec = randomParameterSpec(factory) CAST5 is the default algorithm used in some versions of GPG and PGP. It isn&#39;t included by default in the JDK, so for this we&#39;ll use the Bouncy Castle library. [Just as a note. If you are wanting to encrypt or decrypt GPG/PGP files, don&#39;t use the above code. Libraries like Bouncy Castle have dedicated classes for such scenarios.] We now encrypt and decrypt as before: encrypted = encrypt(text.bytes, key, ivParameterSpec, factory)println &quot;Encrypted text : ${new String(encrypted)}&quot;decrypted = decrypt(encrypted, key, ivParameterSpec, factory)println &quot;Decrypted text : ${new String(decrypted)}&quot; Which has this output: Encrypted text : M&ordf;&aacute;?r?v9&pound;&divide;~4&micro;T&#39;&rsaquo;&Ugrave;&Yacute;&Aacute;l&iquest;&THORN;g&amp;frac34;0&ntilde;≈Ω&iexcl;?&Uuml;=&amp;sup3;9Q&not;&raquo;3&laquo;&Ouml;&Aacute;&iexcl;&micro; &amp;frac34;@4&divide;`F&ntilde;&Ugrave;&Scaron;f&oslash;7&yen;#&rsaquo;v&curren;&Iacute;&ndash;&permil;&amp;frac14;&Uuml;&cent;&fnof;E6&ocirc;≈ΩT&Ugrave;l&aelig;&Iuml;z&gt;o?&agrave;L&rsaquo;&iexcl;&cent;z1n&Ouml;o9]&scaron;O&Ocirc;&amp;frac14;S&Ocirc;O&Iacute;#&Yacute;7L&oelig;&Agrave;&icirc;}&oacute;5m%q&bull;&raquo;l% /AWT&acute;&cent;zH#t&igrave;&dagger;&plusmn;l&para;&pound;&mdash;&OElig; &laquo;&copy;w&circ;&Atilde;&reg;&gt;&reg;&Uuml;6&euml;r-E Decrypted text : Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. Other useful functionality Passing around binary data like our secret key or the encrypted data, has its own problems. Groovy provides extension methods to encode such data (and corresponding decode methods). For example, we can encode our secret key in various ways: var keyBytes = key.encodedprintln keyBytes.encodeHex()println keyBytes.encodeBase64()println keyBytes.encodeBase64Url() Which has this output (the key is random, so the output will differ for each run): 85a0d3f0ce0cbe6402dc9579fbffcf1d haDT8M4MvmQC3JV5+//PHQ== haDT8M4MvmQC3JV5-__PHQ Groovy also provides extension methods for various checksums (but you might want to look at stronger checksum algorithms in security sensitive scenarios): println &quot;SHA256 : ${text.sha256()}&quot;println &quot;MD5 : ${text.md5()}&quot; Which has this output: SHA256 : ccb184e35e4c32bafc730d84ec924ea2980035ea5fadb012e3b2b31abf4323c9 MD5 : 46c61a174c2dc99204521ca89f09f63c If you are encrypting and decrypting entire files, the JDK has special classes for that too which are also easy to use from Groovy. That&#39;s all for now. References Comparison of cryptography libraries&nbsp;(Wikipedia) How to encrypt and decrypt data in java&nbsp;(also on medium.com) Bouncy castle in maven central AES Encryption and Decryption&nbsp;in Java (Baeldung) Initialization Vector for Encryption in Java (Baeldung) 3DES in Java (Baeldung) Conclusion We have taken a brief look at encrypting and decrypting with Apache Groovy." />
<link rel="canonical" href="http://localhost:4000/groovy/entry/encryption-and-decryption-with-groovy" />
<meta property="og:url" content="http://localhost:4000/groovy/entry/encryption-and-decryption-with-groovy" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-09-19T14:34:39-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Encryption and decryption with Groovy" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-19T14:34:39-04:00","datePublished":"2022-09-19T14:34:39-04:00","description":"Inspired by this recent blog entry, here is an example showing how to encrypt and decrypt with Groovy. Using the JDK crypto classes First, we need some text to encrypt. We&#39;ll use an excerpt of the one from the aforementioned blog post: var text = &#39;Contrary to popular belief, Lorem Ipsum is not simply random text.\\ It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old.&#39; Next, we&#39;ll create a factory for our cipher instance, generate a key, and set up an initialization vector. First, the cipher factory: var factory = { Cipher.getInstance(&#39;AES/CBC/PKCS5Padding&#39;) } For our cipher algorithm, we are using the Advanced Encryption Standard (AES) algorithm, in Cipher Block Chaining (CBC) mode, with PKCS5 padding. We&#39;ll look at other options later. Next we generate our secret key. Our secret key is our password. Only someone who has the password will be able to decrypt the encrypted message. We could use any random bits for our key, but like passwords, we want to choose a strong key rather than a weak one. Cryptographic libraries provide classes to generate such keys. We just need to provide the key size. AES supports 128, 192 and 256 bit keys. We&#39;ll choose 192 here: var key = generateKey(&#39;AES&#39;, 192) Our code uses this helper method: def generateKey(String algorithm, Integer size) { var generator = KeyGenerator.getInstance(algorithm) generator.init(size) generator.generateKey()} Next, we generate an initialization vector: var ivParameterSpec = randomParameterSpec(factory) It uses this helper method (we&#39;re using the algorithm block size for our initialization vector size): def randomParameterSpec(Closure factory) { var block = new byte[factory().blockSize] SecureRandom.instanceStrong.nextBytes(block) new IvParameterSpec(block)}&lt;/pre&gt; An&nbsp;initialization vector&nbsp;is used to introduce some additional randomness to avoid repeating patterns in the input leading to repeating patterns in the encrypted bytes. With all these things in place, we are almost ready to encrypt or decrypt, but first, let&#39;s define two more helper methods: def encrypt(byte[] bytes, Key key, IvParameterSpec spec, Closure factory) { var cipher = factory() cipher.init(ENCRYPT_MODE, key, spec) cipher.doFinal(bytes)}def decrypt(byte[] bytes, Key key, IvParameterSpec spec, Closure factory) { var cipher = factory() cipher.init(DECRYPT_MODE, key, spec) cipher.doFinal(bytes)}&lt;/pre&gt; &lt;/div&gt; And here is how we encrypt and decrypt: var encrypted = encrypt(text.bytes, key, ivParameterSpec, factory)println &quot;Encrypted bytes : $encrypted&quot;println &quot;Encrypted text : ${new String(encrypted)}&quot;var decrypted = decrypt(encrypted, key, ivParameterSpec, factory)println &quot;Decrypted bytes : $decrypted&quot;println &quot;Decrypted text : ${new String(decrypted)}&quot; Which has this output: Encrypted bytes : [-117, 36, 18, 69, -101, -8, 35, 93, -102, -49, -12, ..., -19, -100] Encrypted text : &lsaquo;$\u0012E&rsaquo;&oslash;#]&scaron;&Iuml;&ocirc;&aelig;&rdquo;&Aacute;&tilde;&ccedil;p^&micro;&amp;sup3;=L(&Ouml;^_&OElig;C&gt;CI&Euml;&bdquo;&ouml;,1&Eacute;8&AElig;\u0005&Yuml;.&Scaron;?\u0013v&szlig;G,&Egrave;w&permil;&aring;&amp;frac14;z&Uuml;f&gt;?&micro;\u001b&rsaquo;D&amp;sup1;\u0004&eacute;&AElig;k&euro; &deg;&tilde;2&ecirc;&Ocirc;}&iacute;&copy;&agrave;hl$&gt;?&amp;sup1;&iexcl;K&aring;3&Ocirc;O\u0013?&plusmn;&amp;&hellip;&ecirc;&icirc;&para;&Ecirc;&ndash;\b&amp;frac34;&deg;&reg;q&reg;&agrave;&mdash;0\u001a&uacute;&lsquo;\u001a&Ocirc;hO&lt;\u0010H&brvbar;&ccedil;&reg;\b&Ccedil;\u0018&rdquo;&Egrave;hA&euml;j&oacute; QPy&fnof;y6&Auml;&curren;*&acute;un&amp;frac14;&iuml;&macr;m&uml;&acute;&Ugrave;\u0016j\beJt\u0001&euml;&ordm;\\&oacute;6\u001e&AElig;&ordf;K&ordf;&oelig;&iacute;&oelig; Decrypted bytes : [67, 111, 110, 116, 114, 97, 114, 121, 32, 116, 111, 32, ..., 100, 46] Decrypted text : Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. We can see that everything worked as expected, since the final output matches our original input text. Using the Bouncy Castle library We can alternatively, swap algorithms. There are numerous algorithms and modes supported by the JDK and others supported by third-party libraries. A nice summary can be found here. We&#39;ll swap to use the CAST5 (CAST-128) algorithm which supports up to a 128-bit key. We&#39;ll use HMAC-SHA1 to generate our key. import org.bouncycastle.jce.provider.BouncyCastleProvidervar bc = new BouncyCastleProvider()factory = { Cipher.getInstance(&#39;CAST5&#39;, bc) }key = generateKey(&#39;HmacSHA1&#39;, 128)ivParameterSpec = randomParameterSpec(factory) CAST5 is the default algorithm used in some versions of GPG and PGP. It isn&#39;t included by default in the JDK, so for this we&#39;ll use the Bouncy Castle library. [Just as a note. If you are wanting to encrypt or decrypt GPG/PGP files, don&#39;t use the above code. Libraries like Bouncy Castle have dedicated classes for such scenarios.] We now encrypt and decrypt as before: encrypted = encrypt(text.bytes, key, ivParameterSpec, factory)println &quot;Encrypted text : ${new String(encrypted)}&quot;decrypted = decrypt(encrypted, key, ivParameterSpec, factory)println &quot;Decrypted text : ${new String(decrypted)}&quot; Which has this output: Encrypted text : M&ordf;&aacute;?r?v9&pound;&divide;~4&micro;T&#39;&rsaquo;&Ugrave;&Yacute;&Aacute;l\u001b&iquest;&THORN;\u000fg&amp;frac34;0&ntilde;\u0013≈Ω&iexcl;?&Uuml;=&amp;sup3;9\u001eQ&not;&raquo;3&laquo;&Ouml;&Aacute;&iexcl;&micro; &amp;frac34;@4&divide;`F&ntilde;&Ugrave;&Scaron;f&oslash;7&yen;#&rsaquo;v&curren;&Iacute;&ndash;&permil;&amp;frac14;&Uuml;&cent;&fnof;E6&ocirc;\u001f≈ΩT&Ugrave;l&aelig;&Iuml;\u0017\u000ez&gt;o\u000e?&agrave;L&rsaquo;&iexcl;&cent;z1n&Ouml;o9\u0017]&scaron;O&Ocirc;&amp;frac14;S&Ocirc;O&Iacute;#&Yacute;7L&oelig;&Agrave;\u0011&icirc;}&oacute;5m%q&bull;\u0001&raquo;l% /AW\u0011T&acute;&cent;zH#t&igrave;&dagger;&plusmn;l&para;&pound;&mdash;&OElig; &laquo;&copy;w\u0002&circ;&Atilde;&reg;&gt;&reg;&Uuml;6&euml;r-E Decrypted text : Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. Other useful functionality Passing around binary data like our secret key or the encrypted data, has its own problems. Groovy provides extension methods to encode such data (and corresponding decode methods). For example, we can encode our secret key in various ways: var keyBytes = key.encodedprintln keyBytes.encodeHex()println keyBytes.encodeBase64()println keyBytes.encodeBase64Url() Which has this output (the key is random, so the output will differ for each run): 85a0d3f0ce0cbe6402dc9579fbffcf1d haDT8M4MvmQC3JV5+//PHQ== haDT8M4MvmQC3JV5-__PHQ Groovy also provides extension methods for various checksums (but you might want to look at stronger checksum algorithms in security sensitive scenarios): println &quot;SHA256 : ${text.sha256()}&quot;println &quot;MD5 : ${text.md5()}&quot; Which has this output: SHA256 : ccb184e35e4c32bafc730d84ec924ea2980035ea5fadb012e3b2b31abf4323c9 MD5 : 46c61a174c2dc99204521ca89f09f63c If you are encrypting and decrypting entire files, the JDK has special classes for that too which are also easy to use from Groovy. That&#39;s all for now. References Comparison of cryptography libraries&nbsp;(Wikipedia) How to encrypt and decrypt data in java&nbsp;(also on medium.com) Bouncy castle in maven central AES Encryption and Decryption&nbsp;in Java (Baeldung) Initialization Vector for Encryption in Java (Baeldung) 3DES in Java (Baeldung) Conclusion We have taken a brief look at encrypting and decrypting with Apache Groovy.","headline":"Encryption and decryption with Groovy","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/groovy/entry/encryption-and-decryption-with-groovy"},"url":"http://localhost:4000/groovy/entry/encryption-and-decryption-with-groovy"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Encryption and decryption with Groovy</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-09-19T14:34:39-04:00" itemprop="datePublished">Sep 19, 2022
      </time>‚Ä¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Paul King", "login"=>"paulk", "email"=>"paulk@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Inspired by this <a href="https://asyncq.com/how-to-encrypt-and-decrypt-data-in-java" target="_blank">recent blog entry</a>, here is an example showing how to encrypt and decrypt with Groovy.</p>
<h3>Using the JDK crypto classes</h3>
<p>First, we need some text to encrypt. We'll use an excerpt of the one from the aforementioned blog post:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>text = <span style="color:#6a8759;">'Contrary to popular belief, Lorem Ipsum is not simply random text.</span><span style="color:#cc7832;">\<br></span><span style="color:#6a8759;"> It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old.'<br></span></pre>
<p>Next, we'll create a factory for our cipher instance, generate a key, and set up an initialization vector.</p>
<p>First, the cipher factory:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>factory = <span style="font-weight:bold;">{ </span>Cipher.<span style="color:#9876aa;font-style:italic;">getInstance</span>(<span style="color:#6a8759;">'AES/CBC/PKCS5Padding'</span>) <span style="font-weight:bold;">}</span><br></pre>
<p>For our cipher algorithm, we are using the Advanced Encryption Standard (<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" target="_blank">AES</a>) algorithm, in Cipher Block Chaining (<a href="https://www.highgo.ca/2019/08/08/the-difference-in-five-modes-in-the-aes-encryption-algorithm/" target="_blank">CBC</a>) mode, with <a href="https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS#5_and_PKCS#7" target="_blank">PKCS5 padding</a>. We'll look at other options later.</p>
<p>Next we generate our secret key. Our secret key is our password. Only someone who has the password will be able to decrypt the encrypted message. We could use any random bits for our key, but like passwords, we want to choose a strong key rather than a weak one. Cryptographic libraries provide classes to generate such keys. We just need to provide the key size. AES supports 128, 192 and 256 bit keys. We'll choose 192 here:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>key = generateKey(<span style="color:#6a8759;">'AES'</span>, <span style="color:#6897bb;">192</span>)<br></pre>
<p>Our code uses this helper method:<br></p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>generateKey(String algorithm, Integer size) {<br>    <span style="color:#cc7832;">var </span>generator = KeyGenerator.<span style="color:#9876aa;font-style:italic;">getInstance</span>(algorithm)<br>    generator.init(size)<br>    generator.generateKey()<br>}<br></pre>
<p>Next, we generate an initialization vector:<br></p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>ivParameterSpec = randomParameterSpec(factory)<br></pre>
<p>It uses this helper method (we're using the algorithm block size for our initialization vector size):</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>randomParameterSpec(Closure<Cipher> factory) {<br>    <span style="color:#cc7832;">var </span>block = <span style="color:#cc7832;">new byte</span>[factory().<span style="color:#9876aa;">blockSize</span>]<br>    SecureRandom.<span style="color:#9876aa;font-style:italic;">instanceStrong</span>.nextBytes(block)<br>    <span style="color:#cc7832;">new </span>IvParameterSpec(block)<br>}<br></pre>
<p>An&nbsp;<a href="https://en.wikipedia.org/wiki/Initialization_vector" target="_blank" style="background-color: rgb(255, 255, 255);">initialization vector</a>&nbsp;is used to introduce some additional randomness to avoid repeating patterns in the input leading to repeating patterns in the encrypted bytes.<br></p>
<div>With all these things in place, we are almost ready to encrypt or decrypt, but first, let's define two more helper methods:</div>
<div>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>encrypt(<span style="color:#cc7832;">byte</span>[] bytes, Key key, IvParameterSpec spec, Closure<Cipher> factory) {<br>    <span style="color:#cc7832;">var </span>cipher = factory()<br>    cipher.init(<span style="color:#9876aa;font-style:italic;">ENCRYPT_MODE</span>, key, spec)<br>    cipher.doFinal(bytes)<br>}<br><br><span style="color:#cc7832;">def </span>decrypt(<span style="color:#cc7832;">byte</span>[] bytes, Key key, IvParameterSpec spec, Closure<Cipher> factory) {<br>    <span style="color:#cc7832;">var </span>cipher = factory()<br>    cipher.init(<span style="color:#9876aa;font-style:italic;">DECRYPT_MODE</span>, key, spec)<br>    cipher.doFinal(bytes)<br>}<br></pre>
</div>
<div>And here is how we encrypt and decrypt:</div>
<div>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>encrypted = encrypt(text.<span style="color:#9876aa;">bytes</span>, key, ivParameterSpec, factory)<br>println <span style="color:#6a8759;">"Encrypted bytes : </span>$encrypted<span style="color:#6a8759;">"<br></span>println <span style="color:#6a8759;">"Encrypted text : </span>$<span style="font-weight:bold;">{</span><span style="color:#cc7832;">new </span>String(encrypted)<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;"><br></span><span style="color:#cc7832;">var </span>decrypted = decrypt(encrypted, key, ivParameterSpec, factory)<br>println <span style="color:#6a8759;">"Decrypted bytes : </span>$decrypted<span style="color:#6a8759;">"<br></span>println <span style="color:#6a8759;">"Decrypted text : </span>$<span style="font-weight:bold;">{</span><span style="color:#cc7832;">new </span>String(decrypted)<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"</span></pre>
</div>
<p>Which has this output:</p>
<pre>Encrypted bytes : [-117, 36, 18, 69, -101, -8, 35, 93, -102, -49, -12, ..., -19, -100]
Encrypted text : &lsaquo;$E&rsaquo;&oslash;#]&scaron;&Iuml;&ocirc;&aelig;&rdquo;&Aacute;&tilde;&ccedil;p^&micro;&sup3;=L(&Ouml;^_&OElig;C>CI&Euml;&bdquo;&ouml;,1&Eacute;8&AElig;&Yuml;.&Scaron;?v&szlig;G,&Egrave;w&permil;&aring;&frac14;z&Uuml;f>?&micro;&rsaquo;D&sup1;&eacute;&AElig;k&euro;	&deg;&tilde;2&ecirc;&Ocirc;}&iacute;&copy;&agrave;hl$>?&sup1;&iexcl;K&aring;3&Ocirc;O?&plusmn;&amp;&hellip;&ecirc;&icirc;&para;&Ecirc;&ndash;&frac34;&deg;&reg;q&reg;&agrave;&mdash;0&uacute;&lsquo;&Ocirc;hO<H&brvbar;&ccedil;&reg;&Ccedil;&rdquo;&Egrave;hA&euml;j&oacute; QPy&fnof;y6&Auml;&curren;*&acute;un&frac14;&iuml;&macr;m&uml;&acute;&Ugrave;jeJt&euml;&ordm;\&oacute;6&AElig;&ordf;K&ordf;&oelig;&iacute;&oelig;
Decrypted bytes : [67, 111, 110, 116, 114, 97, 114, 121, 32, 116, 111, 32, ..., 100, 46]
Decrypted text : Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old.
</pre>
<p>We can see that everything worked as expected, since the final output matches our original input text.</p>
<h3>Using the Bouncy Castle library</h3>
<p>We can alternatively, swap algorithms. There are numerous <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/crypto/Cipher.html" target="_blank">algorithms and modes supported</a> by the JDK and others supported by third-party libraries. A nice summary can be found <a href="https://en.wikipedia.org/wiki/Comparison_of_cryptography_libraries" target="_blank">here</a>.</p>
<p>We'll swap to use the CAST5 (<a href="https://en.wikipedia.org/wiki/CAST-128" target="_blank">CAST-128</a>) algorithm which supports up to a 128-bit key. We'll use <a href="https://en.wikipedia.org/w/index.php?title=HMAC-SHA1" target="_blank">HMAC-SHA1</a> to generate our key.</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">import </span>org.bouncycastle.jce.provider.BouncyCastleProvider<br><span style="color:#cc7832;">var </span>bc = <span style="color:#cc7832;">new </span>BouncyCastleProvider()<br>factory = <span style="font-weight:bold;">{ </span>Cipher.<span style="color:#9876aa;font-style:italic;">getInstance</span>(<span style="color:#6a8759;">'CAST5'</span>, bc) <span style="font-weight:bold;">}<br></span>key = generateKey(<span style="color:#6a8759;">'HmacSHA1'</span>, <span style="color:#6897bb;">128</span>)<br>ivParameterSpec = randomParameterSpec(factory)<br></pre>
<p>CAST5 is the default algorithm used in some versions of GPG and PGP. It isn't included by default in the JDK, so for this we'll use the <a href="https://www.bouncycastle.org/java.html" target="_blank">Bouncy Castle library</a>.</p>
<p>[Just as a note. If you are wanting to encrypt or decrypt GPG/PGP files, don't use the above code. Libraries like Bouncy Castle have <a href="https://www.bouncycastle.org/docs/pgdocs1.8on/index.html" target="_blank">dedicated classes</a> for such scenarios.]</p>
<p>We now encrypt and decrypt as before:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">encrypted = encrypt(text.<span style="color:#9876aa;">bytes</span>, key, ivParameterSpec, factory)<br>println <span style="color:#6a8759;">"Encrypted text : </span>$<span style="font-weight:bold;">{</span><span style="color:#cc7832;">new </span>String(encrypted)<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"<br></span>decrypted = decrypt(encrypted, key, ivParameterSpec, factory)<br>println <span style="color:#6a8759;">"Decrypted text : </span>$<span style="font-weight:bold;">{</span><span style="color:#cc7832;">new </span>String(decrypted)<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"<br></span></pre>
<p>Which has this output:</p>
<pre>Encrypted text : M&ordf;&aacute;?r?v9&pound;&divide;~4&micro;T'&rsaquo;&Ugrave;&Yacute;&Aacute;l&iquest;&THORN;g&frac34;0&ntilde;≈Ω&iexcl;?&Uuml;=&sup3;9Q&not;&raquo;3&laquo;&Ouml;&Aacute;&iexcl;&micro; &frac34;@4&divide;`F&ntilde;&Ugrave;&Scaron;f&oslash;7&yen;#&rsaquo;v&curren;&Iacute;&ndash;&permil;&frac14;&Uuml;&cent;&fnof;E6&ocirc;≈ΩT&Ugrave;l&aelig;&Iuml;z>o?&agrave;L&rsaquo;&iexcl;&cent;z1n&Ouml;o9]&scaron;O&Ocirc;&frac14;S&Ocirc;O&Iacute;#&Yacute;7L&oelig;&Agrave;&icirc;}&oacute;5m%q&bull;&raquo;l%/AWT&acute;&cent;zH#t&igrave;&dagger;&plusmn;l&para;&pound;&mdash;&OElig;&laquo;&copy;w&circ;&Atilde;&reg;>&reg;&Uuml;6&euml;r-E
Decrypted text : Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old.
</pre>
<h3>Other useful functionality</h3>
<p>Passing around binary data like our secret key or the encrypted data, has its own problems. Groovy provides extension methods to encode such data (and corresponding decode methods). For example, we can encode our secret key in various ways:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>keyBytes = key.<span style="color:#9876aa;">encoded<br></span>println keyBytes.encodeHex()<br>println keyBytes.encodeBase64()<br>println keyBytes.encodeBase64Url()<br></pre>
<p>Which has this output (the key is random, so the output will differ for each run):</p>
<pre>85a0d3f0ce0cbe6402dc9579fbffcf1d
haDT8M4MvmQC3JV5+//PHQ==
haDT8M4MvmQC3JV5-__PHQ
</pre>
<p>Groovy also provides extension methods for various checksums (but you might want to look at stronger checksum algorithms in security sensitive scenarios):</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">println <span style="color:#6a8759;">"SHA256 : </span>$<span style="font-weight:bold;">{</span>text.sha256()<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"<br></span>println <span style="color:#6a8759;">"MD5 : </span>$<span style="font-weight:bold;">{</span>text.md5()<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"<br></span></pre>
<p>Which has this output:</p>
<pre>SHA256 : ccb184e35e4c32bafc730d84ec924ea2980035ea5fadb012e3b2b31abf4323c9
MD5 : 46c61a174c2dc99204521ca89f09f63c
</pre>
<p>If you are encrypting and decrypting entire files, the JDK has <a href="https://www.baeldung.com/java-cipher-input-output-stream" target="_blank">special classes for that too</a> which are also easy to use from Groovy. That's all for now.</p>
<h3>References</h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Comparison_of_cryptography_libraries" target="_blank">Comparison of cryptography libraries</a>&nbsp;(Wikipedia)</li>
<li><a href="https://asyncq.com/how-to-encrypt-and-decrypt-data-in-java" target="_blank">How to encrypt and decrypt data in java</a>&nbsp;(also on <a href="https://i-sammy.medium.com/how-to-encrypt-and-decrypt-data-in-java-de41be237422" target="_blank">medium.com</a>)</li>
<li><a href="https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk18on/1.71.1" target="_blank">Bouncy castle</a> in maven central</li>
<li><a href="https://www.baeldung.com/java-aes-encryption-decryption" target="_blank">AES Encryption and Decryption&nbsp;in Java</a> (Baeldung)</li>
<li><a href="https://www.baeldung.com/java-encryption-iv" target="_blank">Initialization Vector for Encryption in Java</a> (Baeldung)</li>
<li><a href="https://www.baeldung.com/java-3des" target="_blank">3DES in Java</a> (Baeldung)<br></li>
</ul>
<h3>Conclusion</h3>
<p>We have taken a brief look at encrypting and decrypting with Apache Groovy.</p>

  </div><a class="u-url" href="/groovy/entry/encryption-and-decryption-with-groovy" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
