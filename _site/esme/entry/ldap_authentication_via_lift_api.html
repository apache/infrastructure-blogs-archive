<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>LDAP authentication via Lift API in Apache ESME | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="LDAP authentication via Lift API in Apache ESME" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This blog was written by our new committer&nbsp;Vladimir Ivanov&nbsp;who implemented a feature that users have been wanting for a long time.&nbsp; In the first two parts of this blog series, scenarios were discussed where the authentication process was performed by the container. While it often makes sense to delegate this task to the container in order to integrate with corporate services such as Single Sign-On, sometimes it might be better to take full control of the authentication process and perform this task directly in the source code. In this final part of the blog series, I&#39;ll show how to authenticate user in LDAP via the Lift API as well as introduce some changes that have been made in the authentication modules. Changes in UserAuth.scala In order to perform authentication via the Lift API, a new module LDAPAuthModule has been added. Basically, it uses the same operation sequence as the ContainerManagedAuthModule: it gets the user credentials, tries to authenticate and authorize the user, retrieves additional attributes from the LDAP for a new user and finally logs the user in. Since several operations are common to both authentication modules, it is worth placing them in a base trait LDAPBase: trait LDAPBase { LDAPBase is marked with a self-type to denote that any concrete class that mixes with this trait is a AuthModule instance &nbsp; this : AuthModule =&gt; To check whether the user has a specific role, a list of roles, separated by commas, is read from the property file, split and placed into a val. &nbsp; val rolesToCheck = Props.get(&quot;role_list&quot;) match { &nbsp;&nbsp;&nbsp; case Full(s) =&gt; s.split(&#39;,&#39;).toList &nbsp;&nbsp;&nbsp; case _ =&gt; Nil &nbsp; } A new variable was also added to hold the current role for the User. &nbsp; var currentRole : String = _ The object LDAPVendor and method that extracts attributes from LDAP are used by both modules and were left without changes &nbsp; object myLdapVendor extends LDAPVendor &nbsp; def myLdap : LDAPVendor = ... &nbsp; def getAttrs(dn : String) : Map[String, List[String]] = ... The following two methods are used to construct distinguished name for the user/group pair. Since users and groups can have different bases and prefixes, specific properties are retrieved from the property file depending on the isGroup flag (The new feature, default parameters, introduced in Scala 2.8 is used to set default value for this flag). &nbsp; def constructDistinguishedName(who : String, isGroup : Boolean = false) = { &nbsp;&nbsp;&nbsp; val base = Props.get( if(isGroup) {&quot;ldap.groupBase&quot;} else {&quot;ldap.userBase&quot;} )&nbsp; openOr &quot;&quot; &nbsp;&nbsp;&nbsp;&nbsp; val dn = &quot;%s,%s&quot;.format(constructNameWithPrefix(who, isGroup), base) &nbsp;&nbsp;&nbsp;&nbsp; dn &nbsp; } &nbsp; def constructNameWithPrefix(username: String, isGroup: Boolean = false) = { &nbsp;&nbsp;&nbsp; val prefix = if(isGroup) {&quot;cn&quot;} else {Props.get(&quot;ldap.uidPrefix&quot;) openOr &quot;&quot;} &nbsp;&nbsp;&nbsp; val nameWithPrefix = &quot;%s=%s&quot;.format(prefix, username) &nbsp;&nbsp;&nbsp; nameWithPrefix &nbsp; } The method logInUser was modified to set the current role for the authenticated User. &nbsp; def logInUser(who: User) { &nbsp;&nbsp;&nbsp; User.logUserIn(who) &nbsp;&nbsp;&nbsp; User.setRole(currentRole) &nbsp;&nbsp;&nbsp; S.notice(S.?(&quot;base_user_msg_welcome&quot;, who.niceName)) &nbsp; } } The singleton object ContainerManagedAuthModule now mixes with the LDAPBase trait and uses it&#39;s constructDistinguishedName method to get the LDAP attributes. In all other aspects, it has the same implementation as before. object ContainerManagedAuthModule extends AuthModule with LDAPBase ... Now let&#39;s review the new LDAPAuthModule. object LDAPAuthModule extends AuthModule with LDAPBase { At first, a set of standard methods for all authentication modules is defined: &nbsp; override def isDefault = false &nbsp; def loginPresentation: Box[NodeSeq] = ... &nbsp; def moduleName: String = &quot;ldap&quot; &nbsp; def createHolder() = ... The method performInit makes most of the module&#39;s work: &nbsp; def performInit(): Unit = { The new module is mapped to the /ldap/login URL. &nbsp;&nbsp;&nbsp; LiftRules.dispatch.append { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Req(&quot;ldap&quot; :: &quot;login&quot; :: Nil, _, PostRequest) =&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val from = S.referer openOr &quot;/&quot; It is necessary to check whether LDAP is enabled based on the setting in the property file and if that&#39;s the case, the user credentials are read from the HTTP request and used for the subsequent authentication in LDAP with the LDAPVendor.bindUser method. It takes the distinguished name (composed of username that comes from the HTTP request and the prefix/user base taken from the property file) and password and returns a Boolean. The next step is to check if the user is authorized with the checkRoles method. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val ldapEnabled = Props.getBool(&quot;ldap.enabled&quot;) openOr false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(ldapEnabled) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val name = S.param(&quot;username&quot;).map(_.trim.toLowerCase) openOr &quot;&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val pwd = S.param(&quot;password&quot;).map(_.trim) openOr &quot;&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(myLdap.bindUser(constructNameWithPrefix(name), pwd) &amp;&amp; checkRoles(constructDistinguishedName(name))) { After successful authentication and authorization, an attempt is made to find the existing User. If found, the User is logged in into the application. Otherwise, a new instance of User class is created, populated with attributes from LDAP, saved into the database and then logged in. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user &lt;- UserAuth.find(By(UserAuth.authKey, name), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; By(UserAuth.authType, moduleName)).flatMap(_.user.obj) or &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; User.find(By(User.nickname, name)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } yield user) match { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Full(user) =&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logInUser(user) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Empty =&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val usr = User.createAndPopulate.nickname(name).saveMe &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val ldapAttrs = getAttrs(constructDistinguishedName(name)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val firstName = ldapAttrs(&quot;givenName&quot;).head &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val lastName = ldapAttrs(&quot;sn&quot;).head &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val mail = ldapAttrs(&quot;mail&quot;).head &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usr.firstName(firstName).lastName(lastName).save &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UserAuth.create.authType(moduleName).user(usr).authKey(name).save &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logInUser(usr) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S.error(S.?(&quot;base_user_err_unknown_creds&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S.redirectTo(from) &nbsp;&nbsp;&nbsp; } &nbsp; } The method checkRoles takes the username as a parameter and iterates through a list of roles defined in the property file to see whether the current role contains this name as a value of its uniqueMember attribute. If that&#39;s the case, it assign this role to the currentRole var of LDAPBase trait (it will be then saved in the HTTP session) and returns true, otherwise it returns false. def checkRoles(who : String) : Boolean = { &nbsp;&nbsp;&nbsp; for (role &lt;-rolesToCheck) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val ldapAttrs = getAttrs(constructDistinguishedName(role, true)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val uniqueMember = ldapAttrs(&quot;uniqueMember&quot;).head &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(who == uniqueMember) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRole = role &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; return false; &nbsp; } The last thing I&#39;m going to mention are the two new properties in the default.props file. The property ldap.groupBase specifies the path in LDAP under which groups are searched. The list of application roles is set in the role_list property as a string separated by commas. default.props ;Group base DN to check whether user has specific role ldap.groupBase=ou=Groups,ou=esme,dc=lester,dc=org ;Allow access to application for following roles role_list=esme-users,monitoring-admin Note that the lift-ldap module also has to be added as a dependency to the Maven pom.xml and/or the SBT project file to work with the Lift LDAP API. Conclusion In this article, we have discovered how to authenticate the User directly in LDAP using the Lift API as well as the corresponding changes in the UserAuth class. Links Lift API: http://scala-tools.org/mvnsites/liftweb-2.3/ &lt;/p&gt; &lt;/p&gt;" />
<meta property="og:description" content="This blog was written by our new committer&nbsp;Vladimir Ivanov&nbsp;who implemented a feature that users have been wanting for a long time.&nbsp; In the first two parts of this blog series, scenarios were discussed where the authentication process was performed by the container. While it often makes sense to delegate this task to the container in order to integrate with corporate services such as Single Sign-On, sometimes it might be better to take full control of the authentication process and perform this task directly in the source code. In this final part of the blog series, I&#39;ll show how to authenticate user in LDAP via the Lift API as well as introduce some changes that have been made in the authentication modules. Changes in UserAuth.scala In order to perform authentication via the Lift API, a new module LDAPAuthModule has been added. Basically, it uses the same operation sequence as the ContainerManagedAuthModule: it gets the user credentials, tries to authenticate and authorize the user, retrieves additional attributes from the LDAP for a new user and finally logs the user in. Since several operations are common to both authentication modules, it is worth placing them in a base trait LDAPBase: trait LDAPBase { LDAPBase is marked with a self-type to denote that any concrete class that mixes with this trait is a AuthModule instance &nbsp; this : AuthModule =&gt; To check whether the user has a specific role, a list of roles, separated by commas, is read from the property file, split and placed into a val. &nbsp; val rolesToCheck = Props.get(&quot;role_list&quot;) match { &nbsp;&nbsp;&nbsp; case Full(s) =&gt; s.split(&#39;,&#39;).toList &nbsp;&nbsp;&nbsp; case _ =&gt; Nil &nbsp; } A new variable was also added to hold the current role for the User. &nbsp; var currentRole : String = _ The object LDAPVendor and method that extracts attributes from LDAP are used by both modules and were left without changes &nbsp; object myLdapVendor extends LDAPVendor &nbsp; def myLdap : LDAPVendor = ... &nbsp; def getAttrs(dn : String) : Map[String, List[String]] = ... The following two methods are used to construct distinguished name for the user/group pair. Since users and groups can have different bases and prefixes, specific properties are retrieved from the property file depending on the isGroup flag (The new feature, default parameters, introduced in Scala 2.8 is used to set default value for this flag). &nbsp; def constructDistinguishedName(who : String, isGroup : Boolean = false) = { &nbsp;&nbsp;&nbsp; val base = Props.get( if(isGroup) {&quot;ldap.groupBase&quot;} else {&quot;ldap.userBase&quot;} )&nbsp; openOr &quot;&quot; &nbsp;&nbsp;&nbsp;&nbsp; val dn = &quot;%s,%s&quot;.format(constructNameWithPrefix(who, isGroup), base) &nbsp;&nbsp;&nbsp;&nbsp; dn &nbsp; } &nbsp; def constructNameWithPrefix(username: String, isGroup: Boolean = false) = { &nbsp;&nbsp;&nbsp; val prefix = if(isGroup) {&quot;cn&quot;} else {Props.get(&quot;ldap.uidPrefix&quot;) openOr &quot;&quot;} &nbsp;&nbsp;&nbsp; val nameWithPrefix = &quot;%s=%s&quot;.format(prefix, username) &nbsp;&nbsp;&nbsp; nameWithPrefix &nbsp; } The method logInUser was modified to set the current role for the authenticated User. &nbsp; def logInUser(who: User) { &nbsp;&nbsp;&nbsp; User.logUserIn(who) &nbsp;&nbsp;&nbsp; User.setRole(currentRole) &nbsp;&nbsp;&nbsp; S.notice(S.?(&quot;base_user_msg_welcome&quot;, who.niceName)) &nbsp; } } The singleton object ContainerManagedAuthModule now mixes with the LDAPBase trait and uses it&#39;s constructDistinguishedName method to get the LDAP attributes. In all other aspects, it has the same implementation as before. object ContainerManagedAuthModule extends AuthModule with LDAPBase ... Now let&#39;s review the new LDAPAuthModule. object LDAPAuthModule extends AuthModule with LDAPBase { At first, a set of standard methods for all authentication modules is defined: &nbsp; override def isDefault = false &nbsp; def loginPresentation: Box[NodeSeq] = ... &nbsp; def moduleName: String = &quot;ldap&quot; &nbsp; def createHolder() = ... The method performInit makes most of the module&#39;s work: &nbsp; def performInit(): Unit = { The new module is mapped to the /ldap/login URL. &nbsp;&nbsp;&nbsp; LiftRules.dispatch.append { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Req(&quot;ldap&quot; :: &quot;login&quot; :: Nil, _, PostRequest) =&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val from = S.referer openOr &quot;/&quot; It is necessary to check whether LDAP is enabled based on the setting in the property file and if that&#39;s the case, the user credentials are read from the HTTP request and used for the subsequent authentication in LDAP with the LDAPVendor.bindUser method. It takes the distinguished name (composed of username that comes from the HTTP request and the prefix/user base taken from the property file) and password and returns a Boolean. The next step is to check if the user is authorized with the checkRoles method. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val ldapEnabled = Props.getBool(&quot;ldap.enabled&quot;) openOr false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(ldapEnabled) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val name = S.param(&quot;username&quot;).map(_.trim.toLowerCase) openOr &quot;&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val pwd = S.param(&quot;password&quot;).map(_.trim) openOr &quot;&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(myLdap.bindUser(constructNameWithPrefix(name), pwd) &amp;&amp; checkRoles(constructDistinguishedName(name))) { After successful authentication and authorization, an attempt is made to find the existing User. If found, the User is logged in into the application. Otherwise, a new instance of User class is created, populated with attributes from LDAP, saved into the database and then logged in. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user &lt;- UserAuth.find(By(UserAuth.authKey, name), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; By(UserAuth.authType, moduleName)).flatMap(_.user.obj) or &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; User.find(By(User.nickname, name)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } yield user) match { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Full(user) =&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logInUser(user) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Empty =&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val usr = User.createAndPopulate.nickname(name).saveMe &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val ldapAttrs = getAttrs(constructDistinguishedName(name)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val firstName = ldapAttrs(&quot;givenName&quot;).head &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val lastName = ldapAttrs(&quot;sn&quot;).head &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val mail = ldapAttrs(&quot;mail&quot;).head &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usr.firstName(firstName).lastName(lastName).save &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UserAuth.create.authType(moduleName).user(usr).authKey(name).save &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logInUser(usr) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S.error(S.?(&quot;base_user_err_unknown_creds&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S.redirectTo(from) &nbsp;&nbsp;&nbsp; } &nbsp; } The method checkRoles takes the username as a parameter and iterates through a list of roles defined in the property file to see whether the current role contains this name as a value of its uniqueMember attribute. If that&#39;s the case, it assign this role to the currentRole var of LDAPBase trait (it will be then saved in the HTTP session) and returns true, otherwise it returns false. def checkRoles(who : String) : Boolean = { &nbsp;&nbsp;&nbsp; for (role &lt;-rolesToCheck) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val ldapAttrs = getAttrs(constructDistinguishedName(role, true)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val uniqueMember = ldapAttrs(&quot;uniqueMember&quot;).head &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(who == uniqueMember) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRole = role &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; return false; &nbsp; } The last thing I&#39;m going to mention are the two new properties in the default.props file. The property ldap.groupBase specifies the path in LDAP under which groups are searched. The list of application roles is set in the role_list property as a string separated by commas. default.props ;Group base DN to check whether user has specific role ldap.groupBase=ou=Groups,ou=esme,dc=lester,dc=org ;Allow access to application for following roles role_list=esme-users,monitoring-admin Note that the lift-ldap module also has to be added as a dependency to the Maven pom.xml and/or the SBT project file to work with the Lift LDAP API. Conclusion In this article, we have discovered how to authenticate the User directly in LDAP using the Lift API as well as the corresponding changes in the UserAuth class. Links Lift API: http://scala-tools.org/mvnsites/liftweb-2.3/ &lt;/p&gt; &lt;/p&gt;" />
<link rel="canonical" href="http://localhost:4000/esme/entry/ldap_authentication_via_lift_api" />
<meta property="og:url" content="http://localhost:4000/esme/entry/ldap_authentication_via_lift_api" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2011-05-26T14:35:06-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="LDAP authentication via Lift API in Apache ESME" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2011-05-26T14:35:06-04:00","datePublished":"2011-05-26T14:35:06-04:00","description":"This blog was written by our new committer&nbsp;Vladimir Ivanov&nbsp;who implemented a feature that users have been wanting for a long time.&nbsp; In the first two parts of this blog series, scenarios were discussed where the authentication process was performed by the container. While it often makes sense to delegate this task to the container in order to integrate with corporate services such as Single Sign-On, sometimes it might be better to take full control of the authentication process and perform this task directly in the source code. In this final part of the blog series, I&#39;ll show how to authenticate user in LDAP via the Lift API as well as introduce some changes that have been made in the authentication modules. Changes in UserAuth.scala In order to perform authentication via the Lift API, a new module LDAPAuthModule has been added. Basically, it uses the same operation sequence as the ContainerManagedAuthModule: it gets the user credentials, tries to authenticate and authorize the user, retrieves additional attributes from the LDAP for a new user and finally logs the user in. Since several operations are common to both authentication modules, it is worth placing them in a base trait LDAPBase: trait LDAPBase { LDAPBase is marked with a self-type to denote that any concrete class that mixes with this trait is a AuthModule instance &nbsp; this : AuthModule =&gt; To check whether the user has a specific role, a list of roles, separated by commas, is read from the property file, split and placed into a val. &nbsp; val rolesToCheck = Props.get(&quot;role_list&quot;) match { &nbsp;&nbsp;&nbsp; case Full(s) =&gt; s.split(&#39;,&#39;).toList &nbsp;&nbsp;&nbsp; case _ =&gt; Nil &nbsp; } A new variable was also added to hold the current role for the User. &nbsp; var currentRole : String = _ The object LDAPVendor and method that extracts attributes from LDAP are used by both modules and were left without changes &nbsp; object myLdapVendor extends LDAPVendor &nbsp; def myLdap : LDAPVendor = ... &nbsp; def getAttrs(dn : String) : Map[String, List[String]] = ... The following two methods are used to construct distinguished name for the user/group pair. Since users and groups can have different bases and prefixes, specific properties are retrieved from the property file depending on the isGroup flag (The new feature, default parameters, introduced in Scala 2.8 is used to set default value for this flag). &nbsp; def constructDistinguishedName(who : String, isGroup : Boolean = false) = { &nbsp;&nbsp;&nbsp; val base = Props.get( if(isGroup) {&quot;ldap.groupBase&quot;} else {&quot;ldap.userBase&quot;} )&nbsp; openOr &quot;&quot; &nbsp;&nbsp;&nbsp;&nbsp; val dn = &quot;%s,%s&quot;.format(constructNameWithPrefix(who, isGroup), base) &nbsp;&nbsp;&nbsp;&nbsp; dn &nbsp; } &nbsp; def constructNameWithPrefix(username: String, isGroup: Boolean = false) = { &nbsp;&nbsp;&nbsp; val prefix = if(isGroup) {&quot;cn&quot;} else {Props.get(&quot;ldap.uidPrefix&quot;) openOr &quot;&quot;} &nbsp;&nbsp;&nbsp; val nameWithPrefix = &quot;%s=%s&quot;.format(prefix, username) &nbsp;&nbsp;&nbsp; nameWithPrefix &nbsp; } The method logInUser was modified to set the current role for the authenticated User. &nbsp; def logInUser(who: User) { &nbsp;&nbsp;&nbsp; User.logUserIn(who) &nbsp;&nbsp;&nbsp; User.setRole(currentRole) &nbsp;&nbsp;&nbsp; S.notice(S.?(&quot;base_user_msg_welcome&quot;, who.niceName)) &nbsp; } } The singleton object ContainerManagedAuthModule now mixes with the LDAPBase trait and uses it&#39;s constructDistinguishedName method to get the LDAP attributes. In all other aspects, it has the same implementation as before. object ContainerManagedAuthModule extends AuthModule with LDAPBase ... Now let&#39;s review the new LDAPAuthModule. object LDAPAuthModule extends AuthModule with LDAPBase { At first, a set of standard methods for all authentication modules is defined: &nbsp; override def isDefault = false &nbsp; def loginPresentation: Box[NodeSeq] = ... &nbsp; def moduleName: String = &quot;ldap&quot; &nbsp; def createHolder() = ... The method performInit makes most of the module&#39;s work: &nbsp; def performInit(): Unit = { The new module is mapped to the /ldap/login URL. &nbsp;&nbsp;&nbsp; LiftRules.dispatch.append { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Req(&quot;ldap&quot; :: &quot;login&quot; :: Nil, _, PostRequest) =&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val from = S.referer openOr &quot;/&quot; It is necessary to check whether LDAP is enabled based on the setting in the property file and if that&#39;s the case, the user credentials are read from the HTTP request and used for the subsequent authentication in LDAP with the LDAPVendor.bindUser method. It takes the distinguished name (composed of username that comes from the HTTP request and the prefix/user base taken from the property file) and password and returns a Boolean. The next step is to check if the user is authorized with the checkRoles method. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val ldapEnabled = Props.getBool(&quot;ldap.enabled&quot;) openOr false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(ldapEnabled) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val name = S.param(&quot;username&quot;).map(_.trim.toLowerCase) openOr &quot;&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val pwd = S.param(&quot;password&quot;).map(_.trim) openOr &quot;&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(myLdap.bindUser(constructNameWithPrefix(name), pwd) &amp;&amp; checkRoles(constructDistinguishedName(name))) { After successful authentication and authorization, an attempt is made to find the existing User. If found, the User is logged in into the application. Otherwise, a new instance of User class is created, populated with attributes from LDAP, saved into the database and then logged in. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user &lt;- UserAuth.find(By(UserAuth.authKey, name), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; By(UserAuth.authType, moduleName)).flatMap(_.user.obj) or &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; User.find(By(User.nickname, name)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } yield user) match { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Full(user) =&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logInUser(user) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Empty =&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val usr = User.createAndPopulate.nickname(name).saveMe &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val ldapAttrs = getAttrs(constructDistinguishedName(name)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val firstName = ldapAttrs(&quot;givenName&quot;).head &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val lastName = ldapAttrs(&quot;sn&quot;).head &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val mail = ldapAttrs(&quot;mail&quot;).head &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usr.firstName(firstName).lastName(lastName).save &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UserAuth.create.authType(moduleName).user(usr).authKey(name).save &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logInUser(usr) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S.error(S.?(&quot;base_user_err_unknown_creds&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S.redirectTo(from) &nbsp;&nbsp;&nbsp; } &nbsp; } The method checkRoles takes the username as a parameter and iterates through a list of roles defined in the property file to see whether the current role contains this name as a value of its uniqueMember attribute. If that&#39;s the case, it assign this role to the currentRole var of LDAPBase trait (it will be then saved in the HTTP session) and returns true, otherwise it returns false. def checkRoles(who : String) : Boolean = { &nbsp;&nbsp;&nbsp; for (role &lt;-rolesToCheck) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val ldapAttrs = getAttrs(constructDistinguishedName(role, true)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val uniqueMember = ldapAttrs(&quot;uniqueMember&quot;).head &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(who == uniqueMember) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRole = role &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; return false; &nbsp; } The last thing I&#39;m going to mention are the two new properties in the default.props file. The property ldap.groupBase specifies the path in LDAP under which groups are searched. The list of application roles is set in the role_list property as a string separated by commas. default.props ;Group base DN to check whether user has specific role ldap.groupBase=ou=Groups,ou=esme,dc=lester,dc=org ;Allow access to application for following roles role_list=esme-users,monitoring-admin Note that the lift-ldap module also has to be added as a dependency to the Maven pom.xml and/or the SBT project file to work with the Lift LDAP API. Conclusion In this article, we have discovered how to authenticate the User directly in LDAP using the Lift API as well as the corresponding changes in the UserAuth class. Links Lift API: http://scala-tools.org/mvnsites/liftweb-2.3/ &lt;/p&gt; &lt;/p&gt;","headline":"LDAP authentication via Lift API in Apache ESME","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/esme/entry/ldap_authentication_via_lift_api"},"url":"http://localhost:4000/esme/entry/ldap_authentication_via_lift_api"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">LDAP authentication via Lift API in Apache ESME</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2011-05-26T14:35:06-04:00" itemprop="datePublished">May 26, 2011
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Richard Hirsch", "login"=>"rhirsch", "email"=>"rhirsch@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div style="background-color: transparent; margin-top: 0px; margin-left: 0px; margin-bottom: 0px; margin-right: 0px; ">
<div style="background-color: transparent; margin-top: 0px; margin-left: 0px; margin-bottom: 0px; margin-right: 0px; ">
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "><span style="white-space: normal; ">This blog was written by our new committer&nbsp;<i>Vladimir Ivanov</i>&nbsp;who implemented a feature that users have been wanting for a long time.&nbsp;</span></span></p>
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">In the first two parts of this blog series, scenarios were discussed where the authentication process was performed by the container. While it often makes sense to delegate this task to the container in order to integrate with corporate services such as Single Sign-On, sometimes it might be better to take full control of the authentication process and perform this task directly in the source code. In this final part of the blog series, I'll show how to authenticate user in LDAP via the Lift API as well as introduce some changes that have been made in the authentication modules.</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<h2><span style="background-color: transparent; font-weight: normal; font-style: normal; vertical-align: baseline; white-space: pre-wrap; ">Changes in UserAuth.scala</span></h2>
<p><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">In order to perform authentication via the Lift API, a new module </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">LDAPAuthModule</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> has been added. Basically, it uses the same operation sequence as the </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">ContainerManagedAuthModule: </span><span style="background-color: transparent; font-weight: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">it </span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">gets the user credentials, tries to authenticate and authorize the user, retrieves additional attributes from the LDAP for a new user and finally logs the user in. Since several operations are common to both authentication modules, it is worth placing them in a base trait </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">LDAPBase</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">:</span><br /><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">trait LDAPBase {</span></pre>
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">LDAPBase</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> is marked with a self-type to denote that any concrete class that mixes with this trait is a </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">AuthModule</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> instance</span><br /><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; this : AuthModule =></span></pre>
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">To check whether the user has a specific role, a list of roles, separated by commas, is read from the property file, split and placed into a val.</span><br /><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; val rolesToCheck = Props.get("role_list") match {
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp; case Full(s) => s.split(',').toList
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp; case _ => Nil
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; }
</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span></pre>
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">A new variable was also added to hold the current role for the User.</span><br /><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; var currentRole : String = _</span></pre>
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">The object </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">LDAPVendor</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> and method that extracts attributes from LDAP are used by both modules and were left without changes</span><br /><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; object myLdapVendor extends LDAPVendor
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> 
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; def myLdap : LDAPVendor = ...
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> 
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; def getAttrs(dn : String) : Map[String, List[String]] = ...</span></pre>
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">The following two methods are used to construct distinguished name for the user/group pair. Since users and groups can have different bases and prefixes, specific properties are retrieved from the property file depending on the </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">isGroup</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> flag (The new feature, default parameters, introduced in Scala 2.8 is used to set default value for this flag).</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; def constructDistinguishedName(who : String, isGroup : Boolean = false) = {
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp; val base = Props.get( if(isGroup) {"ldap.groupBase"} else {"ldap.userBase"} )&nbsp; openOr ""
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp; val dn = "%s,%s".format(constructNameWithPrefix(who, isGroup), base)
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp; dn
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; }
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> 
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; def constructNameWithPrefix(username: String, isGroup: Boolean = false) = {
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp; val prefix = if(isGroup) {"cn"} else {Props.get("ldap.uidPrefix") openOr ""}
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp; val nameWithPrefix = "%s=%s".format(prefix, username)
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp; nameWithPrefix
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; }</span></pre>
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">The method </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">logInUser </span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">was modified to set the current role for the authenticated User.</span><br /><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; def logInUser(who: User) {
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp; User.logUserIn(who)
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp; User.setRole(currentRole)
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp; S.notice(S.?("base_user_msg_welcome", who.niceName))
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; }
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">}</span></pre>
<p><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">The singleton object </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">ContainerManagedAuthModule </span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">now mixes with the </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">LDAPBase</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> trait and uses it's </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">constructDistinguishedName</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> method to get</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> the </span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">LDAP attributes. In all other aspects, it has the same implementation as before.</span><br /><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">object ContainerManagedAuthModule extends AuthModule with LDAPBase
</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">...</span></pre>
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Now let's review the new </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">LDAPAuthModule.</span><br /><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">object LDAPAuthModule extends AuthModule with LDAPBase {</span></pre>
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">At first, a set of standard methods for all authentication modules is defined:</span><br /><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; override def isDefault = false
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> 
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; def loginPresentation: Box[NodeSeq] = ...
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> 
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; def moduleName: String = "ldap"
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> 
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; def createHolder() = ...</span></pre>
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">The method </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">performInit </span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">makes most of the module's work:</span><br /><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; def performInit(): Unit = {</span></pre>
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">The new module is mapped to the </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">/ldap/login</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> URL.</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp; LiftRules.dispatch.append {
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Req("ldap" :: "login" :: Nil, _, PostRequest) =>
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val from = S.referer openOr "/"</span></pre>
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">It is necessary to check whether LDAP is enabled based on the setting in the property file and if that's the case, the user credentials are read from the HTTP request and used for the subsequent authentication in LDAP with the </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">LDAPVendor.bindUser</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> method. It takes the distinguished name (composed of username that comes from the HTTP request and the prefix/user base taken from the property file) and password and returns a </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Boolean</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">. The next step is to check if the user is authorized with the </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">checkRoles</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> method.</span><br /><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val ldapEnabled = Props.getBool("ldap.enabled") openOr false
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(ldapEnabled) {
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val name = S.param("username").map(_.trim.toLowerCase) openOr ""
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val pwd = S.param("password").map(_.trim) openOr ""
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(myLdap.bindUser(constructNameWithPrefix(name), pwd) &amp;&amp; checkRoles(constructDistinguishedName(name))) {</span></pre>
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">After successful authentication and authorization, an attempt is made to find the existing User. If found, the User is logged in into the application. Otherwise, a new instance of User class is created, populated with attributes from LDAP, saved into the database and then logged in.</span><br /><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (for {
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user <- UserAuth.find(By(UserAuth.authKey, name),
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; By(UserAuth.authType, moduleName)).flatMap(_.user.obj) or
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; User.find(By(User.nickname, name))
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } yield user) match {
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Full(user) =>
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logInUser(user)
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Empty =>
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val usr = User.createAndPopulate.nickname(name).saveMe
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val ldapAttrs = getAttrs(constructDistinguishedName(name))
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val firstName = ldapAttrs("givenName").head
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val lastName = ldapAttrs("sn").head
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val mail = ldapAttrs("mail").head
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usr.firstName(firstName).lastName(lastName).save
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UserAuth.create.authType(moduleName).user(usr).authKey(name).save
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logInUser(usr)
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S.error(S.?("base_user_err_unknown_creds"))
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> 
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S.redirectTo(from)
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp; }
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; }</span></pre>
<p><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">The method </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">checkRoles </span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">takes the username as a parameter and iterates through a list of roles defined in the property file to see whether the current role contains this name as a value of its </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">uniqueMember </span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">attribute. If that's the case, it assign this role to the </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">currentRole</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> var of </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">LDAPBase</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> trait (it will be then saved in the HTTP session) and returns </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">true</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">, otherwise it returns </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">false.</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">def checkRoles(who : String) : Boolean = {
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp; for (role <-rolesToCheck) {
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val ldapAttrs = getAttrs(constructDistinguishedName(role, true))
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val uniqueMember = ldapAttrs("uniqueMember").head
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(who == uniqueMember) {
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRole = role
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp; }
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp;&nbsp;&nbsp; return false;
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">&nbsp; }</span></pre>
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">The last thing I'm going to mention are the two new properties in the </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">default.props</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> file. The property </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">ldap.groupBase </span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">specifies the path in LDAP under which groups are searched. The list of application roles is set in the </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">role_list</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> property as a string separated by commas.</span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap; ">default.props</span><br /><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<pre><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">;Group base DN to check whether user has specific role
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">ldap.groupBase=ou=Groups,ou=esme,dc=lester,dc=org
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> 
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">;Allow access to application for following roles
</span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">role_list=esme-users,monitoring-admin</span></pre>
<p><span style="background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Note that the </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">lift-ldap </span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">module also has to be added as a dependency to the Maven </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">pom.xml</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> and/or the SBT project file to work with the Lift LDAP API.</span><span style="background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span> </p>
<h2><span style="background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Conclusion</span></h2>
<p><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">In this article, we have discovered how to authenticate the User directly in LDAP using the Lift API as well as the corresponding changes in the </span><span style="background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">UserAuth</span><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> class.</span><br /><span style="background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Links</span><br /><span style="background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span><br /><span style="background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Lift API: </span><a href="http://scala-tools.org/mvnsites/liftweb-2.3/" style="white-space: normal; "><span style="background-color: transparent; font-weight: normal; font-style: normal; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap; ">http://scala-tools.org/mvnsites/liftweb-2.3/</span></a> </p>
</p></div>
</p></div>

  </div><a class="u-url" href="/esme/entry/ldap_authentication_via_lift_api" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
