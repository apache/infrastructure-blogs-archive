<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Data Types != Schema | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Data Types != Schema" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="by Nick Dimiduk&nbsp; &lt;/p&gt; My work on adding data types to&nbsp;HBase has come along far enough that ambiguities in the conversation are finally starting to shake out. These were issues I&rsquo;d hoped to address through initial design documentation and a draft specification. Unfortunately, it&rsquo;s not until there&rsquo;s real code implemented that the finer points are addressed in concrete. I&rsquo;d like to take a step back from the code for a moment to initiate the conversation again and hopefully clarify some points about how I&rsquo;ve approached this new feature. If you came here looking for code, you&rsquo;re out of luck. Go check out the parent ticket, HBASE-8089. For those who don&rsquo;t care about my personal experiences with information theory, skip down to the TL;DR section at the end. You might also be satisfied by the slides I presented on this same topic at the Hadoop Summit HBase session in June. A database by any other name &ldquo;HBase is a database.&rdquo; This is the very first statement in HBase in Action. Amandeep and I debated, both between ourselves and with a few of our confidants, as to whether we should make that statement. The concern in my mind was never over the validity of the claim, but rather how it would be interpreted. &ldquo;Database&rdquo; has come to encompass a great deal of technologies and features, many of those features HBase doesn&rsquo;t (yet) support. The confusion is worsened by the recent popularity of non-relational databases under the umbrella title NoSQL, a term which itself is confused [1]. In this post, I hope to tease apart some of these related ideas. My experience with data persistence systems started with my first position out of university. I worked for a small company whose product, at its core, was a hierarchical database. That database had a very bare concept of tables and there was no SQL interface. It&rsquo;s primary construct was a hierarchy of nodes and its query engine was very good at traversing that hierarchy. The hierarchy was also all it exposed to its consumers, and querying the database was semantically equivalent to walking that hierarchy and executing functions on an individual node and its children. The only way to communicate with it was via a Java API, or later, the C++ interface. For a very long time, the only data type it could persist was a C-style char[]. Yet a client could connect to the database server over the network, persist data into it, and issue queries to retrieve previously persisted data and transformed versions thereof. It didn&rsquo;t support SQL, it only spoke in Strings, but it was a database. Under the hood, this data storage system used an open source, embedded database library with which you&rsquo;re very likely familiar. The API for that database exposed a linear sequence of pages allocated from disk. Each page held a byte[]. You can think of the whole database as a persisted byte[][]. Queries against that database involved requesting a specific page by its ID and it returned to you the raw block of data that resided there. Our database engine delegated persistence responsibilities to that system, using it to manage it&rsquo;s own concepts and data structures in a format that could be serialized to bytes on disk. Indeed, that embedded database library delegated much of its own persistence responsibilities to the operating system&rsquo;s filesystem implementation. In common usage, the word &ldquo;database&rdquo; tends to be shorthand for Relational Database Management System. Neither the hierarchical database, the embedded database, nor the filesystem qualify by this definition. Yet all three persist and retrieve data according to well defined semantics. HBase is also not a Relational Database Management System, but it persists and retrieves data according to well defined semantics. HBase is a database. Data management as a continuum Please bear with me as I wander blindly into the world of information theory. I think of data management as a continuum. On the one extreme, we have the raw physical substrate on which information is expressed as matter. On the far other extreme is our ability to reason and form understandings about a catalog of knowledge. In computer systems, we narrow the scope of that continuum, but it&rsquo;s still a range from the physical allocation of bits to a structure that can be interpreted by humans. physical bits meaning | | |-------------------|-------------------| | | database A database provides an interface over which the persisted data is available for interaction. Those interacting with it are generally technical humans and systems that expose that data to non-technical humans through applications. The humans&rsquo; goal is primarily to derive meaning from that persisted data. The RDBMS exposes an interface that&rsquo;s a lot closer to the human level than HBase or my other examples. That interface is brought closer in large part because the RDBMS includes a system of metadata description and management called aschema. Exposing a schema, a way to describe the data physically persisted, acts as a bridge from database to non-technical humans. It allows the human to describe the information they want to persist in a way that has meaning to both the human and the database. A schema is metadata. It&rsquo;s a description of the shape of the data and also provides hints to its intended meaning. Computer systems represent data as sequences of binary data. The schema helps us make sense of those digits. A schema can tell us that 0x01c7c6 represents the numeric value 99.99 which means &ldquo;the average price of your monthly mobile phone bill.&rdquo; In addition to providing data management tools, most RDBMSs provided schema management tools. Managing schema is just as important as managing the data itself. I say that because without schema, how can I begin to understand what this collection of data means? As knowledge and needs change, so too does data. Just as the data management tools provide a method for changing data values, the schema management tools provide a method for tracking the change in meaning of the data. From here to there A database does not get a schema for free. In order to describe meaning of persisted data, a schema needs a few building block concepts. Relational systems derive their name from the system of relational algebra upon which they describe their data and its access. A table contains records that all conform to a particular shape and that shape is described by a sequence of labeled columns. Tables often represent something specific and the columns describe attributes of that something. As humans, we often find it helpful to describe the domain of valid values an attribute can take. 99.99 makes sense for the average price described above, while hello worlddoes not. A layer of abstraction is introduced, and we might describe the range of valid values for this average price as a numeric value representing a unit of currency with up to two decimals of precision between the range of 0.00 and 9999.99. We describe that aspect of the schema as a data type. The &ldquo;currency&rdquo; data type we just defined allows us to be more specific about the meaning of the attribute in our schema. Better still, if we can describe the data type to our database, we can let it monitor and constrain the accepted values used in that attribute. That&rsquo;s helpful for humans because the computer is probably better as managing these constraints than we are. It&rsquo;s also helpful for the database because it no longer needs to store &ldquo;any of the things&rdquo; in this attribute. Instead, it only must store any of the valid values of this data type. That allows it to optimize the way it stores those values and potentially provide other meaningful operations on those values. With a data type defined, it opens the database to be able to answer queries about the data and ranges of data instead of just persisting and retrieving values. &ldquo;What&rsquo;s the lowest average price?&rdquo; &ldquo;What&rsquo;s the highest?&rdquo; &ldquo;By how much do the average prices deviate?&rdquo; The filesystem upon which my hierarchical database sat couldn&rsquo;t answer questions like those. Data types bridge the gap between persistence layers and schema, allowing the database to share in the responsibility of value constraint management and allowing it to do more than just persist values. But data types are only half of the story. Just because I&rsquo;ve declared an attribute to be of type &ldquo;numeric&rdquo; doesn&rsquo;t mean the database can persist it. A data type can be implemented that honors the constraints upon numerical values, but there&rsquo;s still another step between my value and the sequence of binary digits. That step is the encoding. An encoding is a way to represent a value in binary digits. The simplest encoding for integer values is the representation of that number in base-2; this is a literal representation in binary digits. Encodings come with limitations though, this one included. In this case, it provides no means to represent a negative integer value. The 2&rsquo;s compliment encoding has the advantage of being able to represent negative integers. It also enjoys the convenience that most arithmetic operations on values in this encoding behave naturally. Binary coded decimal is another encoding for integer values. It has different properties and different advantages and disadvantages than 2&rsquo;s compliment. Both are equally valid ways to represent integers as a sequence of binary data. Thus an integer data type, honoring all the constraints of integer values can be encoded in multiple ways. Continuing the example, just like there are multiple valid relational schema designs to derive meaning over a data set of mobile subscribers, so too are there multiple valid encodings to represent an integer value [2]. Data types for HBase Thus far in its lifetime, HBase has provided data persistence. It does so in a rather unique way as compared to other databases. That method of persistence influences the semantics it exposes around persisting and retrieving the data it stores. To date, those semantics have exposed a very simple logical data model, that of a sorted, nested map of maps. That data model is heavily influenced by the physical data model of the database implementation. Technically this data model is a schema because it defines a logical structure for data, complete with a data type. However, this model is very rudimentary as schemas go. It provides very few facilities for mapping application-level meaning to physical layout. The only data type this logical data model exposes is the humble byte[] and its encoding is a simple no-op [3]. While the byte[] is strictly sufficient, it&rsquo;s not particularly convenient for application developers. I don&rsquo;t want to think about my average subscription price as a byte[], but rather as a value conforming to the numeric type described earlier. HBase requires that I accept the burden of both data type constraint maintenance and data value encoding into my application. HBase does provide a number of data encodings for Java languages primitive types. These encodings are implemented in the toXXX methods on the Bytes class. These methods transform the Java types into byte[]and back again. The trouble is they (mostly, partially) don&rsquo;t preserve the sort order of the values they represent. This is a problem. HBase&rsquo;s semantics of a sorted map of maps is extremely important in designing table layouts for applications. The sort order influences physical layout of data on disk, which has direct impact on data access latency. The practice of HBase &ldquo;schema design&rdquo; is the task of laying out your data physically so as to minimize the latency of the access patterns that are important to your application. A major aspect of that is in designing a rowkey that orders well for the application. Because the default encodings do not always honor the natural sorting of the values they represent, it can become difficult to reason about application performance. Application developers are left to devise their own encoding systems that honor the natural sorting of any data types they wish to use. Doing more for application developers In HBASE-8089, I proposed that we expand the set of data types that HBase exposes to include a number of new members. The idea being that those other types make it easier for developers to build applications. It includes an initial list of suggested data types and some proposals about how they might be implemented, hinting toward considerations of order-preserving encodings. HBASE-8201 defines a new utility class for data encodings called OrderedBytes. The encodings implemented there are designed primarily to produce byte[]s that preserve the natural sort order of the values they represent. They are also implemented in such a way as to be self-identifying. Meaning, an encoded value can be inspected to determine which encoding it represents. This last feature makes the encoding scheme at least rudimentarily machine readable and is particularly valuable, in my opinion. It enables reader tools (a raw data inspector, for example) to be encoding aware even in the absence of knowledge about schema or data types. HBASE-8693 advocates an extensible data type API, so that application developers can easily introduce new data types. This allows HBase applications to implement their own data types that the HBase community hasn&rsquo;t thought of or does not think are appropriate to ship with the core system. The working implementation of that DataType API and a number of pre-supported data types are provided. Those data types are built on the two codecs, Bytes and OrderedBytes. That means application developers will have access to basic constructs like number and Strings in addition to byte[]. It also means that sophisticated users can develop highly specialized data types for use as the foundation of extensions to HBase. My hope is this will make extension efforts on par with PostGIS possible in HBase. Please take note that nothing here approaches the topic of schema or schema management. My personal opinion is that not enough complex applications have been written against HBase for the project to ship with such a system out of the box. Two notable efforts which are imposing schema onto HBase are Phoenix and Kiji. The former seeks to translate a subset of the Relational model onto HBase. The latter is devising its own solution, presumably modeled after its authors&rsquo; own experiences. In both cases, I hope these projects can benefit by HBase providing some additional data encodings and an API for user-extensible data types. Conclusions It&rsquo;s an exciting time to be building large, data-driven applications. We enjoy a wealth of new tools, not just HBase, to make that easier than ever before. Still, those same tools that make things possible are still in infant stages of usability. Hopefully these efforts will move the conversation forward. Please take a moment to review these tickets. Let us know what data types we haven&rsquo;t thought about and what encoding schemes you fancy. Poke holes in the data type extension API and provide counter examples that you can&rsquo;t implement due to lack of expression. Take this opportunity to customize your tools to better fit your own hands. Notes [1] The term NoSQL is used to reference pretty much anything that stores data and didn&rsquo;t exist a decade ago. This includes quite an array of data tools. Amandeep and I studied and summarized the landscape in a short body of work that was cut from the book. Key-value stores, graph databases, in-memory stores, object stores, and hybrids of the above all make the cut. About all they can agree on is they don&rsquo;t like using the relational model to describe their data. [2] For more fun, check out the ZigZag encoding described in the documentation of Google&rsquo;s protobuf. [3] That&rsquo;s almost true. HBase also provides a uint64 data type exposed through the Increment API." />
<meta property="og:description" content="by Nick Dimiduk&nbsp; &lt;/p&gt; My work on adding data types to&nbsp;HBase has come along far enough that ambiguities in the conversation are finally starting to shake out. These were issues I&rsquo;d hoped to address through initial design documentation and a draft specification. Unfortunately, it&rsquo;s not until there&rsquo;s real code implemented that the finer points are addressed in concrete. I&rsquo;d like to take a step back from the code for a moment to initiate the conversation again and hopefully clarify some points about how I&rsquo;ve approached this new feature. If you came here looking for code, you&rsquo;re out of luck. Go check out the parent ticket, HBASE-8089. For those who don&rsquo;t care about my personal experiences with information theory, skip down to the TL;DR section at the end. You might also be satisfied by the slides I presented on this same topic at the Hadoop Summit HBase session in June. A database by any other name &ldquo;HBase is a database.&rdquo; This is the very first statement in HBase in Action. Amandeep and I debated, both between ourselves and with a few of our confidants, as to whether we should make that statement. The concern in my mind was never over the validity of the claim, but rather how it would be interpreted. &ldquo;Database&rdquo; has come to encompass a great deal of technologies and features, many of those features HBase doesn&rsquo;t (yet) support. The confusion is worsened by the recent popularity of non-relational databases under the umbrella title NoSQL, a term which itself is confused [1]. In this post, I hope to tease apart some of these related ideas. My experience with data persistence systems started with my first position out of university. I worked for a small company whose product, at its core, was a hierarchical database. That database had a very bare concept of tables and there was no SQL interface. It&rsquo;s primary construct was a hierarchy of nodes and its query engine was very good at traversing that hierarchy. The hierarchy was also all it exposed to its consumers, and querying the database was semantically equivalent to walking that hierarchy and executing functions on an individual node and its children. The only way to communicate with it was via a Java API, or later, the C++ interface. For a very long time, the only data type it could persist was a C-style char[]. Yet a client could connect to the database server over the network, persist data into it, and issue queries to retrieve previously persisted data and transformed versions thereof. It didn&rsquo;t support SQL, it only spoke in Strings, but it was a database. Under the hood, this data storage system used an open source, embedded database library with which you&rsquo;re very likely familiar. The API for that database exposed a linear sequence of pages allocated from disk. Each page held a byte[]. You can think of the whole database as a persisted byte[][]. Queries against that database involved requesting a specific page by its ID and it returned to you the raw block of data that resided there. Our database engine delegated persistence responsibilities to that system, using it to manage it&rsquo;s own concepts and data structures in a format that could be serialized to bytes on disk. Indeed, that embedded database library delegated much of its own persistence responsibilities to the operating system&rsquo;s filesystem implementation. In common usage, the word &ldquo;database&rdquo; tends to be shorthand for Relational Database Management System. Neither the hierarchical database, the embedded database, nor the filesystem qualify by this definition. Yet all three persist and retrieve data according to well defined semantics. HBase is also not a Relational Database Management System, but it persists and retrieves data according to well defined semantics. HBase is a database. Data management as a continuum Please bear with me as I wander blindly into the world of information theory. I think of data management as a continuum. On the one extreme, we have the raw physical substrate on which information is expressed as matter. On the far other extreme is our ability to reason and form understandings about a catalog of knowledge. In computer systems, we narrow the scope of that continuum, but it&rsquo;s still a range from the physical allocation of bits to a structure that can be interpreted by humans. physical bits meaning | | |-------------------|-------------------| | | database A database provides an interface over which the persisted data is available for interaction. Those interacting with it are generally technical humans and systems that expose that data to non-technical humans through applications. The humans&rsquo; goal is primarily to derive meaning from that persisted data. The RDBMS exposes an interface that&rsquo;s a lot closer to the human level than HBase or my other examples. That interface is brought closer in large part because the RDBMS includes a system of metadata description and management called aschema. Exposing a schema, a way to describe the data physically persisted, acts as a bridge from database to non-technical humans. It allows the human to describe the information they want to persist in a way that has meaning to both the human and the database. A schema is metadata. It&rsquo;s a description of the shape of the data and also provides hints to its intended meaning. Computer systems represent data as sequences of binary data. The schema helps us make sense of those digits. A schema can tell us that 0x01c7c6 represents the numeric value 99.99 which means &ldquo;the average price of your monthly mobile phone bill.&rdquo; In addition to providing data management tools, most RDBMSs provided schema management tools. Managing schema is just as important as managing the data itself. I say that because without schema, how can I begin to understand what this collection of data means? As knowledge and needs change, so too does data. Just as the data management tools provide a method for changing data values, the schema management tools provide a method for tracking the change in meaning of the data. From here to there A database does not get a schema for free. In order to describe meaning of persisted data, a schema needs a few building block concepts. Relational systems derive their name from the system of relational algebra upon which they describe their data and its access. A table contains records that all conform to a particular shape and that shape is described by a sequence of labeled columns. Tables often represent something specific and the columns describe attributes of that something. As humans, we often find it helpful to describe the domain of valid values an attribute can take. 99.99 makes sense for the average price described above, while hello worlddoes not. A layer of abstraction is introduced, and we might describe the range of valid values for this average price as a numeric value representing a unit of currency with up to two decimals of precision between the range of 0.00 and 9999.99. We describe that aspect of the schema as a data type. The &ldquo;currency&rdquo; data type we just defined allows us to be more specific about the meaning of the attribute in our schema. Better still, if we can describe the data type to our database, we can let it monitor and constrain the accepted values used in that attribute. That&rsquo;s helpful for humans because the computer is probably better as managing these constraints than we are. It&rsquo;s also helpful for the database because it no longer needs to store &ldquo;any of the things&rdquo; in this attribute. Instead, it only must store any of the valid values of this data type. That allows it to optimize the way it stores those values and potentially provide other meaningful operations on those values. With a data type defined, it opens the database to be able to answer queries about the data and ranges of data instead of just persisting and retrieving values. &ldquo;What&rsquo;s the lowest average price?&rdquo; &ldquo;What&rsquo;s the highest?&rdquo; &ldquo;By how much do the average prices deviate?&rdquo; The filesystem upon which my hierarchical database sat couldn&rsquo;t answer questions like those. Data types bridge the gap between persistence layers and schema, allowing the database to share in the responsibility of value constraint management and allowing it to do more than just persist values. But data types are only half of the story. Just because I&rsquo;ve declared an attribute to be of type &ldquo;numeric&rdquo; doesn&rsquo;t mean the database can persist it. A data type can be implemented that honors the constraints upon numerical values, but there&rsquo;s still another step between my value and the sequence of binary digits. That step is the encoding. An encoding is a way to represent a value in binary digits. The simplest encoding for integer values is the representation of that number in base-2; this is a literal representation in binary digits. Encodings come with limitations though, this one included. In this case, it provides no means to represent a negative integer value. The 2&rsquo;s compliment encoding has the advantage of being able to represent negative integers. It also enjoys the convenience that most arithmetic operations on values in this encoding behave naturally. Binary coded decimal is another encoding for integer values. It has different properties and different advantages and disadvantages than 2&rsquo;s compliment. Both are equally valid ways to represent integers as a sequence of binary data. Thus an integer data type, honoring all the constraints of integer values can be encoded in multiple ways. Continuing the example, just like there are multiple valid relational schema designs to derive meaning over a data set of mobile subscribers, so too are there multiple valid encodings to represent an integer value [2]. Data types for HBase Thus far in its lifetime, HBase has provided data persistence. It does so in a rather unique way as compared to other databases. That method of persistence influences the semantics it exposes around persisting and retrieving the data it stores. To date, those semantics have exposed a very simple logical data model, that of a sorted, nested map of maps. That data model is heavily influenced by the physical data model of the database implementation. Technically this data model is a schema because it defines a logical structure for data, complete with a data type. However, this model is very rudimentary as schemas go. It provides very few facilities for mapping application-level meaning to physical layout. The only data type this logical data model exposes is the humble byte[] and its encoding is a simple no-op [3]. While the byte[] is strictly sufficient, it&rsquo;s not particularly convenient for application developers. I don&rsquo;t want to think about my average subscription price as a byte[], but rather as a value conforming to the numeric type described earlier. HBase requires that I accept the burden of both data type constraint maintenance and data value encoding into my application. HBase does provide a number of data encodings for Java languages primitive types. These encodings are implemented in the toXXX methods on the Bytes class. These methods transform the Java types into byte[]and back again. The trouble is they (mostly, partially) don&rsquo;t preserve the sort order of the values they represent. This is a problem. HBase&rsquo;s semantics of a sorted map of maps is extremely important in designing table layouts for applications. The sort order influences physical layout of data on disk, which has direct impact on data access latency. The practice of HBase &ldquo;schema design&rdquo; is the task of laying out your data physically so as to minimize the latency of the access patterns that are important to your application. A major aspect of that is in designing a rowkey that orders well for the application. Because the default encodings do not always honor the natural sorting of the values they represent, it can become difficult to reason about application performance. Application developers are left to devise their own encoding systems that honor the natural sorting of any data types they wish to use. Doing more for application developers In HBASE-8089, I proposed that we expand the set of data types that HBase exposes to include a number of new members. The idea being that those other types make it easier for developers to build applications. It includes an initial list of suggested data types and some proposals about how they might be implemented, hinting toward considerations of order-preserving encodings. HBASE-8201 defines a new utility class for data encodings called OrderedBytes. The encodings implemented there are designed primarily to produce byte[]s that preserve the natural sort order of the values they represent. They are also implemented in such a way as to be self-identifying. Meaning, an encoded value can be inspected to determine which encoding it represents. This last feature makes the encoding scheme at least rudimentarily machine readable and is particularly valuable, in my opinion. It enables reader tools (a raw data inspector, for example) to be encoding aware even in the absence of knowledge about schema or data types. HBASE-8693 advocates an extensible data type API, so that application developers can easily introduce new data types. This allows HBase applications to implement their own data types that the HBase community hasn&rsquo;t thought of or does not think are appropriate to ship with the core system. The working implementation of that DataType API and a number of pre-supported data types are provided. Those data types are built on the two codecs, Bytes and OrderedBytes. That means application developers will have access to basic constructs like number and Strings in addition to byte[]. It also means that sophisticated users can develop highly specialized data types for use as the foundation of extensions to HBase. My hope is this will make extension efforts on par with PostGIS possible in HBase. Please take note that nothing here approaches the topic of schema or schema management. My personal opinion is that not enough complex applications have been written against HBase for the project to ship with such a system out of the box. Two notable efforts which are imposing schema onto HBase are Phoenix and Kiji. The former seeks to translate a subset of the Relational model onto HBase. The latter is devising its own solution, presumably modeled after its authors&rsquo; own experiences. In both cases, I hope these projects can benefit by HBase providing some additional data encodings and an API for user-extensible data types. Conclusions It&rsquo;s an exciting time to be building large, data-driven applications. We enjoy a wealth of new tools, not just HBase, to make that easier than ever before. Still, those same tools that make things possible are still in infant stages of usability. Hopefully these efforts will move the conversation forward. Please take a moment to review these tickets. Let us know what data types we haven&rsquo;t thought about and what encoding schemes you fancy. Poke holes in the data type extension API and provide counter examples that you can&rsquo;t implement due to lack of expression. Take this opportunity to customize your tools to better fit your own hands. Notes [1] The term NoSQL is used to reference pretty much anything that stores data and didn&rsquo;t exist a decade ago. This includes quite an array of data tools. Amandeep and I studied and summarized the landscape in a short body of work that was cut from the book. Key-value stores, graph databases, in-memory stores, object stores, and hybrids of the above all make the cut. About all they can agree on is they don&rsquo;t like using the relational model to describe their data. [2] For more fun, check out the ZigZag encoding described in the documentation of Google&rsquo;s protobuf. [3] That&rsquo;s almost true. HBase also provides a uint64 data type exposed through the Increment API." />
<link rel="canonical" href="http://localhost:4000/hbase/entry/data_types_schema" />
<meta property="og:url" content="http://localhost:4000/hbase/entry/data_types_schema" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-07-29T19:26:11-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Data Types != Schema" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2013-07-29T19:26:11-04:00","datePublished":"2013-07-29T19:26:11-04:00","description":"by Nick Dimiduk&nbsp; &lt;/p&gt; My work on adding data types to&nbsp;HBase has come along far enough that ambiguities in the conversation are finally starting to shake out. These were issues I&rsquo;d hoped to address through initial design documentation and a draft specification. Unfortunately, it&rsquo;s not until there&rsquo;s real code implemented that the finer points are addressed in concrete. I&rsquo;d like to take a step back from the code for a moment to initiate the conversation again and hopefully clarify some points about how I&rsquo;ve approached this new feature. If you came here looking for code, you&rsquo;re out of luck. Go check out the parent ticket, HBASE-8089. For those who don&rsquo;t care about my personal experiences with information theory, skip down to the TL;DR section at the end. You might also be satisfied by the slides I presented on this same topic at the Hadoop Summit HBase session in June. A database by any other name &ldquo;HBase is a database.&rdquo; This is the very first statement in HBase in Action. Amandeep and I debated, both between ourselves and with a few of our confidants, as to whether we should make that statement. The concern in my mind was never over the validity of the claim, but rather how it would be interpreted. &ldquo;Database&rdquo; has come to encompass a great deal of technologies and features, many of those features HBase doesn&rsquo;t (yet) support. The confusion is worsened by the recent popularity of non-relational databases under the umbrella title NoSQL, a term which itself is confused [1]. In this post, I hope to tease apart some of these related ideas. My experience with data persistence systems started with my first position out of university. I worked for a small company whose product, at its core, was a hierarchical database. That database had a very bare concept of tables and there was no SQL interface. It&rsquo;s primary construct was a hierarchy of nodes and its query engine was very good at traversing that hierarchy. The hierarchy was also all it exposed to its consumers, and querying the database was semantically equivalent to walking that hierarchy and executing functions on an individual node and its children. The only way to communicate with it was via a Java API, or later, the C++ interface. For a very long time, the only data type it could persist was a C-style char[]. Yet a client could connect to the database server over the network, persist data into it, and issue queries to retrieve previously persisted data and transformed versions thereof. It didn&rsquo;t support SQL, it only spoke in Strings, but it was a database. Under the hood, this data storage system used an open source, embedded database library with which you&rsquo;re very likely familiar. The API for that database exposed a linear sequence of pages allocated from disk. Each page held a byte[]. You can think of the whole database as a persisted byte[][]. Queries against that database involved requesting a specific page by its ID and it returned to you the raw block of data that resided there. Our database engine delegated persistence responsibilities to that system, using it to manage it&rsquo;s own concepts and data structures in a format that could be serialized to bytes on disk. Indeed, that embedded database library delegated much of its own persistence responsibilities to the operating system&rsquo;s filesystem implementation. In common usage, the word &ldquo;database&rdquo; tends to be shorthand for Relational Database Management System. Neither the hierarchical database, the embedded database, nor the filesystem qualify by this definition. Yet all three persist and retrieve data according to well defined semantics. HBase is also not a Relational Database Management System, but it persists and retrieves data according to well defined semantics. HBase is a database. Data management as a continuum Please bear with me as I wander blindly into the world of information theory. I think of data management as a continuum. On the one extreme, we have the raw physical substrate on which information is expressed as matter. On the far other extreme is our ability to reason and form understandings about a catalog of knowledge. In computer systems, we narrow the scope of that continuum, but it&rsquo;s still a range from the physical allocation of bits to a structure that can be interpreted by humans. physical bits meaning | | |-------------------|-------------------| | | database A database provides an interface over which the persisted data is available for interaction. Those interacting with it are generally technical humans and systems that expose that data to non-technical humans through applications. The humans&rsquo; goal is primarily to derive meaning from that persisted data. The RDBMS exposes an interface that&rsquo;s a lot closer to the human level than HBase or my other examples. That interface is brought closer in large part because the RDBMS includes a system of metadata description and management called aschema. Exposing a schema, a way to describe the data physically persisted, acts as a bridge from database to non-technical humans. It allows the human to describe the information they want to persist in a way that has meaning to both the human and the database. A schema is metadata. It&rsquo;s a description of the shape of the data and also provides hints to its intended meaning. Computer systems represent data as sequences of binary data. The schema helps us make sense of those digits. A schema can tell us that 0x01c7c6 represents the numeric value 99.99 which means &ldquo;the average price of your monthly mobile phone bill.&rdquo; In addition to providing data management tools, most RDBMSs provided schema management tools. Managing schema is just as important as managing the data itself. I say that because without schema, how can I begin to understand what this collection of data means? As knowledge and needs change, so too does data. Just as the data management tools provide a method for changing data values, the schema management tools provide a method for tracking the change in meaning of the data. From here to there A database does not get a schema for free. In order to describe meaning of persisted data, a schema needs a few building block concepts. Relational systems derive their name from the system of relational algebra upon which they describe their data and its access. A table contains records that all conform to a particular shape and that shape is described by a sequence of labeled columns. Tables often represent something specific and the columns describe attributes of that something. As humans, we often find it helpful to describe the domain of valid values an attribute can take. 99.99 makes sense for the average price described above, while hello worlddoes not. A layer of abstraction is introduced, and we might describe the range of valid values for this average price as a numeric value representing a unit of currency with up to two decimals of precision between the range of 0.00 and 9999.99. We describe that aspect of the schema as a data type. The &ldquo;currency&rdquo; data type we just defined allows us to be more specific about the meaning of the attribute in our schema. Better still, if we can describe the data type to our database, we can let it monitor and constrain the accepted values used in that attribute. That&rsquo;s helpful for humans because the computer is probably better as managing these constraints than we are. It&rsquo;s also helpful for the database because it no longer needs to store &ldquo;any of the things&rdquo; in this attribute. Instead, it only must store any of the valid values of this data type. That allows it to optimize the way it stores those values and potentially provide other meaningful operations on those values. With a data type defined, it opens the database to be able to answer queries about the data and ranges of data instead of just persisting and retrieving values. &ldquo;What&rsquo;s the lowest average price?&rdquo; &ldquo;What&rsquo;s the highest?&rdquo; &ldquo;By how much do the average prices deviate?&rdquo; The filesystem upon which my hierarchical database sat couldn&rsquo;t answer questions like those. Data types bridge the gap between persistence layers and schema, allowing the database to share in the responsibility of value constraint management and allowing it to do more than just persist values. But data types are only half of the story. Just because I&rsquo;ve declared an attribute to be of type &ldquo;numeric&rdquo; doesn&rsquo;t mean the database can persist it. A data type can be implemented that honors the constraints upon numerical values, but there&rsquo;s still another step between my value and the sequence of binary digits. That step is the encoding. An encoding is a way to represent a value in binary digits. The simplest encoding for integer values is the representation of that number in base-2; this is a literal representation in binary digits. Encodings come with limitations though, this one included. In this case, it provides no means to represent a negative integer value. The 2&rsquo;s compliment encoding has the advantage of being able to represent negative integers. It also enjoys the convenience that most arithmetic operations on values in this encoding behave naturally. Binary coded decimal is another encoding for integer values. It has different properties and different advantages and disadvantages than 2&rsquo;s compliment. Both are equally valid ways to represent integers as a sequence of binary data. Thus an integer data type, honoring all the constraints of integer values can be encoded in multiple ways. Continuing the example, just like there are multiple valid relational schema designs to derive meaning over a data set of mobile subscribers, so too are there multiple valid encodings to represent an integer value [2]. Data types for HBase Thus far in its lifetime, HBase has provided data persistence. It does so in a rather unique way as compared to other databases. That method of persistence influences the semantics it exposes around persisting and retrieving the data it stores. To date, those semantics have exposed a very simple logical data model, that of a sorted, nested map of maps. That data model is heavily influenced by the physical data model of the database implementation. Technically this data model is a schema because it defines a logical structure for data, complete with a data type. However, this model is very rudimentary as schemas go. It provides very few facilities for mapping application-level meaning to physical layout. The only data type this logical data model exposes is the humble byte[] and its encoding is a simple no-op [3]. While the byte[] is strictly sufficient, it&rsquo;s not particularly convenient for application developers. I don&rsquo;t want to think about my average subscription price as a byte[], but rather as a value conforming to the numeric type described earlier. HBase requires that I accept the burden of both data type constraint maintenance and data value encoding into my application. HBase does provide a number of data encodings for Java languages primitive types. These encodings are implemented in the toXXX methods on the Bytes class. These methods transform the Java types into byte[]and back again. The trouble is they (mostly, partially) don&rsquo;t preserve the sort order of the values they represent. This is a problem. HBase&rsquo;s semantics of a sorted map of maps is extremely important in designing table layouts for applications. The sort order influences physical layout of data on disk, which has direct impact on data access latency. The practice of HBase &ldquo;schema design&rdquo; is the task of laying out your data physically so as to minimize the latency of the access patterns that are important to your application. A major aspect of that is in designing a rowkey that orders well for the application. Because the default encodings do not always honor the natural sorting of the values they represent, it can become difficult to reason about application performance. Application developers are left to devise their own encoding systems that honor the natural sorting of any data types they wish to use. Doing more for application developers In HBASE-8089, I proposed that we expand the set of data types that HBase exposes to include a number of new members. The idea being that those other types make it easier for developers to build applications. It includes an initial list of suggested data types and some proposals about how they might be implemented, hinting toward considerations of order-preserving encodings. HBASE-8201 defines a new utility class for data encodings called OrderedBytes. The encodings implemented there are designed primarily to produce byte[]s that preserve the natural sort order of the values they represent. They are also implemented in such a way as to be self-identifying. Meaning, an encoded value can be inspected to determine which encoding it represents. This last feature makes the encoding scheme at least rudimentarily machine readable and is particularly valuable, in my opinion. It enables reader tools (a raw data inspector, for example) to be encoding aware even in the absence of knowledge about schema or data types. HBASE-8693 advocates an extensible data type API, so that application developers can easily introduce new data types. This allows HBase applications to implement their own data types that the HBase community hasn&rsquo;t thought of or does not think are appropriate to ship with the core system. The working implementation of that DataType API and a number of pre-supported data types are provided. Those data types are built on the two codecs, Bytes and OrderedBytes. That means application developers will have access to basic constructs like number and Strings in addition to byte[]. It also means that sophisticated users can develop highly specialized data types for use as the foundation of extensions to HBase. My hope is this will make extension efforts on par with PostGIS possible in HBase. Please take note that nothing here approaches the topic of schema or schema management. My personal opinion is that not enough complex applications have been written against HBase for the project to ship with such a system out of the box. Two notable efforts which are imposing schema onto HBase are Phoenix and Kiji. The former seeks to translate a subset of the Relational model onto HBase. The latter is devising its own solution, presumably modeled after its authors&rsquo; own experiences. In both cases, I hope these projects can benefit by HBase providing some additional data encodings and an API for user-extensible data types. Conclusions It&rsquo;s an exciting time to be building large, data-driven applications. We enjoy a wealth of new tools, not just HBase, to make that easier than ever before. Still, those same tools that make things possible are still in infant stages of usability. Hopefully these efforts will move the conversation forward. Please take a moment to review these tickets. Let us know what data types we haven&rsquo;t thought about and what encoding schemes you fancy. Poke holes in the data type extension API and provide counter examples that you can&rsquo;t implement due to lack of expression. Take this opportunity to customize your tools to better fit your own hands. Notes [1] The term NoSQL is used to reference pretty much anything that stores data and didn&rsquo;t exist a decade ago. This includes quite an array of data tools. Amandeep and I studied and summarized the landscape in a short body of work that was cut from the book. Key-value stores, graph databases, in-memory stores, object stores, and hybrids of the above all make the cut. About all they can agree on is they don&rsquo;t like using the relational model to describe their data. [2] For more fun, check out the ZigZag encoding described in the documentation of Google&rsquo;s protobuf. [3] That&rsquo;s almost true. HBase also provides a uint64 data type exposed through the Increment API.","headline":"Data Types != Schema","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/hbase/entry/data_types_schema"},"url":"http://localhost:4000/hbase/entry/data_types_schema"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Data Types != Schema</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2013-07-29T19:26:11-04:00" itemprop="datePublished">Jul 29, 2013
      </time> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Michael Stack", "login"=>"stack", "email"=>"stack@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>by Nick Dimiduk&nbsp;</p></p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">My work on adding data types to&nbsp;<a href="http://hbase.apache.org/" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">HBase</a> has come along far enough that ambiguities in the conversation are finally starting to shake out. These were issues I&rsquo;d hoped to address through initial <a href="https://issues.apache.org/jira/browse/HBASE-8089" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">design documentation</a> and a draft specification. Unfortunately, it&rsquo;s not until there&rsquo;s real code implemented that the finer points are addressed in concrete. I&rsquo;d like to take a step back from the code for a moment to initiate the conversation again and hopefully clarify some points about how I&rsquo;ve approached this new feature.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">If you came here looking for code, you&rsquo;re out of luck. Go check out the parent ticket, <a href="https://issues.apache.org/jira/browse/HBASE-8089" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">HBASE-8089</a>. For those who don&rsquo;t care about my personal experiences with information theory, skip down to the <a href="http://www.n10k.com/blog/data-types-not-equal-schema/#tldr" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">TL;DR</a> section at the end. You might also be satisfied by the <a href="http://ndimiduk.github.io/hbase-datatypes-wip/" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">slides</a> I presented on this same topic at the Hadoop Summit HBase session in June.</p>
<h2 style="margin-top: 0px; margin-bottom: 1em; padding: 0.8em 0px 0px; border: 0px; font-family: 'Libre Baskerville', Georgia, 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 1.5em; vertical-align: baseline; text-rendering: optimizelegibility; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAABCAYAAACsXeyTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAFUlEQVQIHWNIS0sr/v//PwMMDzY+ADqMahlW4J91AAAAAElFTkSuQmCC); color: #222222; letter-spacing: normal; background-position: 0% 0%; background-repeat: repeat no-repeat;"><a id="a_database" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; line-height: inherit; font-size: 24px; vertical-align: baseline; color: #1863a1; transition: color 0.3s; -webkit-transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">A database by any other name</a></h2>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">&ldquo;HBase is a database.&rdquo; This is the very first statement in <a href="http://www.manning.com/dimidukkhurana/" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">HBase in Action</a>. Amandeep and I debated, both between ourselves and with a few of our confidants, as to whether we should make that statement. The concern in my mind was never over the validity of the claim, but rather how it would be interpreted. &ldquo;Database&rdquo; has come to encompass a great deal of technologies and features, many of those features HBase doesn&rsquo;t (yet) support. The confusion is worsened by the recent popularity of non-relational databases under the umbrella title <a href="http://en.wikipedia.org/wiki/NoSQL" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">NoSQL</a>, a term which itself is confused <a href="http://www.n10k.com/blog/data-types-not-equal-schema/#1" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">[1]</a>. In this post, I hope to tease apart some of these related ideas.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">My experience with data persistence systems started with my first position out of university. I worked for a small company whose product, at its core, was a hierarchical database. That database had a very bare concept of tables and there was no SQL interface. It&rsquo;s primary construct was a hierarchy of nodes and its query engine was very good at traversing that hierarchy. The hierarchy was also all it exposed to its consumers, and querying the database was semantically equivalent to walking that hierarchy and executing functions on an individual node and its children. The only way to communicate with it was via a Java API, or later, the C++ interface. For a very long time, the only data type it could persist was a C-style <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">char[]</code>. Yet a client could connect to the database server over the network, persist data into it, and issue queries to retrieve previously persisted data and transformed versions thereof. It didn&rsquo;t support SQL, it only spoke in <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">Strings</code>, but it was a database.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">Under the hood, this data storage system used an open source, embedded database library with which you&rsquo;re very likely familiar. The API for that database exposed a linear sequence of pages allocated from disk. Each page held a <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">byte[]</code>. You can think of the whole database as a persisted <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">byte[][]</code>. Queries against that database involved requesting a specific page by its ID and it returned to you the raw block of data that resided there. Our database engine delegated persistence responsibilities to that system, using it to manage it&rsquo;s own concepts and data structures in a format that could be serialized to bytes on disk. Indeed, that embedded database library delegated much of its own persistence responsibilities to the operating system&rsquo;s filesystem implementation.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">In common usage, the word &ldquo;database&rdquo; tends to be shorthand for <em style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline;">Relational Database Management System</em>. Neither the hierarchical database, the embedded database, nor the filesystem qualify by this definition. Yet all three persist and retrieve data according to well defined semantics. HBase is also not a Relational Database Management System, but it persists and retrieves data according to well defined semantics. HBase is a database.</p>
<h2 style="margin-top: 0px; margin-bottom: 1em; padding: 0.8em 0px 0px; border: 0px; font-family: 'Libre Baskerville', Georgia, 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 1.5em; vertical-align: baseline; text-rendering: optimizelegibility; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAABCAYAAACsXeyTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAFUlEQVQIHWNIS0sr/v//PwMMDzY+ADqMahlW4J91AAAAAElFTkSuQmCC); color: #222222; letter-spacing: normal; background-position: 0% 0%; background-repeat: repeat no-repeat;"><a id="continuum" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; line-height: inherit; font-size: 24px; vertical-align: baseline; color: #1863a1; transition: color 0.3s; -webkit-transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">Data management as a continuum</a></h2>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">Please bear with me as I wander blindly into the world of information theory.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">I think of data management as a continuum. On the one extreme, we have the raw physical substrate on which information is expressed as matter. On the far other extreme is our ability to reason and form understandings about a catalog of knowledge. In computer systems, we narrow the scope of that continuum, but it&rsquo;s still a range from the <em style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline;">physical allocation of bits</em> to a <em style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline;">structure that can be interpreted</em> by humans.</p>
<pre style="margin-top: 0px; margin-bottom: 2.1em; padding: 0.8em 1em; border: 1px solid #05232b; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; line-height: 1.45em; vertical-align: baseline; -webkit-box-shadow: rgba(0, 0, 0, 0.0588235) 0px 0px 10px; box-shadow: rgba(0, 0, 0, 0.0588235) 0px 0px 10px; background-image: url(http://www.n10k.com/images/noise.png?1366959713); background-color: #002b36; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em; color: #93a1a1; overflow: auto; background-position: 0% 0%;"><code style="margin: 0px; padding: 0px; border: 0px; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline;">physical bits                             meaning
     |                                       |
     |-------------------|-------------------|
     |                                       |
                      database
</code></pre>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">A database provides an interface over which the persisted data is available for interaction. Those interacting with it are generally technical humans and systems that expose that data to non-technical humans through applications. The humans&rsquo; goal is primarily to derive meaning from that persisted data. The RDBMS exposes an interface that&rsquo;s a lot closer to the human level than HBase or my other examples. That interface is brought closer in large part because the RDBMS includes a system of metadata description and management called a<em style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline;">schema</em>. Exposing a schema, a way to describe the data physically persisted, acts as a bridge from database to non-technical humans. It allows the human to describe the information they want to persist in a way that has meaning to both the human and the database.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;"><em style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline;">A schema is metadata.</em> It&rsquo;s a description of the shape of the data and also provides hints to its intended meaning. Computer systems represent data as sequences of binary data. The schema helps us make sense of those digits. A schema can tell us that <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">0x01c7c6</code> represents the numeric value <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">99.99</code> which means &ldquo;the average price of your monthly mobile phone bill.&rdquo;</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">In addition to providing data management tools, most RDBMSs provided schema management tools. Managing schema is just as important as managing the data itself. I say that because without schema, how can I begin to understand what this collection of data means? As knowledge and needs change, so too does data. Just as the data management tools provide a method for changing data values, the schema management tools provide a method for tracking the change in meaning of the data.</p>
<h2 style="margin-top: 0px; margin-bottom: 1em; padding: 0.8em 0px 0px; border: 0px; font-family: 'Libre Baskerville', Georgia, 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 1.5em; vertical-align: baseline; text-rendering: optimizelegibility; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAABCAYAAACsXeyTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAFUlEQVQIHWNIS0sr/v//PwMMDzY+ADqMahlW4J91AAAAAElFTkSuQmCC); color: #222222; letter-spacing: normal; background-position: 0% 0%; background-repeat: repeat no-repeat;"><a id="here_to_there" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; line-height: inherit; font-size: 24px; vertical-align: baseline; color: #1863a1; transition: color 0.3s; -webkit-transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">From here to there</a></h2>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">A database does not get a schema for free. In order to describe meaning of persisted data, a schema needs a few building block concepts. Relational systems derive their name from the system of <a href="http://en.wikipedia.org/wiki/Relational_model" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">relational algebra</a> upon which they describe their data and its access. A table contains records that all conform to a particular <em style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline;">shape</em> and that shape is described by a sequence of labeled columns. Tables often represent something specific and the columns describe attributes of that something. As humans, we often find it helpful to describe the domain of valid values an attribute can take. <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">99.99</code> makes sense for the average price described above, while <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">hello world</code>does not. A layer of abstraction is introduced, and we might describe the range of valid values for this average price as a numeric value representing a unit of currency with up to two decimals of precision between the range of <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">0.00</code> and <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">9999.99</code>. We describe that aspect of the schema as a <em style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline;">data type</em>.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">The &ldquo;currency&rdquo; data type we just defined allows us to be more specific about the meaning of the attribute in our schema. Better still, if we can describe the data type to our database, we can let it monitor and constrain the accepted values used in that attribute. That&rsquo;s helpful for humans because the computer is probably better as managing these constraints than we are. It&rsquo;s also helpful for the database because it no longer needs to store &ldquo;any of the things&rdquo; in this attribute. Instead, it only must store any of the valid values of this data type. That allows it to optimize the way it stores those values and potentially provide other meaningful operations on those values. With a data type defined, it opens the database to be able to answer queries about the data and ranges of data instead of just persisting and retrieving values. &ldquo;What&rsquo;s the lowest average price?&rdquo; &ldquo;What&rsquo;s the highest?&rdquo; &ldquo;By how much do the average prices deviate?&rdquo;</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">The filesystem upon which my hierarchical database sat couldn&rsquo;t answer questions like those.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">Data types bridge the gap between persistence layers and schema, allowing the database to share in the responsibility of value constraint management and allowing it to do more than just persist values. But data types are only half of the story. Just because I&rsquo;ve declared an attribute to be of type &ldquo;numeric&rdquo; doesn&rsquo;t mean the database can persist it. A data type can be implemented that honors the constraints upon numerical values, but there&rsquo;s still another step between my value and the sequence of binary digits. That step is the <em style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline;">encoding.</em></p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">An encoding is a way to represent a value in binary digits. The simplest encoding for integer values is the representation of that number in base-2; this is a literal representation in binary digits. Encodings come with limitations though, this one included. In this case, it provides no means to represent a negative integer value. The <a href="http://en.wikipedia.org/wiki/Two's_complement" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">2&rsquo;s compliment</a> encoding has the advantage of being able to represent negative integers. It also enjoys the convenience that most arithmetic operations on values in this encoding behave naturally.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;"><a href="http://en.wikipedia.org/wiki/Binary-coded_decimal" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">Binary coded decimal</a> is another encoding for integer values. It has different properties and different advantages and disadvantages than 2&rsquo;s compliment. Both are equally valid ways to represent integers as a sequence of binary data. Thus an integer data type, honoring all the constraints of integer values can be encoded in multiple ways. Continuing the example, just like there are multiple valid relational schema designs to derive meaning over a data set of mobile subscribers, so too are there multiple valid encodings to represent an integer value <a href="http://www.n10k.com/blog/data-types-not-equal-schema/#2" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">[2]</a>.</p>
<h2 style="margin-top: 0px; margin-bottom: 1em; padding: 0.8em 0px 0px; border: 0px; font-family: 'Libre Baskerville', Georgia, 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 1.5em; vertical-align: baseline; text-rendering: optimizelegibility; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAABCAYAAACsXeyTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAFUlEQVQIHWNIS0sr/v//PwMMDzY+ADqMahlW4J91AAAAAElFTkSuQmCC); color: #222222; letter-spacing: normal; background-position: 0% 0%; background-repeat: repeat no-repeat;"><a id="data_types" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; line-height: inherit; font-size: 24px; vertical-align: baseline; color: #1863a1; transition: color 0.3s; -webkit-transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">Data types for HBase</a></h2>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">Thus far in its lifetime, HBase has provided data persistence. It does so in a rather unique way as compared to other databases. That method of persistence influences the semantics it exposes around persisting and retrieving the data it stores. To date, those semantics have exposed a very simple logical data model, that of a sorted, nested map of maps. That data model is heavily influenced by the physical data model of the database implementation.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">Technically this data model is a schema because it defines a logical structure for data, complete with a data type. However, this model is very rudimentary as schemas go. It provides very few facilities for mapping application-level meaning to physical layout. The only data type this logical data model exposes is the humble <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">byte[]</code> and its encoding is a simple no-op <a href="http://www.n10k.com/blog/data-types-not-equal-schema/#3" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">[3]</a>.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">While the <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">byte[]</code> is strictly sufficient, it&rsquo;s not particularly convenient for application developers. I don&rsquo;t want to think about my average subscription price as a <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">byte[]</code>, but rather as a value conforming to the numeric type described earlier. HBase requires that I accept the burden of both data type constraint maintenance and data value encoding into my application.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">HBase does provide a number of data encodings for Java languages primitive types. These encodings are implemented in the <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">toXXX</code> methods on the <a href="http://hbase.apache.org/0.94/apidocs/org/apache/hadoop/hbase/util/Bytes.html" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;"><code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">Bytes</code></a> class. These methods transform the Java types into <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">byte[]</code>and back again. The trouble is they (mostly, partially) don&rsquo;t preserve the sort order of the values they represent. This is a problem.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">HBase&rsquo;s semantics of a <em style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline;">sorted</em> map of maps is extremely important in designing table layouts for applications. The sort order influences physical layout of data on disk, which has direct impact on data access latency. The practice of HBase &ldquo;schema design&rdquo; is the task of laying out your data physically so as to minimize the latency of the access patterns that are important to your application. A major aspect of that is in designing a rowkey that orders well for the application. Because the default encodings do not always honor the natural sorting of the values they represent, it can become difficult to reason about application performance. Application developers are left to devise their own encoding systems that honor the natural sorting of any data types they wish to use.</p>
<h2 style="margin-top: 0px; margin-bottom: 1em; padding: 0.8em 0px 0px; border: 0px; font-family: 'Libre Baskerville', Georgia, 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 1.5em; vertical-align: baseline; text-rendering: optimizelegibility; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAABCAYAAACsXeyTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAFUlEQVQIHWNIS0sr/v//PwMMDzY+ADqMahlW4J91AAAAAElFTkSuQmCC); color: #222222; letter-spacing: normal; background-position: 0% 0%; background-repeat: repeat no-repeat;"><a id="tldr" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; line-height: inherit; font-size: 24px; vertical-align: baseline; color: #1863a1; transition: color 0.3s; -webkit-transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">Doing more for application developers</a></h2>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">In <a href="https://issues.apache.org/jira/browse/HBASE-8089" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">HBASE-8089</a>, I proposed that we expand the set of data types that HBase exposes to include a number of new members. The idea being that those other types make it easier for developers to build applications. It includes an initial list of suggested data types and some proposals about how they might be implemented, hinting toward considerations of order-preserving encodings.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;"><a href="https://issues.apache.org/jira/browse/HBASE-8201" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">HBASE-8201</a> defines a new utility class for data encodings called <a href="https://github.com/ndimiduk/hbase/blob/8201-OrderedBytes/hbase-common/src/main/java/org/apache/hadoop/hbase/util/OrderedBytes.java" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;"><code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">OrderedBytes</code></a>. The encodings implemented there are designed primarily to produce <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">byte[]</code>s that preserve the natural sort order of the values they represent. They are also implemented in such a way as to be self-identifying. Meaning, an encoded value can be inspected to determine which encoding it represents. This last feature makes the encoding scheme at least rudimentarily <a href="http://en.wikipedia.org/wiki/Machine-readable_data" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">machine readable</a> and is particularly valuable, in my opinion. It enables reader tools (a raw data inspector, for example) to be encoding aware even in the absence of knowledge about schema or data types.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;"><a href="https://issues.apache.org/jira/browse/HBASE-8693" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">HBASE-8693</a> advocates an extensible data type API, so that application developers can easily introduce new data types. This allows HBase applications to implement their own data types that the HBase community hasn&rsquo;t thought of or does not think are appropriate to ship with the core system. The working implementation of that <a href="https://github.com/ndimiduk/hbase/blob/8693-datatypes-api/hbase-common/src/main/java/org/apache/hadoop/hbase/types/DataType.java" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">DataType</a> API and a number of pre-supported data <a href="https://github.com/ndimiduk/hbase/tree/8693-datatypes-api/hbase-common/src/main/java/org/apache/hadoop/hbase/types" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">types</a> are provided. Those data types are built on the two codecs, <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">Bytes</code> and <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">OrderedBytes</code>. That means application developers will have access to basic constructs like number and Strings in addition to <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">byte[]</code>. It also means that sophisticated users can develop highly specialized data types for use as the foundation of extensions to HBase. My hope is this will make extension efforts on par with <a href="http://postgis.net/" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">PostGIS</a> possible in HBase.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">Please take note that nothing here approaches the topic of schema or schema management. My personal opinion is that not enough complex applications have been written against HBase for the project to ship with such a system out of the box. Two notable efforts which are imposing schema onto HBase are <a href="https://github.com/forcedotcom/phoenix" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">Phoenix</a> and <a href="http://www.kiji.org/" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">Kiji</a>. The former seeks to translate a subset of the Relational model onto HBase. The latter is devising its own solution, presumably modeled after its authors&rsquo; own experiences. In both cases, I hope these projects can benefit by HBase providing some additional data encodings and an API for user-extensible data types.</p>
<h2 style="margin-top: 0px; margin-bottom: 1em; padding: 0.8em 0px 0px; border: 0px; font-family: 'Libre Baskerville', Georgia, 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 1.5em; vertical-align: baseline; text-rendering: optimizelegibility; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAABCAYAAACsXeyTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAFUlEQVQIHWNIS0sr/v//PwMMDzY+ADqMahlW4J91AAAAAElFTkSuQmCC); color: #222222; letter-spacing: normal; background-position: 0% 0%; background-repeat: repeat no-repeat;"><a id="fin" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; line-height: inherit; font-size: 24px; vertical-align: baseline; color: #1863a1; transition: color 0.3s; -webkit-transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">Conclusions</a></h2>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;">It&rsquo;s an exciting time to be building large, data-driven applications. We enjoy a wealth of new tools, not just HBase, to make that easier than ever before. Still, those same tools that make things possible are still in infant stages of usability. Hopefully these efforts will move the conversation forward. Please take a moment to review these tickets. Let us know what data types we haven&rsquo;t thought about and what encoding schemes you fancy. Poke holes in the data type extension API and provide counter examples that you can&rsquo;t implement due to lack of expression. Take this opportunity to customize your tools to better fit your own hands.</p>
<h3 style="margin-top: 0px; margin-bottom: 1em; padding: 0px; border: 0px; font-family: 'Libre Baskerville', Georgia, 'Helvetica Neue', Arial, sans-serif; font-style: italic; line-height: 24px; font-size: 1.3em; vertical-align: baseline; text-rendering: optimizelegibility; color: #222222; letter-spacing: normal;"><a id="notes" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; line-height: inherit; font-size: 21px; vertical-align: baseline; color: #1863a1; transition: color 0.3s; -webkit-transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">Notes</a></h3>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;"><a id="1" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">[1]</a> The term NoSQL is used to reference pretty much anything that stores data and didn&rsquo;t exist a decade ago. This includes quite an array of data tools. Amandeep and I studied and summarized the landscape in a short body of work that was cut from the book. Key-value stores, graph databases, in-memory stores, object stores, and hybrids of the above all make the cut. About all they can agree on is they don&rsquo;t like using the relational model to describe their data.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;"><a id="2" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">[2]</a> For more fun, check out the <a href="https://developers.google.com/protocol-buffers/docs/encoding" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">ZigZag</a> encoding described in the documentation of Google&rsquo;s protobuf.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif; line-height: 24px; font-size: 16px; vertical-align: baseline; color: #222222;"><a id="3" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">[3]</a> That&rsquo;s almost true. HBase also provides a <code style="margin: -1px 0px; padding: 0px 0.3em; border: 1px solid #dddddd; font-family: Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace; font-style: inherit; font-variant: inherit; line-height: 1.5em; font-size: 0.8em; vertical-align: baseline; display: inline-block; color: #555555; border-top-left-radius: 0.4em; border-top-right-radius: 0.4em; border-bottom-right-radius: 0.4em; border-bottom-left-radius: 0.4em;">uint64</code> data type exposed through the <a href="http://hbase.apache.org/0.94/apidocs/org/apache/hadoop/hbase/client/Increment.html" style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-style: inherit; font-variant: inherit; line-height: inherit; vertical-align: baseline; color: #1863a1; -webkit-transition: color 0.3s; transition: color 0.3s; white-space: pre-wrap; word-wrap: break-word;">Increment</a> API.</p>
<div></div>

  </div><a class="u-url" href="/hbase/entry/data_types_schema" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
