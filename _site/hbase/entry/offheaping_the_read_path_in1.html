<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Offheaping the Read Path in Apache HBase: Part 2 of 2 | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Offheaping the Read Path in Apache HBase: Part 2 of 2" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="by HBase Committers Anoop Sam John,&nbsp;Ramkrishna S Vasudevan, and&nbsp;Michael Stack This is part two of a two part blog. Herein we&nbsp;compare before and after&nbsp;off heaping. See part one for preamble and&nbsp;detail on work done. Performance Results There were two parts to our performance measurement. &nbsp; Using HBase&rsquo;s built-in Performance Evaluation (PE) tool. &nbsp; Using YCSB to measure the throughput. The PE test was conducted on a single node machine. &nbsp;Table is created and loaded with 100 GB of data. &nbsp;Table has one CF and one column per row. Each cell value size is 1K. Configuration of the node : System configuration CPU : Intel(R) Xeon(R) CPU with 8 cores. RAM : 150 GB JDK : 1.8 HBase configuration HBASE_HEAPSIZE = 9 GB HBASE_OFFHEAPSIZE = 105 GB &lt;/span&gt; &nbsp;hbase.bucketcache.ioengine &nbsp;offheap &lt;/property&gt; &lt;/span&gt; &nbsp;hfile.block.cache.size &nbsp;0.2 &lt;/property&gt; &lt;/span&gt; &nbsp;hbase.bucketcache.size &nbsp;&lt;/span&gt; 104448 &lt;/value&gt; &lt;/property&gt;&lt;/font&gt;&lt;/pre&gt; 20% of the heap is allocated to the L1 cache (LRU cache). When L2 is enabled, L1 holds no data, just index and bloom filter blocks. 102 GB off heap space is allocated to the L2 cache (BucketCache) Before performing the read tests, we have made sure that all data is loaded into BucketCache so there is no i/o. &nbsp;The read workloads of PE tool run with multiple threads. &nbsp;We considerthe average completion time for each of the threads to do the required reads. 1. Each thread does 100 row multi get operations for 1000000 times. We can see that there is a 55 &ndash; 82 % reduction in average run time. See the graph below for the test for 5 to 75 threads reading. Y axis shows average completion time, in seconds, for one thread. Here each thread is doing 100000000 row get and converting this to throughput numbers we can see 5 Threads 10 Threads 20 Threads 25 Threads 50 Threads 75 Threads Throughput Without Patch 5594092.638 7152564.19 7001330.25 6920798.38 6113142.03 5463246.92 Throughput With HBASE-11425 11353315.17 19782393.7 28477858.5 28216704.3 30229746.1 30647270.3 Throughput gain 2x 2.7x 4x 4x 4.9x 5.6x So without the patch case, at the 20 threads level, the system goes to peak load situation and throughput starts to fall off. But with HBASE-11425 this is not the case and even with 75 threads. It is mostly linear scaling with more loading. &nbsp;The major factor which helps us here is reduced GC activity. 2. Each thread is doing a range scan of 10000 rows with filtering of all the data on the server side. The filtering is done to see the server side gain alone and avoid any impact of network and/or client app side bottleneck. Each thread is doing the scan operation 10000 times. We can see that there is 55 &ndash; 74 % reduction in average run time of each thread. See below the graph for the test for 5 to 75 threads reading. Y axis shows average completion time, in seconds, for one thread. 3. &nbsp;Another range scan test is performed with part of data returned back to client. &nbsp;The test will return 10% of total rows back to the client and the remaining rows are filtered out at the server. The below graph is for a test with 10, 20, 25 and 50 threads. Again Y axis gives the average thread completion time, in seconds. The gain is &nbsp;28 &ndash; 39% latency. The YCSB test is done in same cluster with 90 GB of data. We had similar system configuration and HBase configuration as for the PE tests. The YCSB setup involves creating a table with a single column family with around 90 GB of data. There are 10 columns each with 100 bytes of data (each row having 1k of data). All the readings are taken after ensuring that the entire data set is in the BucketCache. The multi get test includes each thread doing 100 row gets and 5000000 such operations. Range scan does random range scans with 1000000 operations. Threads With HBASE-11425(Ops/sec) Withoutpatch(Ops/sec) 10 28045.53 23277.97 25 45767.99 25922.18 50 58904.03 24558.72 75 63280.86 24316.74 Threads With HBASE-11425(Ops/Sec) Withoutpatch(Ops/sec) 10 5332.451701 4139.416 25 8685.456204 5340.796 50 9180.235565 5149 75 9019.192842 4981.8 For multi get there is 20 &ndash; 160 % throughput gain whereas for range scan it is 20 - 80%. With HBASE-11425 we can see there is linear throughput increase with more threads whereas old code starts performing badly when more threads (See when 50 and 75 threads) GC graphs With HBASE-11425, we serve data directly from the off heap cache rather than copy each of the blocks on heap for each of the reads. &nbsp;So we should be doing much better with respect to GC on the &nbsp;RegionServer side. &nbsp;Below are the GC graph samples taken on one RegionServer during the PE test run. &nbsp;We can clearly notice that with the changes in HBASE-11425, we are doing much less (better) GC. MultiGets &ndash; without HBASE-11425 (25 threads) Multigets &ndash; with HBASE-11425(25 threads) ScanRange10000 &ndash; without HBASE-11425 (20 threads) ScanRange10000 &ndash; with HBASE-11425 (20 threads) Future Work One implication of the findings above is that we should run with off heap Cache on always. We were reluctant to do this in the past when reads from the off heap cache took longer. This is no longer the case. We will look into making this option on by default. Also, this posting has described our conversion of the read pipeline to make it run with offheap buffers. Next up, naturally, would be making the write pipeline offheap. Conclusion Some parts of this work made it into branch-1 but to run with a fully off heap read path, you will have to wait on the HBase 2.0 release which should be available early next year (2016). Enabling L2 (BucketCache) in off heap mode will automatically turn on the off heap mechanisms described above. We hope you enjoy these improvements made to the Apache HBase read path." />
<meta property="og:description" content="by HBase Committers Anoop Sam John,&nbsp;Ramkrishna S Vasudevan, and&nbsp;Michael Stack This is part two of a two part blog. Herein we&nbsp;compare before and after&nbsp;off heaping. See part one for preamble and&nbsp;detail on work done. Performance Results There were two parts to our performance measurement. &nbsp; Using HBase&rsquo;s built-in Performance Evaluation (PE) tool. &nbsp; Using YCSB to measure the throughput. The PE test was conducted on a single node machine. &nbsp;Table is created and loaded with 100 GB of data. &nbsp;Table has one CF and one column per row. Each cell value size is 1K. Configuration of the node : System configuration CPU : Intel(R) Xeon(R) CPU with 8 cores. RAM : 150 GB JDK : 1.8 HBase configuration HBASE_HEAPSIZE = 9 GB HBASE_OFFHEAPSIZE = 105 GB &lt;/span&gt; &nbsp;hbase.bucketcache.ioengine &nbsp;offheap &lt;/property&gt; &lt;/span&gt; &nbsp;hfile.block.cache.size &nbsp;0.2 &lt;/property&gt; &lt;/span&gt; &nbsp;hbase.bucketcache.size &nbsp;&lt;/span&gt; 104448 &lt;/value&gt; &lt;/property&gt;&lt;/font&gt;&lt;/pre&gt; 20% of the heap is allocated to the L1 cache (LRU cache). When L2 is enabled, L1 holds no data, just index and bloom filter blocks. 102 GB off heap space is allocated to the L2 cache (BucketCache) Before performing the read tests, we have made sure that all data is loaded into BucketCache so there is no i/o. &nbsp;The read workloads of PE tool run with multiple threads. &nbsp;We considerthe average completion time for each of the threads to do the required reads. 1. Each thread does 100 row multi get operations for 1000000 times. We can see that there is a 55 &ndash; 82 % reduction in average run time. See the graph below for the test for 5 to 75 threads reading. Y axis shows average completion time, in seconds, for one thread. Here each thread is doing 100000000 row get and converting this to throughput numbers we can see 5 Threads 10 Threads 20 Threads 25 Threads 50 Threads 75 Threads Throughput Without Patch 5594092.638 7152564.19 7001330.25 6920798.38 6113142.03 5463246.92 Throughput With HBASE-11425 11353315.17 19782393.7 28477858.5 28216704.3 30229746.1 30647270.3 Throughput gain 2x 2.7x 4x 4x 4.9x 5.6x So without the patch case, at the 20 threads level, the system goes to peak load situation and throughput starts to fall off. But with HBASE-11425 this is not the case and even with 75 threads. It is mostly linear scaling with more loading. &nbsp;The major factor which helps us here is reduced GC activity. 2. Each thread is doing a range scan of 10000 rows with filtering of all the data on the server side. The filtering is done to see the server side gain alone and avoid any impact of network and/or client app side bottleneck. Each thread is doing the scan operation 10000 times. We can see that there is 55 &ndash; 74 % reduction in average run time of each thread. See below the graph for the test for 5 to 75 threads reading. Y axis shows average completion time, in seconds, for one thread. 3. &nbsp;Another range scan test is performed with part of data returned back to client. &nbsp;The test will return 10% of total rows back to the client and the remaining rows are filtered out at the server. The below graph is for a test with 10, 20, 25 and 50 threads. Again Y axis gives the average thread completion time, in seconds. The gain is &nbsp;28 &ndash; 39% latency. The YCSB test is done in same cluster with 90 GB of data. We had similar system configuration and HBase configuration as for the PE tests. The YCSB setup involves creating a table with a single column family with around 90 GB of data. There are 10 columns each with 100 bytes of data (each row having 1k of data). All the readings are taken after ensuring that the entire data set is in the BucketCache. The multi get test includes each thread doing 100 row gets and 5000000 such operations. Range scan does random range scans with 1000000 operations. Threads With HBASE-11425(Ops/sec) Withoutpatch(Ops/sec) 10 28045.53 23277.97 25 45767.99 25922.18 50 58904.03 24558.72 75 63280.86 24316.74 Threads With HBASE-11425(Ops/Sec) Withoutpatch(Ops/sec) 10 5332.451701 4139.416 25 8685.456204 5340.796 50 9180.235565 5149 75 9019.192842 4981.8 For multi get there is 20 &ndash; 160 % throughput gain whereas for range scan it is 20 - 80%. With HBASE-11425 we can see there is linear throughput increase with more threads whereas old code starts performing badly when more threads (See when 50 and 75 threads) GC graphs With HBASE-11425, we serve data directly from the off heap cache rather than copy each of the blocks on heap for each of the reads. &nbsp;So we should be doing much better with respect to GC on the &nbsp;RegionServer side. &nbsp;Below are the GC graph samples taken on one RegionServer during the PE test run. &nbsp;We can clearly notice that with the changes in HBASE-11425, we are doing much less (better) GC. MultiGets &ndash; without HBASE-11425 (25 threads) Multigets &ndash; with HBASE-11425(25 threads) ScanRange10000 &ndash; without HBASE-11425 (20 threads) ScanRange10000 &ndash; with HBASE-11425 (20 threads) Future Work One implication of the findings above is that we should run with off heap Cache on always. We were reluctant to do this in the past when reads from the off heap cache took longer. This is no longer the case. We will look into making this option on by default. Also, this posting has described our conversion of the read pipeline to make it run with offheap buffers. Next up, naturally, would be making the write pipeline offheap. Conclusion Some parts of this work made it into branch-1 but to run with a fully off heap read path, you will have to wait on the HBase 2.0 release which should be available early next year (2016). Enabling L2 (BucketCache) in off heap mode will automatically turn on the off heap mechanisms described above. We hope you enjoy these improvements made to the Apache HBase read path." />
<link rel="canonical" href="http://localhost:4000/hbase/entry/offheaping_the_read_path_in1" />
<meta property="og:url" content="http://localhost:4000/hbase/entry/offheaping_the_read_path_in1" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-12-18T00:07:24-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Offheaping the Read Path in Apache HBase: Part 2 of 2" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2015-12-18T00:07:24-05:00","datePublished":"2015-12-18T00:07:24-05:00","description":"by HBase Committers Anoop Sam John,&nbsp;Ramkrishna S Vasudevan, and&nbsp;Michael Stack This is part two of a two part blog. Herein we&nbsp;compare before and after&nbsp;off heaping. See part one for preamble and&nbsp;detail on work done. Performance Results There were two parts to our performance measurement. &nbsp; Using HBase&rsquo;s built-in Performance Evaluation (PE) tool. &nbsp; Using YCSB to measure the throughput. The PE test was conducted on a single node machine. &nbsp;Table is created and loaded with 100 GB of data. &nbsp;Table has one CF and one column per row. Each cell value size is 1K. Configuration of the node : System configuration CPU : Intel(R) Xeon(R) CPU with 8 cores. RAM : 150 GB JDK : 1.8 HBase configuration HBASE_HEAPSIZE = 9 GB HBASE_OFFHEAPSIZE = 105 GB &lt;/span&gt; &nbsp;hbase.bucketcache.ioengine &nbsp;offheap &lt;/property&gt; &lt;/span&gt; &nbsp;hfile.block.cache.size &nbsp;0.2 &lt;/property&gt; &lt;/span&gt; &nbsp;hbase.bucketcache.size &nbsp;&lt;/span&gt; 104448 &lt;/value&gt; &lt;/property&gt;&lt;/font&gt;&lt;/pre&gt; 20% of the heap is allocated to the L1 cache (LRU cache). When L2 is enabled, L1 holds no data, just index and bloom filter blocks. 102 GB off heap space is allocated to the L2 cache (BucketCache) Before performing the read tests, we have made sure that all data is loaded into BucketCache so there is no i/o. &nbsp;The read workloads of PE tool run with multiple threads. &nbsp;We considerthe average completion time for each of the threads to do the required reads. 1. Each thread does 100 row multi get operations for 1000000 times. We can see that there is a 55 &ndash; 82 % reduction in average run time. See the graph below for the test for 5 to 75 threads reading. Y axis shows average completion time, in seconds, for one thread. Here each thread is doing 100000000 row get and converting this to throughput numbers we can see 5 Threads 10 Threads 20 Threads 25 Threads 50 Threads 75 Threads Throughput Without Patch 5594092.638 7152564.19 7001330.25 6920798.38 6113142.03 5463246.92 Throughput With HBASE-11425 11353315.17 19782393.7 28477858.5 28216704.3 30229746.1 30647270.3 Throughput gain 2x 2.7x 4x 4x 4.9x 5.6x So without the patch case, at the 20 threads level, the system goes to peak load situation and throughput starts to fall off. But with HBASE-11425 this is not the case and even with 75 threads. It is mostly linear scaling with more loading. &nbsp;The major factor which helps us here is reduced GC activity. 2. Each thread is doing a range scan of 10000 rows with filtering of all the data on the server side. The filtering is done to see the server side gain alone and avoid any impact of network and/or client app side bottleneck. Each thread is doing the scan operation 10000 times. We can see that there is 55 &ndash; 74 % reduction in average run time of each thread. See below the graph for the test for 5 to 75 threads reading. Y axis shows average completion time, in seconds, for one thread. 3. &nbsp;Another range scan test is performed with part of data returned back to client. &nbsp;The test will return 10% of total rows back to the client and the remaining rows are filtered out at the server. The below graph is for a test with 10, 20, 25 and 50 threads. Again Y axis gives the average thread completion time, in seconds. The gain is &nbsp;28 &ndash; 39% latency. The YCSB test is done in same cluster with 90 GB of data. We had similar system configuration and HBase configuration as for the PE tests. The YCSB setup involves creating a table with a single column family with around 90 GB of data. There are 10 columns each with 100 bytes of data (each row having 1k of data). All the readings are taken after ensuring that the entire data set is in the BucketCache. The multi get test includes each thread doing 100 row gets and 5000000 such operations. Range scan does random range scans with 1000000 operations. Threads With HBASE-11425(Ops/sec) Withoutpatch(Ops/sec) 10 28045.53 23277.97 25 45767.99 25922.18 50 58904.03 24558.72 75 63280.86 24316.74 Threads With HBASE-11425(Ops/Sec) Withoutpatch(Ops/sec) 10 5332.451701 4139.416 25 8685.456204 5340.796 50 9180.235565 5149 75 9019.192842 4981.8 For multi get there is 20 &ndash; 160 % throughput gain whereas for range scan it is 20 - 80%. With HBASE-11425 we can see there is linear throughput increase with more threads whereas old code starts performing badly when more threads (See when 50 and 75 threads) GC graphs With HBASE-11425, we serve data directly from the off heap cache rather than copy each of the blocks on heap for each of the reads. &nbsp;So we should be doing much better with respect to GC on the &nbsp;RegionServer side. &nbsp;Below are the GC graph samples taken on one RegionServer during the PE test run. &nbsp;We can clearly notice that with the changes in HBASE-11425, we are doing much less (better) GC. MultiGets &ndash; without HBASE-11425 (25 threads) Multigets &ndash; with HBASE-11425(25 threads) ScanRange10000 &ndash; without HBASE-11425 (20 threads) ScanRange10000 &ndash; with HBASE-11425 (20 threads) Future Work One implication of the findings above is that we should run with off heap Cache on always. We were reluctant to do this in the past when reads from the off heap cache took longer. This is no longer the case. We will look into making this option on by default. Also, this posting has described our conversion of the read pipeline to make it run with offheap buffers. Next up, naturally, would be making the write pipeline offheap. Conclusion Some parts of this work made it into branch-1 but to run with a fully off heap read path, you will have to wait on the HBase 2.0 release which should be available early next year (2016). Enabling L2 (BucketCache) in off heap mode will automatically turn on the off heap mechanisms described above. We hope you enjoy these improvements made to the Apache HBase read path.","headline":"Offheaping the Read Path in Apache HBase: Part 2 of 2","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/hbase/entry/offheaping_the_read_path_in1"},"url":"http://localhost:4000/hbase/entry/offheaping_the_read_path_in1"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Offheaping the Read Path in Apache HBase: Part 2 of 2</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2015-12-18T00:07:24-05:00" itemprop="datePublished">Dec 18, 2015
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Michael Stack", "login"=>"stack", "email"=>"stack@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><em style="line-height: 15.3045px; widows: 1;">by HBase Committers Anoop Sam John,&nbsp;<span style="line-height: normal;">Ramkrishna S Vasudevan, and&nbsp;</span><span style="line-height: normal;">Michael Stack</span></em></p>
<p><i>This is part two of a two part blog. Herein we&nbsp;compare before and after&nbsp;off heaping. See <a href="https://blogs.apache.org/hbase/entry/offheaping_the_read_path_in">part one</a> for preamble and&nbsp;detail on work done.</i></p>
<h2 dir="ltr" style="margin-top: 2pt; margin-bottom: 0pt; widows: 1; line-height: 1.295;"><span style="font-weight: 400; vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">Performance Results</span></h2>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">There were two parts to our performance measurement. &nbsp;</span></p>
<ol style="line-height: normal; widows: 1; margin-top: 0pt; margin-bottom: 0pt;">
<li dir="ltr" style="list-style-type: decimal; vertical-align: baseline; background-color: transparent;">
<p dir="ltr" style="line-height: 1.295; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">Using HBase&rsquo;s built-in Performance Evaluation (PE) tool. &nbsp;</span></p>
</li>
<li dir="ltr" style="list-style-type: decimal; vertical-align: baseline; background-color: transparent;">
<p dir="ltr" style="line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">Using </span><a href="https://github.com/brianfrankcooper/YCSB"><span style="text-decoration: underline; vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">YCSB</span></a><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"> to measure the throughput. </span></p>
</li>
</ol>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">The PE test was conducted on a single node machine. &nbsp;Table is created and loaded with 100 GB of data. &nbsp;Table has one CF and one column per row. Each cell value size is 1K. Configuration of the node :</span></p>
<h2 dir="ltr" style="margin-top: 2pt; margin-bottom: 0pt; widows: 1; line-height: 1.295;"><span style="font-weight: 400; vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">System configuration</span></h2>
<pre style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><font face="courier new, courier, monospace" size="1"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">CPU : Intel(R) Xeon(R) CPU with 8 cores.
</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">RAM : 150 GB
</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">JDK : 1.8</span></font></pre>
<h2 dir="ltr" style="margin-top: 2pt; margin-bottom: 0pt; widows: 1; line-height: 1.295;"><span style="font-weight: 400; vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">HBase configuration</span></h2>
<pre style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><font face="courier new, courier, monospace" size="1"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">HBASE_HEAPSIZE = 9 GB
</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">HBASE_OFFHEAPSIZE = 105 GB
</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"><property>
</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"> &nbsp;<name>hbase.bucketcache.ioengine</name>
</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"> &nbsp;<value>offheap</value>
</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"></property>
</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"><property>
</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"> &nbsp;<name>hfile.block.cache.size</name>
</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"> &nbsp;<value>0.2</value>
</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"></property>
</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"><property>
</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"> &nbsp;<name>hbase.bucketcache.size</name>
</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"> &nbsp;<value></span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"> </span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">104448 </value>
</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"></property></span></font></pre>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">20% of the heap is allocated to the L1 cache (LRU cache). When L2 is enabled, L1 holds no data, just index and bloom filter blocks. 102 GB off heap space is allocated to the L2 cache (BucketCache)</span></p>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">Before performing the read tests, we have made sure that all data is loaded into BucketCache so there is no i/o. &nbsp;The read workloads of PE tool run with multiple threads. &nbsp;We considerthe average completion time for each of the threads to do the required reads.</span></p>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">1. Each thread does 100 row multi get operations for 1000000 times. We can see that there is a 55 &ndash; 82 % reduction in average run time. See the graph below for the test for 5 to 75 threads reading. Y axis shows average completion time, in seconds, for one thread.</span></p>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"><img src="https://lh4.googleusercontent.com/fFeJlNKx--Z62BZebqnLOo9gxNpkONEsj-tlzOZUNbG2FKM7ApNujdxtNv55YUd-jCp5fMQyO14iw17Mj6R-kWykexi4L91nKQDNTJ-HyZL8OPlUCyQDR7BUVwcylh3p-ZYbzw-A" width="624" height="333" style="transform: rotate(0rad);" /></span></p>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">Here each thread is doing 100000000 row get and converting this to throughput numbers we can see</span></p>
<p><br style="line-height: normal; widows: 1;" /> </p>
<div dir="ltr" style="line-height: normal; widows: 1; margin-left: -1.1pt;">
<table style="border: none; border-collapse: collapse;">
<colgroup>
<col width="168" />
<col width="92" />
<col width="85" />
<col width="85" />
<col width="85" />
<col width="85" />
<col width="85" /></colgroup>
<tbody>
<tr style="height: 20px;">
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"> </span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">5 Threads</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">10 Threads</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">20 Threads</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">25 Threads</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">50 Threads</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">75 Threads</span></p>
</td>
</tr>
<tr style="height: 20px;">
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">Throughput Without Patch</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">5594092.638</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">7152564.19</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">7001330.25</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">6920798.38</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">6113142.03</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">5463246.92</span></p>
</td>
</tr>
<tr style="height: 20px;">
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">Throughput With HBASE-11425</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">11353315.17</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">19782393.7</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">28477858.5</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">28216704.3</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">30229746.1</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">30647270.3</span></p>
</td>
</tr>
<tr style="height: 20px;">
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">Throughput gain</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">2x</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">2.7x</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">4x</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">4x</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">4.9x</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 0px 8px;">
<p dir="ltr" style="line-height: 1.2; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">5.6x</span></p>
</td>
</tr>
</tbody>
</table></div>
<p><br style="line-height: normal; widows: 1;" /> </p>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">So without the patch case, at the 20 threads level, the system goes to peak load situation and throughput starts to fall off. But with HBASE-11425 this is not the case and even with 75 threads. It is mostly linear scaling with more loading. &nbsp;The major factor which helps us here is reduced GC activity.</span></p>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">2. Each thread is doing a range scan of 10000 rows with filtering of all the data on the server side. The filtering is done to see the server side gain alone and avoid any impact of network and/or client app side bottleneck. Each thread is doing the scan operation 10000 times. We can see that there is 55 &ndash; 74 % reduction in average run time of each thread. See below the graph for the test for 5 to 75 threads reading. Y axis shows average completion time, in seconds, for one thread.</span></p>
<p><br style="line-height: normal; widows: 1;" /><br style="line-height: normal; widows: 1;" /> </p>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"><img src="https://lh6.googleusercontent.com/4vqxdMht1iVJyySN93yU301FzD2JeadhRbs2ZhtdNb-SCUZTlbhhiVErWqDljhf_G5-pMk3yNGNf0ERdC2eVGTEg9uF4RLOUvdaBnw7iKvtt4AxonN2vaAgf7O_3TO2pmJ5AxISa" width="608" height="296" style="transform: rotate(0rad);" /></span></p>
<p><br style="line-height: normal; widows: 1;" /> </p>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">3. &nbsp;Another range scan test is performed with part of data returned back to client. &nbsp;The test will return 10% of total rows back to the client and the remaining rows are filtered out at the server. The below graph is for a test with 10, 20, 25 and 50 threads. Again Y axis gives the average thread completion time, in seconds. The gain is &nbsp;28 &ndash; 39% latency.</span></p>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"><img src="https://lh3.googleusercontent.com/Xp8ygro3hY1DgmBAOjiUd23ABnCO22Pl0__a0vrEIUpvrHzEuLudkZ7lEd92nBtnVbPA4wrhwVvm2Pg-kkQmoYJT5aSwMRjEOzca-QXS2aiJwCZJIKHrdhQnF07UQoZvwP_EQbi5" width="480" height="288" style="transform: rotate(0rad);" /></span></p>
<p><br style="line-height: normal; widows: 1;" /> </p>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">The YCSB test is done in same cluster with 90 GB of data. We had similar system configuration and HBase configuration as for the PE tests.</span></p>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">The YCSB setup involves creating a table with a single column family with around 90 GB of data. There are 10 columns each with 100 bytes of data (each row having 1k of data). All the readings are taken after ensuring that the entire data set is in the BucketCache. The multi get test includes each thread doing 100 row gets and 5000000 such operations. Range scan does random range scans with </span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">1000000 operations</span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">.</span></p>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"><img src="https://lh3.googleusercontent.com/0JPUmi_pFKSGAIjUvtXGoIchv7wSI0nPghlq8al78nnOiwGtbpmlTVfuSRzTVHe2k5VpW6Pg1_eiCUFEsRj5ukJMH1XvZUmXgSPCpE-9nxFZO4_bA3UnOwYJXjxSgFbSaXtrBMuJ" width="483" height="290" style="transform: rotate(0rad);" /></span></p>
<p><br style="line-height: normal; widows: 1;" /> </p>
<div dir="ltr" style="line-height: normal; widows: 1; margin-left: 0pt;">
<table style="border: none; border-collapse: collapse;">
<colgroup>
<col width="149" />
<col width="177" />
<col width="176" /></colgroup>
<tbody>
<tr style="height: 0px;">
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">Threads</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">With HBASE-11425(Ops/sec)</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">Withoutpatch(Ops/sec)</span></p>
</td>
</tr>
<tr style="height: 0px;">
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">10</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">28045.53</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">23277.97</span></p>
</td>
</tr>
<tr style="height: 0px;">
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">25</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">45767.99</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">25922.18</span></p>
</td>
</tr>
<tr style="height: 0px;">
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">50</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">58904.03</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">24558.72</span></p>
</td>
</tr>
<tr style="height: 0px;">
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">75</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">63280.86</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">24316.74</span></p>
</td>
</tr>
</tbody>
</table></div>
<p><br style="line-height: normal; widows: 1;" /> </p>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"><img src="https://lh6.googleusercontent.com/EIfwWcviZIWcPo8PtBWW790LxGFF4of5viEu5oKqoVQ-mvo7DHcCi6eX2PqwhdCf1x8WbksMGRDv-34zy33nornZ2NG9VyF9Yz57EvZEQbYL-iPCmG9D1RWdl13c45oB9ZQp7Pia" width="449" height="290" style="transform: rotate(0rad);" /></span></p>
<p><br style="line-height: normal; widows: 1;" /> </p>
<div dir="ltr" style="line-height: normal; widows: 1; margin-left: 0pt;">
<table style="border: none; border-collapse: collapse;">
<colgroup>
<col width="107" />
<col width="152" />
<col width="182" /></colgroup>
<tbody>
<tr style="height: 0px;">
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">Threads</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">With HBASE-11425(Ops/Sec)</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">Withoutpatch(Ops/sec)</span></p>
</td>
</tr>
<tr style="height: 0px;">
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">10</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">5332.451701</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">4139.416</span></p>
</td>
</tr>
<tr style="height: 0px;">
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">25</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">8685.456204</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">5340.796</span></p>
</td>
</tr>
<tr style="height: 0px;">
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">50</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">9180.235565</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">5149</span></p>
</td>
</tr>
<tr style="height: 0px;">
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">75</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">9019.192842</span></p>
</td>
<td style="border: 1px solid #000000; vertical-align: bottom; padding: 7px;">
<p dir="ltr" style="line-height: 1.295; margin: 0pt 7pt; text-align: center;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">4981.8</span></p>
</td>
</tr>
</tbody>
</table></div>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">For multi get there is 20 &ndash; 160 % throughput gain whereas for range scan it is 20 - 80%.</span></p>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">With HBASE-11425 we can see there is linear throughput increase with more threads whereas old code starts performing badly when more threads (See when 50 and 75 threads)</span></p>
<h2 dir="ltr" style="margin-top: 2pt; margin-bottom: 0pt; widows: 1; line-height: 1.295;"><span style="font-weight: 400; vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">GC graphs</span></h2>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">With HBASE-11425, we serve data directly from the off heap cache rather than copy each of the blocks on heap for each of the reads. &nbsp;So we should be doing much better with respect to GC on the &nbsp;RegionServer side. &nbsp;Below are the GC graph samples taken on one RegionServer during the PE test run. &nbsp;We can clearly notice that with the changes in HBASE-11425, we are doing much less (better) GC.</span></p>
<h2 dir="ltr" style="margin-top: 2pt; margin-bottom: 0pt; widows: 1; line-height: 1.295;"><span style="font-weight: 400; vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">MultiGets &ndash; without HBASE-11425 (25 threads)</span></h2>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"><img src="https://lh6.googleusercontent.com/Kthbru6VNH9f2p_4jVe_uoQBxvVMVfrXDzemkG96xuyYSzmIOAoUwDlkT8d3TmDd7KuMn9oItHfsFl8ZgPz9cqdqUhPB_pkJTo_T4nVPfgkWUJQiM8n-S4L1G7pgKcrhsOiNicYrFjMvAF4c" width="624" height="337" alt="multiGets_69machine_withoutpatch" style="transform: rotate(0rad);" /></span></p>
<h2 dir="ltr" style="margin-top: 2pt; margin-bottom: 0pt; widows: 1; line-height: 1.295;"><span style="font-weight: 400; vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">Multigets &ndash; with HBASE-11425(25 threads)</span></h2>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"><img src="https://lh5.googleusercontent.com/EI1dHUMRqP0CrTA39dRUvSi64RAYY5jI1EsTN5PLuphBxz84YrDecaBJ1AJ4StngsOVCMIIBZJCDI82SzecVJ7WoOtnoWhfkNmC7bdhPZZIL6LLOXxgBmpIvlpJgUvvvmKjp_Kdw5IyP3IDq" width="623" height="336" alt="multiGets_69machine_withpatch" style="transform: rotate(0rad);" /></span></p>
<p><br style="line-height: normal; widows: 1;" /> </p>
<h2 dir="ltr" style="margin-top: 2pt; margin-bottom: 0pt; widows: 1; line-height: 1.295;"><span style="font-weight: 400; vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">ScanRange10000 &ndash; without HBASE-11425 (20 threads)</span></h2>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"><img src="https://lh4.googleusercontent.com/xjJ4UCHDBxQXNYdmh3s5Vkd390qBhALWTrmYOU7bDP1dzlexrZDRghE-r97wths4Dqpmoxm7BxW3dz3scBfacD28TcmsMm4HbUCyaBb4AGOca2GlV0CfcVkYNwuc89pYZbX-75RUlhv416AA" width="623" height="341" alt="scanRange_1k_50threads_withoutpatch" style="transform: rotate(0rad);" /></span><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"> </span></p>
<h2 dir="ltr" style="margin-top: 2pt; margin-bottom: 0pt; widows: 1; line-height: 1.295;"><span style="font-weight: 400; vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">ScanRange10000 &ndash; with HBASE-11425 (20 threads)</span></h2>
<p><br style="line-height: normal; widows: 1;" /> </p>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;"><img src="https://lh4.googleusercontent.com/nDoeLsapfjtyif2AhC3doN73QhhI0puzYt-XwEzTnDIPHAU4jy9xyfZcoLyfMD8WXYoQ80z9bGIcp8NChPkpFqKPXoEVhTR6mWbDFdIkaJkexsW2UylNhomhy3ymnJDI-DesVB3XTRozgjFF" width="623" height="348" alt="scanRange_1k_50threads_withpatch" style="transform: rotate(0rad);" /></span></p>
<p><br style="line-height: normal; widows: 1;" /> </p>
<h2 dir="ltr" style="margin-top: 2pt; margin-bottom: 0pt; widows: 1; line-height: 1.295;"><span style="font-weight: 400; vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">Future Work</span></h2>
<p dir="ltr" style="widows: 1; line-height: 1.295; margin-top: 0pt; margin-bottom: 8pt;"><span style="vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">One implication of the findings above is that we should run with off heap Cache on always. We were reluctant to do this in the past when reads from the off heap cache took longer. This is no longer the case. We will look into making this option on by default. Also, this posting has described our conversion of the read pipeline to make it run with offheap buffers. Next up, naturally, would be making the write pipeline offheap.</span></p>
<h2 dir="ltr" style="margin-top: 2pt; margin-bottom: 0pt; widows: 1; line-height: 1.295;"><span style="font-weight: 400; vertical-align: baseline; white-space: pre-wrap; background-color: transparent;">Conclusion</span></h2>
<p><span style="white-space: pre-wrap; widows: 1; background-color: transparent;">Some parts of this work made it into branch-1 but to run with a fully off heap read path, you will have to wait on the HBase 2.0 release which should be available early next year (2016). Enabling L2 (BucketCache) in off heap mode will automatically turn on the off heap mechanisms described above. We hope you enjoy these improvements made to the Apache HBase read path.</span> </p>

  </div><a class="u-url" href="/hbase/entry/offheaping_the_read_path_in1" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
