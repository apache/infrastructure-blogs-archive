<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Scan Improvements in HBase 1.1.0 | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Scan Improvements in HBase 1.1.0" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Jonathan Lawlor, Apache HBase Contributor Over the past few months there have a been a variety of nice changes made to scanners in HBase. This post focuses on two such changes, namely RPC chunking (HBASE-11544) and scanner heartbeat messages (HBASE-13090). Both of these changes address long standing issues in the client-server scan protocol. Specifically, RPC chunking deals with how a server handles the scanning of very large rows and scanner heartbeat messages allow scan operations to progress even when aggressive server-side filtering makes infrequent result returns. Background In order to discuss these issues, lets first gain a general understanding of how scans currently work in HBase. From an application&#39;s point of view, a ResultScanner is the client side source of all of the Results that an application asked for. When a client opens a scan, it&rsquo;s a ResultScanner that is returned and it is against this object that the client invokes next to fetch more data. ResultScanners handle all communication with the RegionServers involved in a scan and the ResultScanner decides which Results to make visible to the application layer. While there are various implementations of the ResultScanner interface, all implementations use basically the same protocol to communicate with the server. In order to retrieve Results from the server, the ResultScanner will issue ScanRequests via RPC&#39;s to the different RegionServers involved in a scan. A client configures a ScanRequest by passing an appropriately set Scan instance when opening the scan setting start/stop rows, caching limits, the maximum result size limit, and the filters to apply. On the server side, there are three main components involved in constructing the ScanResponse that will be sent back to the client in answer to a ScanRequest: RSRpcService The RSRpcService is a service that lives on RegionServers that can respond to incoming RPC requests, such as ScanRequests. During a scan, the RSRpcServices is the server side component that is responsible for constructing the ScanResponse that will be sent back to the client. The RSRpcServices continues to scan in order to accumulate Results until the region is exhausted, the table is exhausted, or a scan limit is reached (such as the caching limit or max result size limit). In order to retrieve these Results, the RSRpcServices must talk to a RegionScanner RegionScanner The RegionScanner is the server side component responsible for scanning the different rows in the region. In order to scan through the rows in the region, the RegionScanner will talk to a one or more different instances of StoreScanners (one per column family in the row). If the row passes all filtering criteria, the RegionScanner will return the Cells for that row to the RSRpcServices so that they can be used to form a Result to include in the ScanResponse. StoreScanner The StoreScanner is the server side component responsible for scanning through the Cells in each column family. When the client (i.e. ResultScanner) receives the ScanResponse back from the server, it can then decide whether or not scanning should continue. Since the client and the server communicate back and forth in chunks of Results, the client-side ResultScanner will cache all the Results it receives from the server. This allows the application to perform scans faster than the case where an RPC is required for each Result that the application sees. RPC Chunking (HBASE-11544) Why is it necessary? Currently, the server sends back whole rows to the client (each Result contains all of the cells for that row). The max result size limit is only applied at row boundaries. After each full row is scanned, the size limit will be checked. The problem with this approach is that it does not provide a granular enough restriction. Consider, for example, the scenario where each row being scanned is 100 MB. This means that 100 MB worth of data will be read between checks for the size limit. So, even in the case that the client has specified that the size limit is 1 MB, 100 MB worth of data will be read and then returned to the client. This approach for respecting the size limit is problematic. First of all, it means that it is possible for the server to run out of memory and crash in the case that it must scan a large row. At the application level, you simply want to perform a scan without having to worry about crashing the region server. This scenario is also problematic because it means that we do not have fine grained control over the network resources. The most efficient use of the network is to have the client and server talk back and forth in fixed sized chunks. Finally, this approach for respecting the size limit is a problem because it can lead to large, erratic allocations server side playing havoc with GC. Goal of the RPC Chunking solution The goal of the RPC Chunking solution was to: - Create a workflow that is more &lsquo;regular&rsquo;, less likely to cause Region Server distress - Use the network more efficiently - Avoid large garbage collections caused by allocating large blocks Furthermore, we wanted the RPC chunking mechanism to be invisible to the application. The communication between the client and the server should not be a concern of the application. All the application wants is a Result for their scan. How that Result is retrieved is completely up to the protocol used between the client and the server. Implementation Details The first step in implementing this proposed RPC chunking method was to move the max result size limit to a place where it could be respected at a more granular level than on row boundaries. Thus, the max result size limit was moved down to the cell level within StoreScanner. This meant that now the max result size limit could be checked at the cell boundaries, and if in excess, the scan can return early. The next step was to consider what would occur if the size limit was reached in the middle of a row. In this scenario, the Result sent back to the client will be marked as a &quot;partial&quot; Result. By marking the Result with this flag, the server communicates to the client that the Result is not a complete view of the row. Further Scan RPC&#39;s must be made in order to retrieve the outstanding parts of the row before it can be presented to the application. This allows the server to send back partial Results to the client and then the client can handle combining these partials into &quot;whole&quot; row Results. This relieves the server of the burden of having to read the entire row at a time. Finally, these changes were performed in a backwards compatible manner. The client must indicate in its ScanRequest that partial Results are supported. If that flag is not seen server side, the server will not send back partial results. Note that the configuration hbase.client.scanner.max.result.size can be used to change the default chunk size. By default this value is 2 MB in HBase 1.1+. An option (Scan#setAllowPartialResults) was also added so that an application can ask to see partial results as they are returned rather than wait on the aggregation of complete rows. A consistent view on the row is maintained even though a row is the result of multiple RPC partials because the running context server-side keeps account of the outstanding mvcc read point and will not include in results Cells written later. Note that this feature will be available starting in HBase 1.1. All 1.1+ clients will chunk their responses. Heartbeat messages for scans (HBASE-13090) What is a heartbeat message? A heartbeat message is a message used to keep the client-server connection alive. In the context of scans, a heartbeat message allows the server to communicate back to the client that scan progress has been made. On receipt, the client resets the connection timeout. Since the client and the server communicate back and forth in chunks of Results, it is possible that a single progress update will contain &lsquo;enough&rsquo; Results to satisfy the requesting application&rsquo;s purposes. So, beyond simply keeping the client-server connection alive and preventing scan timeouts, heartbeat messages also give the calling application an opportunity to decide whether or not more RPC&#39;s are even needed. Why are heartbeat messages necessary in Scans? Currently, scans execute server side until the table is exhausted, the region is exhausted, or a limit is reached. As such there is no way of influencing the actual execution time of a Scan RPC. The server continues to fetch Results with no regard for how long that process is taking. This is particularly problematic since each Scan RPC has a defined timeout. Thus, in the case that a particular scan is causing timeouts, the only solution is to increase the timeout so it spans the long-running requests (hbase.client.scanner.timeout.period). You may have encountered such problems if you have seen exceptions such as OutOfOrderScannerNextException. Goal of heartbeat messages The goal of the heartbeating message solution was to: - Incorporate a time limit concept into the client-server Scan protocol - The time limit must be enforceable at a granular level (between cells) - Time limit enforcement should be tunable so that checks do not occur too often Beyond simply meeting these goals, it is also important that, similar to RPC chunking, this mechanism is invisible to the application layer. The application simply wants to perform its scan and get a Result back on a call to ResultScanner.next(). It does not want to worry about whether or not the scan is going to take too long and if it needs to adjust timeouts or scan sizings. Implementation details The first step in implementing heartbeat messages was to incorporate a time limit concept into the Scan RPC workflow. This time limit was based on the configured value of the client scanner timeout. Once a time limit was defined, we had to decide where this time limit should be respected. It was decided that this time limit should be enforced within the StoreScanner. The reason for enforcing this limit inside store scanner was that it allowed the time limit to be enforced at the cell boundaries. It is important that the time limit be checked at a fine grained location because, in the case of restrictive filtering or time ranges, it is possible that large portions of time will be spent filtering out and skipping cells. If we wait to check the time limit at the row boundaries, it is possible when the row is wide that we may timeout before a single check occurs. A new configuration was introduced (hbase.cells.scanned.per.heartbeat.check) to control how often these time limit checks occur. The default value of this configuration is 10,000 meaning that we check the time limit every 10,000 cells. Finally, if this time limit is reached, the ScanResponse sent back to the client is marked as a heartbeat message. It is important that the ScanResponse be marked in this way because it communicates to the client the reason the message was sent back from the server. Since a time limit may be reached before any Results are retrieved, it is possible that the heartbeat message&#39;s list of Results will be empty. We do not want the client to interpret this as meaning that the region was exhausted. Note that similar to RPC chunking, this feature was implemented in a fully backwards compatible manner. In other words, heartbeat messages will only be sent back to the client in the case that the client has specified that it can recognize when a ScanResponse is a heartbeat message. Heartbeat messages will be available starting in HBase 1.1. All HBase 1.1+ clients will heartbeat. Cleaning up the Scan API (HBASE-13441) Following these recent improvements to the client-server Scan protocol, there is now an effort to try and cleanup the Scan API. There are some API&rsquo;s that are getting stale, and don&rsquo;t make much sense anymore especially in light of the above changes. There are also some API&rsquo;s that could use some love with regards to documentation. For example the caching and max result size API&rsquo;s deal with how data is transferred between the client and the server. Both of these API&rsquo;s now seem misplaced in the Scan API. These are details that should likely be controlled by the RegionServer rather than the application. It seems much more appropriate to give the RegionServer control over these parameters so that it can tune them based on the current state of the RPC pipeline and server loadings. HBASE-13441 Scan API Improvements is the open umbrella issue covering ideas for Scan API improvements. If you have some time, check it out. Let us know if you have some ideas for improvements that you would like to see. Other recent Scanner improvements It&rsquo;s important to note that these are not the only improvements that have been made to Scanners recently. Many other impressive improvements have come through deserving of their own blog post. For those that are interested, I have listed two: HBASE-13109: Make better SEEK vs SKIP decisions during scanning HBASE-13262: Fixed a data loss issue in Scans Upshot A spate of Scan improvements should make for a smoother Scan experience in HBase 1.1." />
<meta property="og:description" content="Jonathan Lawlor, Apache HBase Contributor Over the past few months there have a been a variety of nice changes made to scanners in HBase. This post focuses on two such changes, namely RPC chunking (HBASE-11544) and scanner heartbeat messages (HBASE-13090). Both of these changes address long standing issues in the client-server scan protocol. Specifically, RPC chunking deals with how a server handles the scanning of very large rows and scanner heartbeat messages allow scan operations to progress even when aggressive server-side filtering makes infrequent result returns. Background In order to discuss these issues, lets first gain a general understanding of how scans currently work in HBase. From an application&#39;s point of view, a ResultScanner is the client side source of all of the Results that an application asked for. When a client opens a scan, it&rsquo;s a ResultScanner that is returned and it is against this object that the client invokes next to fetch more data. ResultScanners handle all communication with the RegionServers involved in a scan and the ResultScanner decides which Results to make visible to the application layer. While there are various implementations of the ResultScanner interface, all implementations use basically the same protocol to communicate with the server. In order to retrieve Results from the server, the ResultScanner will issue ScanRequests via RPC&#39;s to the different RegionServers involved in a scan. A client configures a ScanRequest by passing an appropriately set Scan instance when opening the scan setting start/stop rows, caching limits, the maximum result size limit, and the filters to apply. On the server side, there are three main components involved in constructing the ScanResponse that will be sent back to the client in answer to a ScanRequest: RSRpcService The RSRpcService is a service that lives on RegionServers that can respond to incoming RPC requests, such as ScanRequests. During a scan, the RSRpcServices is the server side component that is responsible for constructing the ScanResponse that will be sent back to the client. The RSRpcServices continues to scan in order to accumulate Results until the region is exhausted, the table is exhausted, or a scan limit is reached (such as the caching limit or max result size limit). In order to retrieve these Results, the RSRpcServices must talk to a RegionScanner RegionScanner The RegionScanner is the server side component responsible for scanning the different rows in the region. In order to scan through the rows in the region, the RegionScanner will talk to a one or more different instances of StoreScanners (one per column family in the row). If the row passes all filtering criteria, the RegionScanner will return the Cells for that row to the RSRpcServices so that they can be used to form a Result to include in the ScanResponse. StoreScanner The StoreScanner is the server side component responsible for scanning through the Cells in each column family. When the client (i.e. ResultScanner) receives the ScanResponse back from the server, it can then decide whether or not scanning should continue. Since the client and the server communicate back and forth in chunks of Results, the client-side ResultScanner will cache all the Results it receives from the server. This allows the application to perform scans faster than the case where an RPC is required for each Result that the application sees. RPC Chunking (HBASE-11544) Why is it necessary? Currently, the server sends back whole rows to the client (each Result contains all of the cells for that row). The max result size limit is only applied at row boundaries. After each full row is scanned, the size limit will be checked. The problem with this approach is that it does not provide a granular enough restriction. Consider, for example, the scenario where each row being scanned is 100 MB. This means that 100 MB worth of data will be read between checks for the size limit. So, even in the case that the client has specified that the size limit is 1 MB, 100 MB worth of data will be read and then returned to the client. This approach for respecting the size limit is problematic. First of all, it means that it is possible for the server to run out of memory and crash in the case that it must scan a large row. At the application level, you simply want to perform a scan without having to worry about crashing the region server. This scenario is also problematic because it means that we do not have fine grained control over the network resources. The most efficient use of the network is to have the client and server talk back and forth in fixed sized chunks. Finally, this approach for respecting the size limit is a problem because it can lead to large, erratic allocations server side playing havoc with GC. Goal of the RPC Chunking solution The goal of the RPC Chunking solution was to: - Create a workflow that is more &lsquo;regular&rsquo;, less likely to cause Region Server distress - Use the network more efficiently - Avoid large garbage collections caused by allocating large blocks Furthermore, we wanted the RPC chunking mechanism to be invisible to the application. The communication between the client and the server should not be a concern of the application. All the application wants is a Result for their scan. How that Result is retrieved is completely up to the protocol used between the client and the server. Implementation Details The first step in implementing this proposed RPC chunking method was to move the max result size limit to a place where it could be respected at a more granular level than on row boundaries. Thus, the max result size limit was moved down to the cell level within StoreScanner. This meant that now the max result size limit could be checked at the cell boundaries, and if in excess, the scan can return early. The next step was to consider what would occur if the size limit was reached in the middle of a row. In this scenario, the Result sent back to the client will be marked as a &quot;partial&quot; Result. By marking the Result with this flag, the server communicates to the client that the Result is not a complete view of the row. Further Scan RPC&#39;s must be made in order to retrieve the outstanding parts of the row before it can be presented to the application. This allows the server to send back partial Results to the client and then the client can handle combining these partials into &quot;whole&quot; row Results. This relieves the server of the burden of having to read the entire row at a time. Finally, these changes were performed in a backwards compatible manner. The client must indicate in its ScanRequest that partial Results are supported. If that flag is not seen server side, the server will not send back partial results. Note that the configuration hbase.client.scanner.max.result.size can be used to change the default chunk size. By default this value is 2 MB in HBase 1.1+. An option (Scan#setAllowPartialResults) was also added so that an application can ask to see partial results as they are returned rather than wait on the aggregation of complete rows. A consistent view on the row is maintained even though a row is the result of multiple RPC partials because the running context server-side keeps account of the outstanding mvcc read point and will not include in results Cells written later. Note that this feature will be available starting in HBase 1.1. All 1.1+ clients will chunk their responses. Heartbeat messages for scans (HBASE-13090) What is a heartbeat message? A heartbeat message is a message used to keep the client-server connection alive. In the context of scans, a heartbeat message allows the server to communicate back to the client that scan progress has been made. On receipt, the client resets the connection timeout. Since the client and the server communicate back and forth in chunks of Results, it is possible that a single progress update will contain &lsquo;enough&rsquo; Results to satisfy the requesting application&rsquo;s purposes. So, beyond simply keeping the client-server connection alive and preventing scan timeouts, heartbeat messages also give the calling application an opportunity to decide whether or not more RPC&#39;s are even needed. Why are heartbeat messages necessary in Scans? Currently, scans execute server side until the table is exhausted, the region is exhausted, or a limit is reached. As such there is no way of influencing the actual execution time of a Scan RPC. The server continues to fetch Results with no regard for how long that process is taking. This is particularly problematic since each Scan RPC has a defined timeout. Thus, in the case that a particular scan is causing timeouts, the only solution is to increase the timeout so it spans the long-running requests (hbase.client.scanner.timeout.period). You may have encountered such problems if you have seen exceptions such as OutOfOrderScannerNextException. Goal of heartbeat messages The goal of the heartbeating message solution was to: - Incorporate a time limit concept into the client-server Scan protocol - The time limit must be enforceable at a granular level (between cells) - Time limit enforcement should be tunable so that checks do not occur too often Beyond simply meeting these goals, it is also important that, similar to RPC chunking, this mechanism is invisible to the application layer. The application simply wants to perform its scan and get a Result back on a call to ResultScanner.next(). It does not want to worry about whether or not the scan is going to take too long and if it needs to adjust timeouts or scan sizings. Implementation details The first step in implementing heartbeat messages was to incorporate a time limit concept into the Scan RPC workflow. This time limit was based on the configured value of the client scanner timeout. Once a time limit was defined, we had to decide where this time limit should be respected. It was decided that this time limit should be enforced within the StoreScanner. The reason for enforcing this limit inside store scanner was that it allowed the time limit to be enforced at the cell boundaries. It is important that the time limit be checked at a fine grained location because, in the case of restrictive filtering or time ranges, it is possible that large portions of time will be spent filtering out and skipping cells. If we wait to check the time limit at the row boundaries, it is possible when the row is wide that we may timeout before a single check occurs. A new configuration was introduced (hbase.cells.scanned.per.heartbeat.check) to control how often these time limit checks occur. The default value of this configuration is 10,000 meaning that we check the time limit every 10,000 cells. Finally, if this time limit is reached, the ScanResponse sent back to the client is marked as a heartbeat message. It is important that the ScanResponse be marked in this way because it communicates to the client the reason the message was sent back from the server. Since a time limit may be reached before any Results are retrieved, it is possible that the heartbeat message&#39;s list of Results will be empty. We do not want the client to interpret this as meaning that the region was exhausted. Note that similar to RPC chunking, this feature was implemented in a fully backwards compatible manner. In other words, heartbeat messages will only be sent back to the client in the case that the client has specified that it can recognize when a ScanResponse is a heartbeat message. Heartbeat messages will be available starting in HBase 1.1. All HBase 1.1+ clients will heartbeat. Cleaning up the Scan API (HBASE-13441) Following these recent improvements to the client-server Scan protocol, there is now an effort to try and cleanup the Scan API. There are some API&rsquo;s that are getting stale, and don&rsquo;t make much sense anymore especially in light of the above changes. There are also some API&rsquo;s that could use some love with regards to documentation. For example the caching and max result size API&rsquo;s deal with how data is transferred between the client and the server. Both of these API&rsquo;s now seem misplaced in the Scan API. These are details that should likely be controlled by the RegionServer rather than the application. It seems much more appropriate to give the RegionServer control over these parameters so that it can tune them based on the current state of the RPC pipeline and server loadings. HBASE-13441 Scan API Improvements is the open umbrella issue covering ideas for Scan API improvements. If you have some time, check it out. Let us know if you have some ideas for improvements that you would like to see. Other recent Scanner improvements It&rsquo;s important to note that these are not the only improvements that have been made to Scanners recently. Many other impressive improvements have come through deserving of their own blog post. For those that are interested, I have listed two: HBASE-13109: Make better SEEK vs SKIP decisions during scanning HBASE-13262: Fixed a data loss issue in Scans Upshot A spate of Scan improvements should make for a smoother Scan experience in HBase 1.1." />
<link rel="canonical" href="http://localhost:4000/hbase/entry/scan_improvements_in_hbase_1" />
<meta property="og:url" content="http://localhost:4000/hbase/entry/scan_improvements_in_hbase_1" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-05-01T21:45:30-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Scan Improvements in HBase 1.1.0" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2015-05-01T21:45:30-04:00","datePublished":"2015-05-01T21:45:30-04:00","description":"Jonathan Lawlor, Apache HBase Contributor Over the past few months there have a been a variety of nice changes made to scanners in HBase. This post focuses on two such changes, namely RPC chunking (HBASE-11544) and scanner heartbeat messages (HBASE-13090). Both of these changes address long standing issues in the client-server scan protocol. Specifically, RPC chunking deals with how a server handles the scanning of very large rows and scanner heartbeat messages allow scan operations to progress even when aggressive server-side filtering makes infrequent result returns. Background In order to discuss these issues, lets first gain a general understanding of how scans currently work in HBase. From an application&#39;s point of view, a ResultScanner is the client side source of all of the Results that an application asked for. When a client opens a scan, it&rsquo;s a ResultScanner that is returned and it is against this object that the client invokes next to fetch more data. ResultScanners handle all communication with the RegionServers involved in a scan and the ResultScanner decides which Results to make visible to the application layer. While there are various implementations of the ResultScanner interface, all implementations use basically the same protocol to communicate with the server. In order to retrieve Results from the server, the ResultScanner will issue ScanRequests via RPC&#39;s to the different RegionServers involved in a scan. A client configures a ScanRequest by passing an appropriately set Scan instance when opening the scan setting start/stop rows, caching limits, the maximum result size limit, and the filters to apply. On the server side, there are three main components involved in constructing the ScanResponse that will be sent back to the client in answer to a ScanRequest: RSRpcService The RSRpcService is a service that lives on RegionServers that can respond to incoming RPC requests, such as ScanRequests. During a scan, the RSRpcServices is the server side component that is responsible for constructing the ScanResponse that will be sent back to the client. The RSRpcServices continues to scan in order to accumulate Results until the region is exhausted, the table is exhausted, or a scan limit is reached (such as the caching limit or max result size limit). In order to retrieve these Results, the RSRpcServices must talk to a RegionScanner RegionScanner The RegionScanner is the server side component responsible for scanning the different rows in the region. In order to scan through the rows in the region, the RegionScanner will talk to a one or more different instances of StoreScanners (one per column family in the row). If the row passes all filtering criteria, the RegionScanner will return the Cells for that row to the RSRpcServices so that they can be used to form a Result to include in the ScanResponse. StoreScanner The StoreScanner is the server side component responsible for scanning through the Cells in each column family. When the client (i.e. ResultScanner) receives the ScanResponse back from the server, it can then decide whether or not scanning should continue. Since the client and the server communicate back and forth in chunks of Results, the client-side ResultScanner will cache all the Results it receives from the server. This allows the application to perform scans faster than the case where an RPC is required for each Result that the application sees. RPC Chunking (HBASE-11544) Why is it necessary? Currently, the server sends back whole rows to the client (each Result contains all of the cells for that row). The max result size limit is only applied at row boundaries. After each full row is scanned, the size limit will be checked. The problem with this approach is that it does not provide a granular enough restriction. Consider, for example, the scenario where each row being scanned is 100 MB. This means that 100 MB worth of data will be read between checks for the size limit. So, even in the case that the client has specified that the size limit is 1 MB, 100 MB worth of data will be read and then returned to the client. This approach for respecting the size limit is problematic. First of all, it means that it is possible for the server to run out of memory and crash in the case that it must scan a large row. At the application level, you simply want to perform a scan without having to worry about crashing the region server. This scenario is also problematic because it means that we do not have fine grained control over the network resources. The most efficient use of the network is to have the client and server talk back and forth in fixed sized chunks. Finally, this approach for respecting the size limit is a problem because it can lead to large, erratic allocations server side playing havoc with GC. Goal of the RPC Chunking solution The goal of the RPC Chunking solution was to: - Create a workflow that is more &lsquo;regular&rsquo;, less likely to cause Region Server distress - Use the network more efficiently - Avoid large garbage collections caused by allocating large blocks Furthermore, we wanted the RPC chunking mechanism to be invisible to the application. The communication between the client and the server should not be a concern of the application. All the application wants is a Result for their scan. How that Result is retrieved is completely up to the protocol used between the client and the server. Implementation Details The first step in implementing this proposed RPC chunking method was to move the max result size limit to a place where it could be respected at a more granular level than on row boundaries. Thus, the max result size limit was moved down to the cell level within StoreScanner. This meant that now the max result size limit could be checked at the cell boundaries, and if in excess, the scan can return early. The next step was to consider what would occur if the size limit was reached in the middle of a row. In this scenario, the Result sent back to the client will be marked as a &quot;partial&quot; Result. By marking the Result with this flag, the server communicates to the client that the Result is not a complete view of the row. Further Scan RPC&#39;s must be made in order to retrieve the outstanding parts of the row before it can be presented to the application. This allows the server to send back partial Results to the client and then the client can handle combining these partials into &quot;whole&quot; row Results. This relieves the server of the burden of having to read the entire row at a time. Finally, these changes were performed in a backwards compatible manner. The client must indicate in its ScanRequest that partial Results are supported. If that flag is not seen server side, the server will not send back partial results. Note that the configuration hbase.client.scanner.max.result.size can be used to change the default chunk size. By default this value is 2 MB in HBase 1.1+. An option (Scan#setAllowPartialResults) was also added so that an application can ask to see partial results as they are returned rather than wait on the aggregation of complete rows. A consistent view on the row is maintained even though a row is the result of multiple RPC partials because the running context server-side keeps account of the outstanding mvcc read point and will not include in results Cells written later. Note that this feature will be available starting in HBase 1.1. All 1.1+ clients will chunk their responses. Heartbeat messages for scans (HBASE-13090) What is a heartbeat message? A heartbeat message is a message used to keep the client-server connection alive. In the context of scans, a heartbeat message allows the server to communicate back to the client that scan progress has been made. On receipt, the client resets the connection timeout. Since the client and the server communicate back and forth in chunks of Results, it is possible that a single progress update will contain &lsquo;enough&rsquo; Results to satisfy the requesting application&rsquo;s purposes. So, beyond simply keeping the client-server connection alive and preventing scan timeouts, heartbeat messages also give the calling application an opportunity to decide whether or not more RPC&#39;s are even needed. Why are heartbeat messages necessary in Scans? Currently, scans execute server side until the table is exhausted, the region is exhausted, or a limit is reached. As such there is no way of influencing the actual execution time of a Scan RPC. The server continues to fetch Results with no regard for how long that process is taking. This is particularly problematic since each Scan RPC has a defined timeout. Thus, in the case that a particular scan is causing timeouts, the only solution is to increase the timeout so it spans the long-running requests (hbase.client.scanner.timeout.period). You may have encountered such problems if you have seen exceptions such as OutOfOrderScannerNextException. Goal of heartbeat messages The goal of the heartbeating message solution was to: - Incorporate a time limit concept into the client-server Scan protocol - The time limit must be enforceable at a granular level (between cells) - Time limit enforcement should be tunable so that checks do not occur too often Beyond simply meeting these goals, it is also important that, similar to RPC chunking, this mechanism is invisible to the application layer. The application simply wants to perform its scan and get a Result back on a call to ResultScanner.next(). It does not want to worry about whether or not the scan is going to take too long and if it needs to adjust timeouts or scan sizings. Implementation details The first step in implementing heartbeat messages was to incorporate a time limit concept into the Scan RPC workflow. This time limit was based on the configured value of the client scanner timeout. Once a time limit was defined, we had to decide where this time limit should be respected. It was decided that this time limit should be enforced within the StoreScanner. The reason for enforcing this limit inside store scanner was that it allowed the time limit to be enforced at the cell boundaries. It is important that the time limit be checked at a fine grained location because, in the case of restrictive filtering or time ranges, it is possible that large portions of time will be spent filtering out and skipping cells. If we wait to check the time limit at the row boundaries, it is possible when the row is wide that we may timeout before a single check occurs. A new configuration was introduced (hbase.cells.scanned.per.heartbeat.check) to control how often these time limit checks occur. The default value of this configuration is 10,000 meaning that we check the time limit every 10,000 cells. Finally, if this time limit is reached, the ScanResponse sent back to the client is marked as a heartbeat message. It is important that the ScanResponse be marked in this way because it communicates to the client the reason the message was sent back from the server. Since a time limit may be reached before any Results are retrieved, it is possible that the heartbeat message&#39;s list of Results will be empty. We do not want the client to interpret this as meaning that the region was exhausted. Note that similar to RPC chunking, this feature was implemented in a fully backwards compatible manner. In other words, heartbeat messages will only be sent back to the client in the case that the client has specified that it can recognize when a ScanResponse is a heartbeat message. Heartbeat messages will be available starting in HBase 1.1. All HBase 1.1+ clients will heartbeat. Cleaning up the Scan API (HBASE-13441) Following these recent improvements to the client-server Scan protocol, there is now an effort to try and cleanup the Scan API. There are some API&rsquo;s that are getting stale, and don&rsquo;t make much sense anymore especially in light of the above changes. There are also some API&rsquo;s that could use some love with regards to documentation. For example the caching and max result size API&rsquo;s deal with how data is transferred between the client and the server. Both of these API&rsquo;s now seem misplaced in the Scan API. These are details that should likely be controlled by the RegionServer rather than the application. It seems much more appropriate to give the RegionServer control over these parameters so that it can tune them based on the current state of the RPC pipeline and server loadings. HBASE-13441 Scan API Improvements is the open umbrella issue covering ideas for Scan API improvements. If you have some time, check it out. Let us know if you have some ideas for improvements that you would like to see. Other recent Scanner improvements It&rsquo;s important to note that these are not the only improvements that have been made to Scanners recently. Many other impressive improvements have come through deserving of their own blog post. For those that are interested, I have listed two: HBASE-13109: Make better SEEK vs SKIP decisions during scanning HBASE-13262: Fixed a data loss issue in Scans Upshot A spate of Scan improvements should make for a smoother Scan experience in HBase 1.1.","headline":"Scan Improvements in HBase 1.1.0","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/hbase/entry/scan_improvements_in_hbase_1"},"url":"http://localhost:4000/hbase/entry/scan_improvements_in_hbase_1"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Scan Improvements in HBase 1.1.0</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2015-05-01T21:45:30-04:00" itemprop="datePublished">May 1, 2015
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Michael Stack", "login"=>"stack", "email"=>"stack@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;" id="docs-internal-guid-0ce1327c-1160-2d12-9710-ffca85fc1712"><span style="font-family: Arial; font-size: 15px; line-height: 1.38; background-color: transparent;"><i>Jonathan Lawlor, Apache HBase Contributor</i></span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">Over the past few months there have a been a variety of nice changes made to scanners in HBase. This post focuses on two such changes, namely RPC chunking (HBASE-11544) and scanner heartbeat messages (HBASE-13090). Both of these changes address long standing issues in the client-server scan protocol. Specifically, RPC chunking deals with how a server handles the scanning of very large rows and scanner heartbeat messages allow scan operations to progress even when aggressive server-side filtering makes infrequent result returns.</span></p>
<p> </p>
<h2 dir="ltr" style="line-height: 1.38; margin-top: 10pt; margin-bottom: 0pt;"><span style="font-size: 17px; font-family: 'Trebuchet MS'; vertical-align: baseline; background-color: transparent;">Background</span></h2>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">In order to discuss these issues, lets first gain a general understanding of how scans currently work in HBase. </span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">From an application's point of view, a </span><a href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/ResultScanner.html"><span style="font-size: 15px; font-family: Arial; color: #1155cc; text-decoration: underline; vertical-align: baseline; background-color: transparent;">ResultScanner</span></a><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;"> is the client side source of all of the </span><a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Result.html"><span style="font-size: 15px; font-family: Arial; color: #1155cc; text-decoration: underline; vertical-align: baseline; background-color: transparent;">Result</span></a><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">s that an application asked for. When a client opens a scan, it&rsquo;s a ResultScanner that is returned and it is against this object that the client invokes next to fetch more data. ResultScanners handle all communication with the RegionServers involved in a scan and the ResultScanner decides which Results to make visible to the application layer. While there are various implementations of the ResultScanner interface, all implementations use basically the same protocol to communicate with the server.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">In order to retrieve Results from the server, the ResultScanner will issue </span><a href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/protobuf/generated/ClientProtos.ScanRequest.html"><span style="font-size: 15px; font-family: Arial; color: #1155cc; text-decoration: underline; vertical-align: baseline; background-color: transparent;">ScanRequest</span></a><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">s via RPC's to the different RegionServers involved in a scan. A client configures a ScanRequest by passing an appropriately set </span><a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html"><span style="font-size: 15px; font-family: Arial; color: #1155cc; text-decoration: underline; vertical-align: baseline; background-color: transparent;">Scan</span></a><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;"> instance when opening the scan setting start/stop rows, caching limits, the maximum result size limit, and the filters to apply.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">On the server side, there are three main components involved in constructing the </span><a href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/protobuf/generated/ClientProtos.ScanResponse.html"><span style="font-size: 15px; font-family: Arial; color: #1155cc; text-decoration: underline; vertical-align: baseline; background-color: transparent;">ScanResponse</span></a><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;"> that will be sent back to the client in answer to a ScanRequest:</span></p>
<p> </p>
<h3 dir="ltr" style="line-height: 1.38; margin-top: 8pt; margin-bottom: 0pt;"><span style="font-size: 16px; font-family: 'Trebuchet MS'; color: #666666; vertical-align: baseline; background-color: transparent;">RSRpcService</span></h3>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">The RSRpcService is a service that lives on RegionServers that can respond to incoming RPC requests, such as ScanRequests. During a scan, the RSRpcServices is the server side component that is responsible for constructing the ScanResponse that will be sent back to the client. The RSRpcServices continues to scan in order to accumulate Results until the region is exhausted, the table is exhausted, or a scan limit is reached (such as the caching limit or max result size limit). In order to retrieve these Results, the RSRpcServices must talk to a RegionScanner</span></p>
<p> </p>
<h3 dir="ltr" style="line-height: 1.38; margin-top: 8pt; margin-bottom: 0pt;"><span style="font-size: 16px; font-family: 'Trebuchet MS'; color: #666666; vertical-align: baseline; background-color: transparent;">RegionScanner</span></h3>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">The </span><a href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/RegionScanner.html"><span style="font-size: 15px; font-family: Arial; color: #1155cc; text-decoration: underline; vertical-align: baseline; background-color: transparent;">RegionScanner</span></a><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;"> is the server side component responsible for scanning the different rows in the region. In order to scan through the rows in the region, the RegionScanner will talk to a one or more different instances of </span><a href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/StoreScanner.html"><span style="font-size: 15px; font-family: Arial; color: #1155cc; text-decoration: underline; vertical-align: baseline; background-color: transparent;">StoreScanner</span></a><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">s (one per column family in the row). If the row passes all filtering criteria, the RegionScanner will return the Cells for that row to the RSRpcServices so that they can be used to form a Result to include in the ScanResponse.</span></p>
<p> </p>
<h3 dir="ltr" style="line-height: 1.38; margin-top: 8pt; margin-bottom: 0pt;"><span style="font-size: 16px; font-family: 'Trebuchet MS'; color: #666666; vertical-align: baseline; background-color: transparent;">StoreScanner</span></h3>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">The StoreScanner is the server side component responsible for scanning through the Cells in each column family.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">When the client (i.e. ResultScanner) receives the ScanResponse back from the server, it can then decide whether or not scanning should continue. Since the client and the server communicate back and forth in chunks of Results, the client-side ResultScanner will cache all the Results it receives from the server. This allows the application to perform scans faster than the case where an RPC is required for each Result that the application sees.</span></p>
<p> </p>
<h2 dir="ltr" style="line-height: 1.38; margin-top: 10pt; margin-bottom: 0pt;"><span style="font-size: 17px; font-family: 'Trebuchet MS'; vertical-align: baseline; background-color: transparent;">RPC Chunking (HBASE-11544)</span></h2>
<h3 dir="ltr" style="line-height: 1.38; margin-top: 8pt; margin-bottom: 0pt;"><span style="font-size: 16px; font-family: 'Trebuchet MS'; color: #666666; vertical-align: baseline; background-color: transparent;">Why is it necessary?</span></h3>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">Currently, the server sends back whole rows to the client (each Result contains all of the cells for that row). The max result size limit is only applied at row boundaries. After each full row is scanned, the size limit will be checked.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">The problem with this approach is that it does not provide a granular enough restriction. Consider, for example, the scenario where each row being scanned is 100 MB. This means that 100 MB worth of data will be read between checks for the size limit. So, even in the case that the client has specified that the size limit is 1 MB, 100 MB worth of data will be read and then returned to the client.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">This approach for respecting the size limit is problematic. First of all, it means that it is possible for the server to run out of memory and crash in the case that it must scan a large row. At the application level, you simply want to perform a scan without having to worry about crashing the region server.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">This scenario is also problematic because it means that we do not have fine grained control over the network resources. The most efficient use of the network is to have the client and server talk back and forth in fixed sized chunks. </span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">Finally, this approach for respecting the size limit is a problem because it can lead to large, erratic allocations server side playing havoc with GC.</span></p>
<p> </p>
<h3 dir="ltr" style="line-height: 1.38; margin-top: 8pt; margin-bottom: 0pt;"><span style="font-size: 16px; font-family: 'Trebuchet MS'; color: #666666; vertical-align: baseline; background-color: transparent;">Goal of the RPC Chunking solution</span></h3>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">The goal of the RPC Chunking solution was to:</span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;"> </span><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">- Create a workflow that is more &lsquo;regular&rsquo;, less likely to cause Region Server distress</span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;"> </span><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">- Use the network more efficiently</span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;"> </span><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">- Avoid large garbage collections caused by allocating large blocks</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">Furthermore, we wanted the RPC chunking mechanism to be invisible to the application. The communication between the client and the server should not be a concern of the application. All the application wants is a Result for their scan. How that Result is retrieved is completely up to the protocol used between the client and the server.</span></p>
<p> </p>
<h3 dir="ltr" style="line-height: 1.38; margin-top: 8pt; margin-bottom: 0pt;"><span style="font-size: 16px; font-family: 'Trebuchet MS'; color: #666666; vertical-align: baseline; background-color: transparent;">Implementation Details</span></h3>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">The first step in implementing this proposed RPC chunking method was to move the max result size limit to a place where it could be respected at a more granular level than on row boundaries. Thus, the max result size limit was moved down to the cell level within StoreScanner. This meant that now the max result size limit could be checked at the cell boundaries, and if in excess, the scan can return early. </span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">The next step was to consider what would occur if the size limit was reached in the middle of a row. In this scenario, the Result sent back to the client will be marked as a "partial" Result. By marking the Result with this flag, the server communicates to the client that the Result is not a complete view of the row. Further Scan RPC's must be made in order to retrieve the outstanding parts of the row before it can be presented to the application. This allows the server to send back partial Results to the client and then the client can handle combining these partials into "whole" row Results. This relieves the server of the burden of having to read the entire row at a time.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">Finally, these changes were performed in a backwards compatible manner. The client must indicate in its ScanRequest that partial Results are supported. If that flag is not seen server side, the server will not send back partial results. Note that the configuration hbase.client.scanner.max.result.size can be used to change the default chunk size. By default this value is 2 MB in HBase 1.1+.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">An option (</span><a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html#setAllowPartialResults(boolean)"><span style="font-size: 15px; font-family: Arial; color: #1155cc; text-decoration: underline; vertical-align: baseline; background-color: transparent;">Scan#setAllowPartialResults</span></a><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">) was also added so that an application can ask to see partial results as they are returned rather than wait on the aggregation of complete rows.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">A consistent view on the row is maintained even though a row is the result of multiple RPC partials because the running context server-side keeps account of the outstanding mvcc read point and will not include in results Cells written later.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">Note that this feature will be available starting in HBase 1.1. All 1.1+ clients will chunk their responses.</span></p>
<p> </p>
<h2 dir="ltr" style="line-height: 1.38; margin-top: 10pt; margin-bottom: 0pt;"><span style="font-size: 17px; font-family: 'Trebuchet MS'; vertical-align: baseline; background-color: transparent;">Heartbeat messages for scans (HBASE-13090)</span></h2>
<h3 dir="ltr" style="line-height: 1.38; margin-top: 8pt; margin-bottom: 0pt;"><span style="font-size: 16px; font-family: 'Trebuchet MS'; color: #666666; vertical-align: baseline; background-color: transparent;">What is a heartbeat message?</span></h3>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">A heartbeat message is a message used to keep the client-server connection alive. In the context of scans, a heartbeat message allows the server to communicate back to the client that scan progress has been made. On receipt, the client resets the connection timeout. Since the client and the server communicate back and forth in chunks of Results, it is possible that a single progress update will contain &lsquo;enough&rsquo; Results to satisfy the requesting application&rsquo;s purposes. So, beyond simply keeping the client-server connection alive and preventing scan timeouts, heartbeat messages also give the calling application an opportunity to decide whether or not more RPC's are even needed.</span></p>
<p> </p>
<h3 dir="ltr" style="line-height: 1.38; margin-top: 8pt; margin-bottom: 0pt;"><span style="font-size: 16px; font-family: 'Trebuchet MS'; color: #666666; vertical-align: baseline; background-color: transparent;">Why are heartbeat messages necessary in Scans?</span></h3>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">Currently, scans execute server side until the table is exhausted, the region is exhausted, or a limit is reached. As such there is no way of influencing the actual execution time of a Scan RPC. The server continues to fetch Results with no regard for how long that process is taking. This is particularly problematic since each Scan RPC has a defined timeout. Thus, in the case that a particular scan is causing timeouts, the only solution is to increase the timeout so it spans the long-running requests (</span><span style="font-size: 15px; font-family: Arial; font-style: italic; vertical-align: baseline; background-color: transparent;">hbase.client.scanner.timeout.period</span><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">). You may have encountered such problems if you have seen exceptions such as </span><span style="font-size: 15px; font-family: Arial; font-style: italic; vertical-align: baseline; background-color: transparent;">OutOfOrderScannerNextException</span><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">.</span></p>
<p> </p>
<h3 dir="ltr" style="line-height: 1.38; margin-top: 8pt; margin-bottom: 0pt;"><span style="font-size: 16px; font-family: 'Trebuchet MS'; color: #666666; vertical-align: baseline; background-color: transparent;">Goal of heartbeat messages</span></h3>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">The goal of the heartbeating message solution was to:</span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;"></span><span style="font-family: Arial; font-size: 15px; line-height: 1.38; text-indent: 36pt; background-color: transparent;">- Incorporate a time limit concept into the client-server Scan protocol</span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;"> </span><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">- The time limit must be enforceable at a granular level (between cells)</span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;"> </span><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">- Time limit enforcement should be tunable so that checks do not occur too often</span></p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">Beyond simply meeting these goals, it is also important that, similar to RPC chunking, this mechanism is invisible to the application layer. The application simply wants to perform its scan and get a Result back on a call to ResultScanner.next(). It does not want to worry about whether or not the scan is going to take too long and if it needs to adjust timeouts or scan sizings.</span></p>
<p> </p>
<h3 dir="ltr" style="margin-top: 8pt; margin-bottom: 0pt; line-height: 1.38;"><span style="font-size: 16px; font-family: 'Trebuchet MS'; color: #666666; vertical-align: baseline; background-color: transparent;">Implementation details</span></h3>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">The first step in implementing heartbeat messages was to incorporate a time limit concept into the Scan RPC workflow. This time limit was based on the configured value of the client scanner timeout.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">Once a time limit was defined, we had to decide where this time limit should be respected. It was decided that this time limit should be enforced within the StoreScanner. The reason for enforcing this limit inside store scanner was that it allowed the time limit to be enforced at the cell boundaries. It is important that the time limit be checked at a fine grained location because, in the case of restrictive filtering or time ranges, it is possible that large portions of time will be spent filtering out and skipping cells. If we wait to check the time limit at the row boundaries, it is possible when the row is wide that we may timeout before a single check occurs.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">A new configuration was introduced (</span><span style="font-size: 15px; font-family: Arial; font-style: italic; vertical-align: baseline; background-color: transparent;">hbase.cells.scanned.per.heartbeat.check</span><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">) to control how often these time limit checks occur. The default value of this configuration is 10,000 meaning that we check the time limit every 10,000 cells.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">Finally, if this time limit is reached, the ScanResponse sent back to the client is marked as a heartbeat message. It is important that the ScanResponse be marked in this way because it communicates to the client the reason the message was sent back from the server. Since a time limit may be reached before any Results are retrieved, it is possible that the heartbeat message's list of Results will be empty. We do not want the client to interpret this as meaning that the region was exhausted.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">Note that similar to RPC chunking, this feature was implemented in a fully backwards compatible manner. In other words, heartbeat messages will only be sent back to the client in the case that the client has specified that it can recognize when a ScanResponse is a heartbeat message. Heartbeat messages will be available starting in HBase 1.1. All HBase 1.1+ clients will heartbeat.</span></p>
<p> </p>
<h2 dir="ltr" style="line-height: 1.38; margin-top: 10pt; margin-bottom: 0pt;"><span style="font-size: 17px; font-family: 'Trebuchet MS'; vertical-align: baseline; background-color: transparent;">Cleaning up the Scan API (HBASE-13441)</span></h2>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">Following these recent improvements to the client-server Scan protocol, there is now an effort to try and cleanup the Scan API. There are some API&rsquo;s that are getting stale, and don&rsquo;t make much sense anymore especially in light of the above changes. There are also some API&rsquo;s that could use some love with regards to documentation. </span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">For example the caching and max result size API&rsquo;s deal with how data is transferred between the client and the server. Both of these API&rsquo;s now seem misplaced in the Scan API. These are details that should likely be controlled by the RegionServer rather than the application. It seems much more appropriate to give the RegionServer control over these parameters so that it can tune them based on the current state of the RPC pipeline and server loadings.</span></p>
<p> </p>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><a href="https://issues.apache.org/jira/browse/HBASE-13441"><span style="font-size: 15px; font-family: Arial; color: #1155cc; text-decoration: underline; vertical-align: baseline; background-color: transparent;">HBASE-13441 Scan API Improvements</span></a><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;"> is the open umbrella issue covering ideas for Scan API improvements. If you have some time, check it out. Let us know if you have some ideas for improvements that you would like to see.</span></p>
<p> </p>
<h2 dir="ltr" style="line-height: 1.38; margin-top: 10pt; margin-bottom: 0pt;"><span style="font-size: 17px; font-family: 'Trebuchet MS'; vertical-align: baseline; background-color: transparent;">Other recent Scanner improvements</span></h2>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">It&rsquo;s important to note that these are not the only improvements that have been made to Scanners recently. Many other impressive improvements have come through deserving of their own blog post. For those that are interested, I have listed two:</span></p>
<ul style="margin-top: 0pt; margin-bottom: 0pt;">
<li dir="ltr" style="list-style-type: disc; font-size: 15px; font-family: Arial; font-weight: bold; vertical-align: baseline; background-color: transparent;">
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="vertical-align: baseline; background-color: transparent;">HBASE-13109: </span><span style="font-weight: normal; vertical-align: baseline; background-color: transparent;">Make better SEEK vs SKIP decisions during scanning</span></p>
</li>
<li dir="ltr" style="list-style-type: disc; font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-weight: bold; vertical-align: baseline; background-color: transparent;">HBASE-13262</span><span style="vertical-align: baseline; background-color: transparent;">: Fixed a data loss issue in Scans </span></p>
</li>
</ul>
<p> </p>
<h2 dir="ltr" style="line-height: 1.38; margin-top: 10pt; margin-bottom: 0pt;"><span style="font-size: 17px; font-family: 'Trebuchet MS'; vertical-align: baseline; background-color: transparent;">Upshot</span></h2>
<p dir="ltr" style="line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 15px; font-family: Arial; vertical-align: baseline; background-color: transparent;">A spate of Scan improvements should make for a smoother Scan experience in HBase 1.1.</span></p>

  </div><a class="u-url" href="/hbase/entry/scan_improvements_in_hbase_1" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
