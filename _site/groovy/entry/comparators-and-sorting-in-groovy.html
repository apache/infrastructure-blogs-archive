<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Comparators and Sorting in Groovy | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Comparators and Sorting in Groovy" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This blog post is inspired by the Comparator examples in the excellent Collections Refuelled talk and blog by Stuart Marks. That blog from 2017 highlights improvements in the Java collections library in Java 8 and 9 including numerous Comparator improvements. It is now 5 years old but still highly recommended for anyone using the Java collections library. Rather than have a Student class as per the original blog example, we&#39;ll have a Celebrity class (and later record) which has the same first and last name fields and an additional age field. We&#39;ll compare initially by last name with nulls before non-nulls and then by first name and lastly by age. As with the original blog, we&#39;ll cater for nulls, e.g. a celebrity known by a single name. The Java comparator story recap Our Celebrity class if we wrote it in Java would look something like: public class Celebrity { // Java private String firstName; private String lastName; private int age; public Celebrity(String firstName, int age) { this(firstName, null, age); } public Celebrity(String firstName, String lastName, int age) { this.firstName = firstName; this.lastName = lastName; this.age = age; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } @Override public String toString() { return &quot;Celebrity{&quot; + &quot;firstName=&#39;&quot; + firstName + (lastName == null ? &quot;&quot; : &quot;&#39;, lastName=&#39;&quot; + lastName) + &quot;&#39;, age=&quot; + age + &#39;}&#39;; }} It would look much nicer as a Java record (JDK16+) but we&#39;ll keep with the spirit of the original blog example for now. This is fairly standard boilerplate and in fact was mostly generated by IntelliJ IDEA. The only slightly interesting aspect is that we tweaked the toString method to not display null last names. On JDK 8 with the old-style comparator coding, a main application which created and sorted some celebrities might look like this: import java.util.ArrayList; // Javaimport java.util.Collections;import java.util.List;public class Main { public static void main(String[] args) { List&lt;Celebrity&gt; celebrities = new ArrayList&lt;&gt;(); celebrities.add(new Celebrity(&quot;Cher&quot;, &quot;Wang&quot;, 63)); celebrities.add(new Celebrity(&quot;Cher&quot;, &quot;Lloyd&quot;, 28)); celebrities.add(new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 47)); celebrities.add(new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 37)); celebrities.add(new Celebrity(&quot;Cher&quot;, 76)); Collections.sort(celebrities, (c1, c2) -&gt; { String f1 = c1.getLastName(); String f2 = c2.getLastName(); int r1; if (f1 == null) { r1 = f2 == null ? 0 : -1; } else { r1 = f2 == null ? 1 : f1.compareTo(f2); } if (r1 != 0) { return r1; } int r2 = c1.getFirstName().compareTo(c2.getFirstName()); if (r2 != 0) { return r2; } return Integer.compare(c1.getAge(), c2.getAge()); }); System.out.println(&quot;Celebrities:&quot;); celebrities.forEach(System.out::println); }} When we run this example, the output looks like this: Celebrities: Celebrity{firstName=&#39;Cher&#39;, age=76} Celebrity{firstName=&#39;Alex&#39;, lastName=&#39;Lloyd&#39;, age=37} Celebrity{firstName=&#39;Alex&#39;, lastName=&#39;Lloyd&#39;, age=47} Celebrity{firstName=&#39;Cher&#39;, lastName=&#39;Lloyd&#39;, age=28} Celebrity{firstName=&#39;Cher&#39;, lastName=&#39;Wang&#39;, age=63} As pointed out in the original blog, this code is rather tedious and error-prone and can be improved greatly with comparator improvements in JDK8: import java.util.Arrays; // Javaimport java.util.List;import static java.util.Comparator.comparing;import static java.util.Comparator.naturalOrder;import static java.util.Comparator.nullsFirst;public class Main { public static void main(String[] args) { List&lt;Celebrity&gt; celebrities = Arrays.asList( new Celebrity(&quot;Cher&quot;, &quot;Wang&quot;, 63), new Celebrity(&quot;Cher&quot;, &quot;Lloyd&quot;, 28), new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 47), new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 37), new Celebrity(&quot;Cher&quot;, 76)); celebrities.sort(comparing(Celebrity::getLastName, nullsFirst(naturalOrder())). thenComparing(Celebrity::getFirstName).thenComparing(Celebrity::getAge)); System.out.println(&quot;Celebrities:&quot;); celebrities.forEach(System.out::println); }} The original blog also points out the convenience factory methods from JDK9 for list creation which you might be tempted to consider here. For our case, we will be sorting in place, so the immutable lists returned by those methods won&#39;t help us here but Arrays.asList isn&#39;t much longer than List.of and works well for this example. As well as being much shorter, the comparing and thenComparing methods and built-in comparators like nullsFirst and naturalOrdering allow for far simpler composability. The sort within array list is also more efficient than the sort that would have been used with the Collections.sort method on earlier JDKs. The output when running the example is the same as previously. The Groovy comparator story At about the same time that Java was evolving its comparator story Groovy added some complementary features to tackle many of the same problems. We&#39;ll look at some of those features and also how the JDK improvements we saw above features can be used instead if preferred. First off, let&#39;s create a Groovy Celebrity record: @Sortable(includes = &#39;last,first,age&#39;)@ToString(ignoreNulls = true, includeNames = true)record Celebrity(String first, String last = null, int age) {} And create our list of celebrities: var celebrities = [ new Celebrity(&quot;Cher&quot;, &quot;Wang&quot;, 63), new Celebrity(&quot;Cher&quot;, &quot;Lloyd&quot;, 28), new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 47), new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 37), new Celebrity(first: &quot;Cher&quot;, age: 76)] The record definition is nice and concise. It would look good in recent Java versions too. A nice aspect of the Groovy solution is that it will provide emulated records on earlier JDKs and it also has some nice declarative transforms to tweak the record definition. We could leave off the @ToString annotation and we&#39;d get a standard record-style toString. Or we could add a toString method to our record definition similar to what was done in the Java example. Using @ToString allows us to remove null last names from the toString in a declarative way. We&#39;ll cover the @Sortable annotation a little later. First off, Groovy&#39;s spaceship operator &lt;=&gt; allows us to write a nice compact version of the &quot;tedious&quot; code in the first Java version. It looks like this: celebrities.sort { c1, c2 -&gt; c1.last &lt;=&gt; c2.last ?: c1.first &lt;=&gt; c2.first ?: c1.age &lt;=&gt; c2.age}println &#39;Celebrities:\n&#39; + celebrities.join(&#39;\n&#39;) And the output looks like this: Celebrities: Celebrity(first:Cher, age:76) Celebrity(first:Alex, last:Lloyd, age:37) Celebrity(first:Alex, last:Lloyd, age:47) Celebrity(first:Cher, last:Lloyd, age:28) Celebrity(first:Cher, last:Wang, age:63) We&#39;d have a tiny bit more work to do if we wanted nulls last but the defaults work well for the example at hand. We can alternatively, make use of the &quot;new in JDK8&quot; methods mentioned earlier: celebrities.sort(comparing(Celebrity::last, nullsFirst(naturalOrder())). thenComparing(c -&gt; c.first).thenComparing(c -&gt; c.age)) But this is where we should come back and further explain the @Sortable annotation. That annotation is associated with an Abstract Syntax Tree (AST) transformation, or just transform for short, which provides us with an automatic compareTo method that takes into account the record&#39;s properties (and likewise if it was a class). Since we provided an includes annotation attribute and provided a list of property names, the order of those names determines the priority of the properties used in the comparator. We could equally include just some of the names in that list or alternatively provide an excludes annotation attribute and just mention that properties we don&#39;t want included. It also adds Comparable&lt;/code&gt; to the list of implemented interfaces for our record. So, what does all this mean? It means we can just write:&lt;/p&gt; celebrities.sort() The transform associated with the @Sortable annotation also provides some additional comparators for us. To sort by age, we can use one of those comparators: celebrities.sort(Celebrity.comparatorByAge()) Which gives this output: Celebrities: Celebrity(first:Cher, last:Lloyd, age:28) Celebrity(first:Alex, last:Lloyd, age:37) Celebrity(first:Alex, last:Lloyd, age:47) Celebrity(first:Cher, last:Wang, age:63) Celebrity(first:Cher, age:76) In addition to the sort method, Groovy provides a toSorted method which sorts a copy of the list, leaving the original unchanged. So, to create a list sorted by first name we can use this code: var celebritiesByFirst = celebrities.toSorted(Celebrity.comparatorByFirst()) Which if output in a similar way to previous examples gives: Celebrities: Celebrity(first:Alex, last:Lloyd, age:37) Celebrity(first:Alex, last:Lloyd, age:47) Celebrity(first:Cher, last:Lloyd, age:28) Celebrity(first:Cher, last:Wang, age:63) Celebrity(first:Cher, age:76) If you are a fan of functional style programming, you might consider using List.of to define the original list and then only toSorted method calls in further processing. Mixing in some language integrated queries Groovy also has a GQuery (aka GINQ) capability which provides a SQL inspired DSL for working with collections. We can use GQueries to examine and order our collection. Here is an example: println GQ { from c in celebrities select c.first, c.last, c.age} Which has this output: +-------+-------+-----+ | first | last&nbsp; | age | +-------+-------+-----+ | Cher&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;| 76&nbsp; | | Alex&nbsp; | Lloyd | 37&nbsp; | | Alex&nbsp; | Lloyd | 47&nbsp; | | Cher&nbsp; | Lloyd | 28&nbsp; | | Cher&nbsp; | Wang&nbsp; | 63&nbsp; | +-------+-------+-----+ In this case, it&#39;s using the natural ordering which @Sortable gives us. Or we can sort by age: println GQ { from c in celebrities orderby c.age select c.first, c.last, c.age} Which has this output: +-------+-------+-----+ | first | last&nbsp; | age | +-------+-------+-----+ | Cher&nbsp; | Lloyd | 28&nbsp; | | Alex&nbsp; | Lloyd | 37&nbsp; | | Alex&nbsp; | Lloyd | 47&nbsp; | | Cher&nbsp; | Wang&nbsp; | 63&nbsp; | | Cher&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;| 76&nbsp; | +-------+-------+-----+ Or we can sort by last name descending and then age: println GQ { from c in celebrities orderby c.last in desc, c.age select c.first, c.last, c.age} Which has this output: +-------+-------+-----+ | first | last&nbsp; | age | +-------+-------+-----+ | Cher&nbsp; | Wang&nbsp; | 63&nbsp; | | Cher&nbsp; | Lloyd | 28&nbsp; | | Alex&nbsp; | Lloyd | 37&nbsp; | | Alex&nbsp; | Lloyd | 47&nbsp; | | Cher&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;| 76&nbsp; | +-------+-------+-----+ Conclusion We have seen a little example of using comparators in Groovy. All the great JDK capabilities are available as well as the spaceship operator, the sort and toSorted methods, and the @Sortable AST transformation." />
<meta property="og:description" content="This blog post is inspired by the Comparator examples in the excellent Collections Refuelled talk and blog by Stuart Marks. That blog from 2017 highlights improvements in the Java collections library in Java 8 and 9 including numerous Comparator improvements. It is now 5 years old but still highly recommended for anyone using the Java collections library. Rather than have a Student class as per the original blog example, we&#39;ll have a Celebrity class (and later record) which has the same first and last name fields and an additional age field. We&#39;ll compare initially by last name with nulls before non-nulls and then by first name and lastly by age. As with the original blog, we&#39;ll cater for nulls, e.g. a celebrity known by a single name. The Java comparator story recap Our Celebrity class if we wrote it in Java would look something like: public class Celebrity { // Java private String firstName; private String lastName; private int age; public Celebrity(String firstName, int age) { this(firstName, null, age); } public Celebrity(String firstName, String lastName, int age) { this.firstName = firstName; this.lastName = lastName; this.age = age; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } @Override public String toString() { return &quot;Celebrity{&quot; + &quot;firstName=&#39;&quot; + firstName + (lastName == null ? &quot;&quot; : &quot;&#39;, lastName=&#39;&quot; + lastName) + &quot;&#39;, age=&quot; + age + &#39;}&#39;; }} It would look much nicer as a Java record (JDK16+) but we&#39;ll keep with the spirit of the original blog example for now. This is fairly standard boilerplate and in fact was mostly generated by IntelliJ IDEA. The only slightly interesting aspect is that we tweaked the toString method to not display null last names. On JDK 8 with the old-style comparator coding, a main application which created and sorted some celebrities might look like this: import java.util.ArrayList; // Javaimport java.util.Collections;import java.util.List;public class Main { public static void main(String[] args) { List&lt;Celebrity&gt; celebrities = new ArrayList&lt;&gt;(); celebrities.add(new Celebrity(&quot;Cher&quot;, &quot;Wang&quot;, 63)); celebrities.add(new Celebrity(&quot;Cher&quot;, &quot;Lloyd&quot;, 28)); celebrities.add(new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 47)); celebrities.add(new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 37)); celebrities.add(new Celebrity(&quot;Cher&quot;, 76)); Collections.sort(celebrities, (c1, c2) -&gt; { String f1 = c1.getLastName(); String f2 = c2.getLastName(); int r1; if (f1 == null) { r1 = f2 == null ? 0 : -1; } else { r1 = f2 == null ? 1 : f1.compareTo(f2); } if (r1 != 0) { return r1; } int r2 = c1.getFirstName().compareTo(c2.getFirstName()); if (r2 != 0) { return r2; } return Integer.compare(c1.getAge(), c2.getAge()); }); System.out.println(&quot;Celebrities:&quot;); celebrities.forEach(System.out::println); }} When we run this example, the output looks like this: Celebrities: Celebrity{firstName=&#39;Cher&#39;, age=76} Celebrity{firstName=&#39;Alex&#39;, lastName=&#39;Lloyd&#39;, age=37} Celebrity{firstName=&#39;Alex&#39;, lastName=&#39;Lloyd&#39;, age=47} Celebrity{firstName=&#39;Cher&#39;, lastName=&#39;Lloyd&#39;, age=28} Celebrity{firstName=&#39;Cher&#39;, lastName=&#39;Wang&#39;, age=63} As pointed out in the original blog, this code is rather tedious and error-prone and can be improved greatly with comparator improvements in JDK8: import java.util.Arrays; // Javaimport java.util.List;import static java.util.Comparator.comparing;import static java.util.Comparator.naturalOrder;import static java.util.Comparator.nullsFirst;public class Main { public static void main(String[] args) { List&lt;Celebrity&gt; celebrities = Arrays.asList( new Celebrity(&quot;Cher&quot;, &quot;Wang&quot;, 63), new Celebrity(&quot;Cher&quot;, &quot;Lloyd&quot;, 28), new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 47), new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 37), new Celebrity(&quot;Cher&quot;, 76)); celebrities.sort(comparing(Celebrity::getLastName, nullsFirst(naturalOrder())). thenComparing(Celebrity::getFirstName).thenComparing(Celebrity::getAge)); System.out.println(&quot;Celebrities:&quot;); celebrities.forEach(System.out::println); }} The original blog also points out the convenience factory methods from JDK9 for list creation which you might be tempted to consider here. For our case, we will be sorting in place, so the immutable lists returned by those methods won&#39;t help us here but Arrays.asList isn&#39;t much longer than List.of and works well for this example. As well as being much shorter, the comparing and thenComparing methods and built-in comparators like nullsFirst and naturalOrdering allow for far simpler composability. The sort within array list is also more efficient than the sort that would have been used with the Collections.sort method on earlier JDKs. The output when running the example is the same as previously. The Groovy comparator story At about the same time that Java was evolving its comparator story Groovy added some complementary features to tackle many of the same problems. We&#39;ll look at some of those features and also how the JDK improvements we saw above features can be used instead if preferred. First off, let&#39;s create a Groovy Celebrity record: @Sortable(includes = &#39;last,first,age&#39;)@ToString(ignoreNulls = true, includeNames = true)record Celebrity(String first, String last = null, int age) {} And create our list of celebrities: var celebrities = [ new Celebrity(&quot;Cher&quot;, &quot;Wang&quot;, 63), new Celebrity(&quot;Cher&quot;, &quot;Lloyd&quot;, 28), new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 47), new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 37), new Celebrity(first: &quot;Cher&quot;, age: 76)] The record definition is nice and concise. It would look good in recent Java versions too. A nice aspect of the Groovy solution is that it will provide emulated records on earlier JDKs and it also has some nice declarative transforms to tweak the record definition. We could leave off the @ToString annotation and we&#39;d get a standard record-style toString. Or we could add a toString method to our record definition similar to what was done in the Java example. Using @ToString allows us to remove null last names from the toString in a declarative way. We&#39;ll cover the @Sortable annotation a little later. First off, Groovy&#39;s spaceship operator &lt;=&gt; allows us to write a nice compact version of the &quot;tedious&quot; code in the first Java version. It looks like this: celebrities.sort { c1, c2 -&gt; c1.last &lt;=&gt; c2.last ?: c1.first &lt;=&gt; c2.first ?: c1.age &lt;=&gt; c2.age}println &#39;Celebrities:\n&#39; + celebrities.join(&#39;\n&#39;) And the output looks like this: Celebrities: Celebrity(first:Cher, age:76) Celebrity(first:Alex, last:Lloyd, age:37) Celebrity(first:Alex, last:Lloyd, age:47) Celebrity(first:Cher, last:Lloyd, age:28) Celebrity(first:Cher, last:Wang, age:63) We&#39;d have a tiny bit more work to do if we wanted nulls last but the defaults work well for the example at hand. We can alternatively, make use of the &quot;new in JDK8&quot; methods mentioned earlier: celebrities.sort(comparing(Celebrity::last, nullsFirst(naturalOrder())). thenComparing(c -&gt; c.first).thenComparing(c -&gt; c.age)) But this is where we should come back and further explain the @Sortable annotation. That annotation is associated with an Abstract Syntax Tree (AST) transformation, or just transform for short, which provides us with an automatic compareTo method that takes into account the record&#39;s properties (and likewise if it was a class). Since we provided an includes annotation attribute and provided a list of property names, the order of those names determines the priority of the properties used in the comparator. We could equally include just some of the names in that list or alternatively provide an excludes annotation attribute and just mention that properties we don&#39;t want included. It also adds Comparable&lt;/code&gt; to the list of implemented interfaces for our record. So, what does all this mean? It means we can just write:&lt;/p&gt; celebrities.sort() The transform associated with the @Sortable annotation also provides some additional comparators for us. To sort by age, we can use one of those comparators: celebrities.sort(Celebrity.comparatorByAge()) Which gives this output: Celebrities: Celebrity(first:Cher, last:Lloyd, age:28) Celebrity(first:Alex, last:Lloyd, age:37) Celebrity(first:Alex, last:Lloyd, age:47) Celebrity(first:Cher, last:Wang, age:63) Celebrity(first:Cher, age:76) In addition to the sort method, Groovy provides a toSorted method which sorts a copy of the list, leaving the original unchanged. So, to create a list sorted by first name we can use this code: var celebritiesByFirst = celebrities.toSorted(Celebrity.comparatorByFirst()) Which if output in a similar way to previous examples gives: Celebrities: Celebrity(first:Alex, last:Lloyd, age:37) Celebrity(first:Alex, last:Lloyd, age:47) Celebrity(first:Cher, last:Lloyd, age:28) Celebrity(first:Cher, last:Wang, age:63) Celebrity(first:Cher, age:76) If you are a fan of functional style programming, you might consider using List.of to define the original list and then only toSorted method calls in further processing. Mixing in some language integrated queries Groovy also has a GQuery (aka GINQ) capability which provides a SQL inspired DSL for working with collections. We can use GQueries to examine and order our collection. Here is an example: println GQ { from c in celebrities select c.first, c.last, c.age} Which has this output: +-------+-------+-----+ | first | last&nbsp; | age | +-------+-------+-----+ | Cher&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;| 76&nbsp; | | Alex&nbsp; | Lloyd | 37&nbsp; | | Alex&nbsp; | Lloyd | 47&nbsp; | | Cher&nbsp; | Lloyd | 28&nbsp; | | Cher&nbsp; | Wang&nbsp; | 63&nbsp; | +-------+-------+-----+ In this case, it&#39;s using the natural ordering which @Sortable gives us. Or we can sort by age: println GQ { from c in celebrities orderby c.age select c.first, c.last, c.age} Which has this output: +-------+-------+-----+ | first | last&nbsp; | age | +-------+-------+-----+ | Cher&nbsp; | Lloyd | 28&nbsp; | | Alex&nbsp; | Lloyd | 37&nbsp; | | Alex&nbsp; | Lloyd | 47&nbsp; | | Cher&nbsp; | Wang&nbsp; | 63&nbsp; | | Cher&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;| 76&nbsp; | +-------+-------+-----+ Or we can sort by last name descending and then age: println GQ { from c in celebrities orderby c.last in desc, c.age select c.first, c.last, c.age} Which has this output: +-------+-------+-----+ | first | last&nbsp; | age | +-------+-------+-----+ | Cher&nbsp; | Wang&nbsp; | 63&nbsp; | | Cher&nbsp; | Lloyd | 28&nbsp; | | Alex&nbsp; | Lloyd | 37&nbsp; | | Alex&nbsp; | Lloyd | 47&nbsp; | | Cher&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;| 76&nbsp; | +-------+-------+-----+ Conclusion We have seen a little example of using comparators in Groovy. All the great JDK capabilities are available as well as the spaceship operator, the sort and toSorted methods, and the @Sortable AST transformation." />
<link rel="canonical" href="http://localhost:4000/groovy/entry/comparators-and-sorting-in-groovy" />
<meta property="og:url" content="http://localhost:4000/groovy/entry/comparators-and-sorting-in-groovy" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-07-22T04:10:26-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Comparators and Sorting in Groovy" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-22T04:10:26-04:00","datePublished":"2022-07-22T04:10:26-04:00","description":"This blog post is inspired by the Comparator examples in the excellent Collections Refuelled talk and blog by Stuart Marks. That blog from 2017 highlights improvements in the Java collections library in Java 8 and 9 including numerous Comparator improvements. It is now 5 years old but still highly recommended for anyone using the Java collections library. Rather than have a Student class as per the original blog example, we&#39;ll have a Celebrity class (and later record) which has the same first and last name fields and an additional age field. We&#39;ll compare initially by last name with nulls before non-nulls and then by first name and lastly by age. As with the original blog, we&#39;ll cater for nulls, e.g. a celebrity known by a single name. The Java comparator story recap Our Celebrity class if we wrote it in Java would look something like: public class Celebrity { // Java private String firstName; private String lastName; private int age; public Celebrity(String firstName, int age) { this(firstName, null, age); } public Celebrity(String firstName, String lastName, int age) { this.firstName = firstName; this.lastName = lastName; this.age = age; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } @Override public String toString() { return &quot;Celebrity{&quot; + &quot;firstName=&#39;&quot; + firstName + (lastName == null ? &quot;&quot; : &quot;&#39;, lastName=&#39;&quot; + lastName) + &quot;&#39;, age=&quot; + age + &#39;}&#39;; }} It would look much nicer as a Java record (JDK16+) but we&#39;ll keep with the spirit of the original blog example for now. This is fairly standard boilerplate and in fact was mostly generated by IntelliJ IDEA. The only slightly interesting aspect is that we tweaked the toString method to not display null last names. On JDK 8 with the old-style comparator coding, a main application which created and sorted some celebrities might look like this: import java.util.ArrayList; // Javaimport java.util.Collections;import java.util.List;public class Main { public static void main(String[] args) { List&lt;Celebrity&gt; celebrities = new ArrayList&lt;&gt;(); celebrities.add(new Celebrity(&quot;Cher&quot;, &quot;Wang&quot;, 63)); celebrities.add(new Celebrity(&quot;Cher&quot;, &quot;Lloyd&quot;, 28)); celebrities.add(new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 47)); celebrities.add(new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 37)); celebrities.add(new Celebrity(&quot;Cher&quot;, 76)); Collections.sort(celebrities, (c1, c2) -&gt; { String f1 = c1.getLastName(); String f2 = c2.getLastName(); int r1; if (f1 == null) { r1 = f2 == null ? 0 : -1; } else { r1 = f2 == null ? 1 : f1.compareTo(f2); } if (r1 != 0) { return r1; } int r2 = c1.getFirstName().compareTo(c2.getFirstName()); if (r2 != 0) { return r2; } return Integer.compare(c1.getAge(), c2.getAge()); }); System.out.println(&quot;Celebrities:&quot;); celebrities.forEach(System.out::println); }} When we run this example, the output looks like this: Celebrities: Celebrity{firstName=&#39;Cher&#39;, age=76} Celebrity{firstName=&#39;Alex&#39;, lastName=&#39;Lloyd&#39;, age=37} Celebrity{firstName=&#39;Alex&#39;, lastName=&#39;Lloyd&#39;, age=47} Celebrity{firstName=&#39;Cher&#39;, lastName=&#39;Lloyd&#39;, age=28} Celebrity{firstName=&#39;Cher&#39;, lastName=&#39;Wang&#39;, age=63} As pointed out in the original blog, this code is rather tedious and error-prone and can be improved greatly with comparator improvements in JDK8: import java.util.Arrays; // Javaimport java.util.List;import static java.util.Comparator.comparing;import static java.util.Comparator.naturalOrder;import static java.util.Comparator.nullsFirst;public class Main { public static void main(String[] args) { List&lt;Celebrity&gt; celebrities = Arrays.asList( new Celebrity(&quot;Cher&quot;, &quot;Wang&quot;, 63), new Celebrity(&quot;Cher&quot;, &quot;Lloyd&quot;, 28), new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 47), new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 37), new Celebrity(&quot;Cher&quot;, 76)); celebrities.sort(comparing(Celebrity::getLastName, nullsFirst(naturalOrder())). thenComparing(Celebrity::getFirstName).thenComparing(Celebrity::getAge)); System.out.println(&quot;Celebrities:&quot;); celebrities.forEach(System.out::println); }} The original blog also points out the convenience factory methods from JDK9 for list creation which you might be tempted to consider here. For our case, we will be sorting in place, so the immutable lists returned by those methods won&#39;t help us here but Arrays.asList isn&#39;t much longer than List.of and works well for this example. As well as being much shorter, the comparing and thenComparing methods and built-in comparators like nullsFirst and naturalOrdering allow for far simpler composability. The sort within array list is also more efficient than the sort that would have been used with the Collections.sort method on earlier JDKs. The output when running the example is the same as previously. The Groovy comparator story At about the same time that Java was evolving its comparator story Groovy added some complementary features to tackle many of the same problems. We&#39;ll look at some of those features and also how the JDK improvements we saw above features can be used instead if preferred. First off, let&#39;s create a Groovy Celebrity record: @Sortable(includes = &#39;last,first,age&#39;)@ToString(ignoreNulls = true, includeNames = true)record Celebrity(String first, String last = null, int age) {} And create our list of celebrities: var celebrities = [ new Celebrity(&quot;Cher&quot;, &quot;Wang&quot;, 63), new Celebrity(&quot;Cher&quot;, &quot;Lloyd&quot;, 28), new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 47), new Celebrity(&quot;Alex&quot;, &quot;Lloyd&quot;, 37), new Celebrity(first: &quot;Cher&quot;, age: 76)] The record definition is nice and concise. It would look good in recent Java versions too. A nice aspect of the Groovy solution is that it will provide emulated records on earlier JDKs and it also has some nice declarative transforms to tweak the record definition. We could leave off the @ToString annotation and we&#39;d get a standard record-style toString. Or we could add a toString method to our record definition similar to what was done in the Java example. Using @ToString allows us to remove null last names from the toString in a declarative way. We&#39;ll cover the @Sortable annotation a little later. First off, Groovy&#39;s spaceship operator &lt;=&gt; allows us to write a nice compact version of the &quot;tedious&quot; code in the first Java version. It looks like this: celebrities.sort { c1, c2 -&gt; c1.last &lt;=&gt; c2.last ?: c1.first &lt;=&gt; c2.first ?: c1.age &lt;=&gt; c2.age}println &#39;Celebrities:\\n&#39; + celebrities.join(&#39;\\n&#39;) And the output looks like this: Celebrities: Celebrity(first:Cher, age:76) Celebrity(first:Alex, last:Lloyd, age:37) Celebrity(first:Alex, last:Lloyd, age:47) Celebrity(first:Cher, last:Lloyd, age:28) Celebrity(first:Cher, last:Wang, age:63) We&#39;d have a tiny bit more work to do if we wanted nulls last but the defaults work well for the example at hand. We can alternatively, make use of the &quot;new in JDK8&quot; methods mentioned earlier: celebrities.sort(comparing(Celebrity::last, nullsFirst(naturalOrder())). thenComparing(c -&gt; c.first).thenComparing(c -&gt; c.age)) But this is where we should come back and further explain the @Sortable annotation. That annotation is associated with an Abstract Syntax Tree (AST) transformation, or just transform for short, which provides us with an automatic compareTo method that takes into account the record&#39;s properties (and likewise if it was a class). Since we provided an includes annotation attribute and provided a list of property names, the order of those names determines the priority of the properties used in the comparator. We could equally include just some of the names in that list or alternatively provide an excludes annotation attribute and just mention that properties we don&#39;t want included. It also adds Comparable&lt;/code&gt; to the list of implemented interfaces for our record. So, what does all this mean? It means we can just write:&lt;/p&gt; celebrities.sort() The transform associated with the @Sortable annotation also provides some additional comparators for us. To sort by age, we can use one of those comparators: celebrities.sort(Celebrity.comparatorByAge()) Which gives this output: Celebrities: Celebrity(first:Cher, last:Lloyd, age:28) Celebrity(first:Alex, last:Lloyd, age:37) Celebrity(first:Alex, last:Lloyd, age:47) Celebrity(first:Cher, last:Wang, age:63) Celebrity(first:Cher, age:76) In addition to the sort method, Groovy provides a toSorted method which sorts a copy of the list, leaving the original unchanged. So, to create a list sorted by first name we can use this code: var celebritiesByFirst = celebrities.toSorted(Celebrity.comparatorByFirst()) Which if output in a similar way to previous examples gives: Celebrities: Celebrity(first:Alex, last:Lloyd, age:37) Celebrity(first:Alex, last:Lloyd, age:47) Celebrity(first:Cher, last:Lloyd, age:28) Celebrity(first:Cher, last:Wang, age:63) Celebrity(first:Cher, age:76) If you are a fan of functional style programming, you might consider using List.of to define the original list and then only toSorted method calls in further processing. Mixing in some language integrated queries Groovy also has a GQuery (aka GINQ) capability which provides a SQL inspired DSL for working with collections. We can use GQueries to examine and order our collection. Here is an example: println GQ { from c in celebrities select c.first, c.last, c.age} Which has this output: +-------+-------+-----+ | first | last&nbsp; | age | +-------+-------+-----+ | Cher&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;| 76&nbsp; | | Alex&nbsp; | Lloyd | 37&nbsp; | | Alex&nbsp; | Lloyd | 47&nbsp; | | Cher&nbsp; | Lloyd | 28&nbsp; | | Cher&nbsp; | Wang&nbsp; | 63&nbsp; | +-------+-------+-----+ In this case, it&#39;s using the natural ordering which @Sortable gives us. Or we can sort by age: println GQ { from c in celebrities orderby c.age select c.first, c.last, c.age} Which has this output: +-------+-------+-----+ | first | last&nbsp; | age | +-------+-------+-----+ | Cher&nbsp; | Lloyd | 28&nbsp; | | Alex&nbsp; | Lloyd | 37&nbsp; | | Alex&nbsp; | Lloyd | 47&nbsp; | | Cher&nbsp; | Wang&nbsp; | 63&nbsp; | | Cher&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;| 76&nbsp; | +-------+-------+-----+ Or we can sort by last name descending and then age: println GQ { from c in celebrities orderby c.last in desc, c.age select c.first, c.last, c.age} Which has this output: +-------+-------+-----+ | first | last&nbsp; | age | +-------+-------+-----+ | Cher&nbsp; | Wang&nbsp; | 63&nbsp; | | Cher&nbsp; | Lloyd | 28&nbsp; | | Alex&nbsp; | Lloyd | 37&nbsp; | | Alex&nbsp; | Lloyd | 47&nbsp; | | Cher&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;| 76&nbsp; | +-------+-------+-----+ Conclusion We have seen a little example of using comparators in Groovy. All the great JDK capabilities are available as well as the spaceship operator, the sort and toSorted methods, and the @Sortable AST transformation.","headline":"Comparators and Sorting in Groovy","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/groovy/entry/comparators-and-sorting-in-groovy"},"url":"http://localhost:4000/groovy/entry/comparators-and-sorting-in-groovy"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Comparators and Sorting in Groovy</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-07-22T04:10:26-04:00" itemprop="datePublished">Jul 22, 2022
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Paul King", "login"=>"paulk", "email"=>"paulk@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><img src="https://blogs.apache.org/groovy/mediaresource/2eb621f3-0419-437e-950b-0c9e5e15804e" align="right" style="width:15%;" alt="2022-07-22 01_05_29-s-l300.webp (300&times;291).png">This blog post is inspired by the Comparator examples in the excellent <i>Collections Refuelled</i> <a href="https://www.youtube.com/watch?v=q6zF3vf114M&amp;t=13s" target="_blank">talk</a> and <a href="https://blogs.oracle.com/java/post/collections-refueled" target="_blank">blog</a> by Stuart Marks. That blog from 2017 highlights improvements in the Java collections library in Java 8 and 9 including numerous Comparator improvements. It is now 5 years old but still highly recommended for anyone using the Java collections library.</p>
<p>Rather than have a <code>Student</code> class as per the original blog example, we'll have a <code>Celebrity</code> class (and later record) which has the same <code>first</code> and <code>last</code> name fields and an additional <code>age</code> field. We'll compare initially by <code>last</code> name with nulls before non-nulls and then by <code>first</code> name and lastly by <code>age</code>.</p>
<p>As with the original blog, we'll cater for nulls, e.g. a celebrity known by a single name.</p>
<h3>The Java comparator story recap</h3>
<p><img src="https://blogs.apache.org/groovy/mediaresource/97dd3c82-aae5-481a-a158-701c8244d5c1" style="width:10%;" align="right" alt="JavaTransparent.png">Our <code>Celebrity</code> class if we wrote it in Java would look something like:</p>
<pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#0033b3;">public class </span><span style="color:#000000;">Celebrity </span>{                    <span style="color:#777777;">// Java</span><br>    <span style="color:#0033b3;">private </span><span style="color:#000000;">String </span><span style="color:#871094;">firstName</span>;<br>    <span style="color:#0033b3;">private </span><span style="color:#000000;">String </span><span style="color:#871094;">lastName</span>;<br>    <span style="color:#0033b3;">private int </span><span style="color:#871094;">age</span>;<br><br>    <span style="color:#0033b3;">public </span><span style="color:#00627a;">Celebrity</span>(<span style="color:#000000;">String </span>firstName, <span style="color:#0033b3;">int </span>age) {<br>        <span style="color:#0033b3;">this</span>(firstName, <span style="color:#0033b3;">null</span>, age);<br>    }<br><br>    <span style="color:#0033b3;">public </span><span style="color:#00627a;">Celebrity</span>(<span style="color:#000000;">String </span>firstName, <span style="color:#000000;">String </span>lastName, <span style="color:#0033b3;">int </span>age) {<br>        <span style="color:#0033b3;">this</span>.<span style="color:#871094;">firstName </span>= firstName;<br>        <span style="color:#0033b3;">this</span>.<span style="color:#871094;">lastName </span>= lastName;<br>        <span style="color:#0033b3;">this</span>.<span style="color:#871094;">age </span>= age;<br>    }<br><br>    <span style="color:#0033b3;">public int </span><span style="color:#00627a;">getAge</span>() {<br>        <span style="color:#0033b3;">return </span><span style="color:#871094;">age</span>;<br>    }<br><br>    <span style="color:#0033b3;">public void </span><span style="color:#00627a;">setAge</span>(<span style="color:#0033b3;">int </span>age) {<br>        <span style="color:#0033b3;">this</span>.<span style="color:#871094;">age </span>= age;<br>    }<br><br>    <span style="color:#0033b3;">public </span><span style="color:#000000;">String </span><span style="color:#00627a;">getFirstName</span>() {<br>        <span style="color:#0033b3;">return </span><span style="color:#871094;">firstName</span>;<br>    }<br><br>    <span style="color:#0033b3;">public void </span><span style="color:#00627a;">setFirstName</span>(<span style="color:#000000;">String </span>firstName) {<br>        <span style="color:#0033b3;">this</span>.<span style="color:#871094;">firstName </span>= firstName;<br>    }<br><br>    <span style="color:#0033b3;">public </span><span style="color:#000000;">String </span><span style="color:#00627a;">getLastName</span>() {<br>        <span style="color:#0033b3;">return </span><span style="color:#871094;">lastName</span>;<br>    }<br><br>    <span style="color:#0033b3;">public void </span><span style="color:#00627a;">setLastName</span>(<span style="color:#000000;">String </span>lastName) {<br>        <span style="color:#0033b3;">this</span>.<span style="color:#871094;">lastName </span>= lastName;<br>    }<br><br>    <span style="color:#9e880d;">@Override<br></span><span style="color:#9e880d;">    </span><span style="color:#0033b3;">public </span><span style="color:#000000;">String </span><span style="color:#00627a;">toString</span>() {<br>        <span style="color:#0033b3;">return </span><span style="color:#067d17;">"Celebrity{" </span>+<br>                <span style="color:#067d17;">"firstName='" </span>+ <span style="color:#871094;">firstName </span>+<br>                (<span style="color:#871094;">lastName </span>== <span style="color:#0033b3;">null </span>? <span style="color:#067d17;">"" </span>: <span style="color:#067d17;">"', lastName='" </span>+ <span style="color:#871094;">lastName</span>) +<br>                <span style="color:#067d17;">"', age=" </span>+ <span style="color:#871094;">age </span>+<br>                <span style="color:#067d17;">'}'</span>;<br>    }<br>}<br></pre>
<p>It would look much nicer as a Java record (JDK16+) but we'll keep with the spirit of the original blog example for now. This is fairly standard boilerplate and in fact was mostly generated by IntelliJ IDEA. The only slightly interesting aspect is that we tweaked the <code>toString</code> method to not display null last names.</p>
<p>On JDK 8 with the old-style comparator coding, a main application which created and sorted some celebrities might look like this:</p>
<pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#0033b3;">import </span><span style="color:#000000;">java.util.ArrayList</span>;            <span style="color:#777777;">// Java</span><br><span style="color:#0033b3;">import </span><span style="color:#000000;">java.util.Collections</span>;<br><span style="color:#0033b3;">import </span><span style="color:#000000;">java.util.List</span>;<br><br><span style="color:#0033b3;">public class </span><span style="color:#000000;">Main </span>{<br>    <span style="color:#0033b3;">public static void </span><span style="color:#00627a;">main</span>(<span style="color:#000000;">String</span>[] args) {<br>        <span style="color:#000000;">List</span><<span style="color:#000000;">Celebrity</span>> <span style="color:#000000;">celebrities </span>= <span style="color:#0033b3;">new </span>ArrayList<>();<br>        <span style="color:#000000;">celebrities</span>.add(<span style="color:#0033b3;">new </span>Celebrity(<span style="color:#067d17;">"Cher"</span>, <span style="color:#067d17;">"Wang"</span>, <span style="color:#1750eb;">63</span>));<br>        <span style="color:#000000;">celebrities</span>.add(<span style="color:#0033b3;">new </span>Celebrity(<span style="color:#067d17;">"Cher"</span>, <span style="color:#067d17;">"Lloyd"</span>, <span style="color:#1750eb;">28</span>));<br>        <span style="color:#000000;">celebrities</span>.add(<span style="color:#0033b3;">new </span>Celebrity(<span style="color:#067d17;">"Alex"</span>, <span style="color:#067d17;">"Lloyd"</span>, <span style="color:#1750eb;">47</span>));<br>        <span style="color:#000000;">celebrities</span>.add(<span style="color:#0033b3;">new </span>Celebrity(<span style="color:#067d17;">"Alex"</span>, <span style="color:#067d17;">"Lloyd"</span>, <span style="color:#1750eb;">37</span>));<br>        <span style="color:#000000;">celebrities</span>.add(<span style="color:#0033b3;">new </span>Celebrity(<span style="color:#067d17;">"Cher"</span>, <span style="color:#1750eb;">76</span>));<br>        <span style="color:#000000;">Collections</span>.<span style="font-style:italic;">sort</span>(<span style="color:#000000;">celebrities</span>, (c1, c2) -> {<br>            <span style="color:#000000;">String f1 </span>= c1.getLastName();<br>            <span style="color:#000000;">String f2 </span>= c2.getLastName();<br>            <span style="color:#0033b3;">int </span><span style="color:#000000;">r1</span>;<br>            <span style="color:#0033b3;">if </span>(<span style="color:#000000;">f1 </span>== <span style="color:#0033b3;">null</span>) {<br>                <span style="color:#000000;">r1 </span>= <span style="color:#000000;">f2 </span>== <span style="color:#0033b3;">null </span>? <span style="color:#1750eb;">0 </span>: -<span style="color:#1750eb;">1</span>;<br>            } <span style="color:#0033b3;">else </span>{<br>                <span style="color:#000000;">r1 </span>= <span style="color:#000000;">f2 </span>== <span style="color:#0033b3;">null </span>? <span style="color:#1750eb;">1 </span>: <span style="color:#000000;">f1</span>.compareTo(<span style="color:#000000;">f2</span>);<br>            }<br>            <span style="color:#0033b3;">if </span>(<span style="color:#000000;">r1 </span>!= <span style="color:#1750eb;">0</span>) {<br>                <span style="color:#0033b3;">return </span><span style="color:#000000;">r1</span>;<br>            }<br>            <span style="color:#0033b3;">int </span><span style="color:#000000;">r2 </span>= c1.getFirstName().compareTo(c2.getFirstName());<br>            <span style="color:#0033b3;">if </span>(<span style="color:#000000;">r2 </span>!= <span style="color:#1750eb;">0</span>) {<br>                <span style="color:#0033b3;">return </span><span style="color:#000000;">r2</span>;<br>            }<br>            <span style="color:#0033b3;">return </span><span style="color:#000000;">Integer</span>.<span style="font-style:italic;">compare</span>(c1.getAge(), c2.getAge());<br>        });<br>        <span style="color:#000000;">System</span>.<span style="color:#871094;font-style:italic;">out</span>.println(<span style="color:#067d17;">"Celebrities:"</span>);<br>        <span style="color:#000000;">celebrities</span>.forEach(<span style="color:#000000;">System</span>.<span style="color:#871094;font-style:italic;">out</span>::println);<br>    }<br>}<br></pre>
<p>When we run this example, the output looks like this:</p>
<pre>Celebrities:
Celebrity{firstName='Cher', age=76}
Celebrity{firstName='Alex', lastName='Lloyd', age=37}
Celebrity{firstName='Alex', lastName='Lloyd', age=47}
Celebrity{firstName='Cher', lastName='Lloyd', age=28}
Celebrity{firstName='Cher', lastName='Wang', age=63}
</pre>
<p>As pointed out in the original blog, this code is rather tedious and error-prone and can be improved greatly with comparator improvements in JDK8:</p>
<pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#0033b3;">import </span><span style="color:#000000;">java.util.Arrays</span>;             // Java<br><span style="color:#0033b3;">import </span><span style="color:#000000;">java.util.List</span>;<br><br><span style="color:#0033b3;">import static </span><span style="color:#000000;">java.util.Comparator</span>.<span style="font-style:italic;">comparing</span>;<br><span style="color:#0033b3;">import static </span><span style="color:#000000;">java.util.Comparator</span>.<span style="font-style:italic;">naturalOrder</span>;<br><span style="color:#0033b3;">import static </span><span style="color:#000000;">java.util.Comparator</span>.<span style="font-style:italic;">nullsFirst</span>;<br><br><span style="color:#0033b3;">public class </span><span style="color:#000000;">Main </span>{<br>    <span style="color:#0033b3;">public static void </span><span style="color:#00627a;">main</span>(<span style="color:#000000;">String</span>[] args) {<br>        <span style="color:#000000;">List</span><<span style="color:#000000;">Celebrity</span>> <span style="color:#000000;">celebrities </span>= <span style="color:#000000;">Arrays</span>.<span style="font-style:italic;">asList</span>(<br>                <span style="color:#0033b3;">new </span>Celebrity(<span style="color:#067d17;">"Cher"</span>, <span style="color:#067d17;">"Wang"</span>, <span style="color:#1750eb;">63</span>),<br>                <span style="color:#0033b3;">new </span>Celebrity(<span style="color:#067d17;">"Cher"</span>, <span style="color:#067d17;">"Lloyd"</span>, <span style="color:#1750eb;">28</span>),<br>                <span style="color:#0033b3;">new </span>Celebrity(<span style="color:#067d17;">"Alex"</span>, <span style="color:#067d17;">"Lloyd"</span>, <span style="color:#1750eb;">47</span>),<br>                <span style="color:#0033b3;">new </span>Celebrity(<span style="color:#067d17;">"Alex"</span>, <span style="color:#067d17;">"Lloyd"</span>, <span style="color:#1750eb;">37</span>),<br>                <span style="color:#0033b3;">new </span>Celebrity(<span style="color:#067d17;">"Cher"</span>, <span style="color:#1750eb;">76</span>));<br>        <span style="color:#000000;">celebrities</span>.sort(<span style="font-style:italic;">comparing</span>(<span style="color:#000000;">Celebrity</span>::getLastName, <span style="font-style:italic;">nullsFirst</span>(<span style="font-style:italic;">naturalOrder</span>())).<br>                thenComparing(<span style="color:#000000;">Celebrity</span>::getFirstName).thenComparing(<span style="color:#000000;">Celebrity</span>::getAge));<br>        <span style="color:#000000;">System</span>.<span style="color:#871094;font-style:italic;">out</span>.println(<span style="color:#067d17;">"Celebrities:"</span>);<br>        <span style="color:#000000;">celebrities</span>.forEach(<span style="color:#000000;">System</span>.<span style="color:#871094;font-style:italic;">out</span>::println);<br>    }<br>}<br></pre>
<p>The original blog also points out the convenience factory methods from JDK9 for list creation which you might be tempted to consider here. For our case, we will be sorting in place, so the immutable lists returned by those methods won't help us here but <code>Arrays.asList</code> isn't much longer than <code>List.of</code> and works well for this example.</p>
<p>As well as being much shorter, the <code>comparing</code> and <code>thenComparing</code> methods and built-in comparators like <code>nullsFirst</code> and <code>naturalOrdering</code> allow for far simpler composability. The sort within array list is also more efficient than the sort that would have been used with the <code>Collections.sort</code> method on earlier JDKs. The output when running the example is the same as previously.</p>
<h3>The Groovy comparator story</h3>
<p><img src="https://blogs.apache.org/groovy/mediaresource/c5ba5e59-737e-4ebf-91c9-08fa67dc8f70" align="right" style="width:15%;" alt="groovy.png">At about the same time that Java was evolving its comparator story Groovy added some complementary features to tackle many of the same problems. We'll look at some of those features and also how the JDK improvements we saw above features can be used instead if preferred.</p>
<p>First off, let's create a Groovy <code>Celebrity</code> record:</p>
<pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#9e880d;">@Sortable</span>(includes = <span style="color:#067d17;">'last,first,age'</span>)<br><span style="color:#9e880d;">@ToString</span>(ignoreNulls = <span style="color:#0033b3;">true</span>, includeNames = <span style="color:#0033b3;">true</span>)<br><span style="color:#0033b3;">record </span><span style="color:#000000;">Celebrity</span>(<span style="color:#000000;">String </span>first, <span style="color:#000000;">String </span>last = <span style="color:#0033b3;">null</span>, <span style="color:#0033b3;">int </span>age) {}</pre>
<p>And create our list of celebrities:</p>
<pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#0033b3;">var </span><span style="color:#000000;">celebrities </span>= [<br>    <span style="color:#0033b3;">new </span><span style="color:#000000;">Celebrity</span>(<span style="color:#067d17;">"Cher"</span>, <span style="color:#067d17;">"Wang"</span>, <span style="color:#1750eb;">63</span>),<br>    <span style="color:#0033b3;">new </span><span style="color:#000000;">Celebrity</span>(<span style="color:#067d17;">"Cher"</span>, <span style="color:#067d17;">"Lloyd"</span>, <span style="color:#1750eb;">28</span>),<br>    <span style="color:#0033b3;">new </span><span style="color:#000000;">Celebrity</span>(<span style="color:#067d17;">"Alex"</span>, <span style="color:#067d17;">"Lloyd"</span>, <span style="color:#1750eb;">47</span>),<br>    <span style="color:#0033b3;">new </span><span style="color:#000000;">Celebrity</span>(<span style="color:#067d17;">"Alex"</span>, <span style="color:#067d17;">"Lloyd"</span>, <span style="color:#1750eb;">37</span>),<br>    <span style="color:#0033b3;">new </span><span style="color:#000000;">Celebrity</span>(<span style="color:#067d17;">first</span>: <span style="color:#067d17;">"Cher"</span>, <span style="color:#067d17;">age</span>: <span style="color:#1750eb;">76</span>)<br>]<br></pre>
<p>The record definition is nice and concise. It would look good in recent Java versions too. A nice aspect of the Groovy solution is that it will provide emulated records on earlier JDKs and it also has some nice declarative transforms to tweak the record definition. We could leave off the <code>@ToString</code> annotation and we'd get a standard record-style <code>toString</code>. Or we could add a <code>toString</code> method to our record definition similar to what was done in the Java example. Using <code>@ToString</code> allows us to remove null last names from the <code>toString</code> in a declarative way. We'll cover the <code>@Sortable</code> annotation a little later.</p>
<p>First off, Groovy's spaceship operator <code><=></code> allows us to write a nice compact version of the "tedious" code in the first Java version. It looks like this:<br></p>
<pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#000000;">celebrities</span>.sort <span style="font-weight:bold;">{ </span>c1, c2 <span style="font-weight:bold;">-><br></span><span style="font-weight:bold;">    </span>c1.<span style="color:#871094;">last </span><=> c2.<span style="color:#871094;">last </span>?: c1.<span style="color:#871094;">first </span><=> c2.<span style="color:#871094;">first </span>?: c1.<span style="color:#871094;">age </span><=> c2.<span style="color:#871094;">age<br></span><span style="font-weight:bold;">}<br></span>println <span style="color:#067d17;">'Celebrities:</span><span style="color:#0037a6;">\n</span><span style="color:#067d17;">' </span>+ <span style="color:#000000;">celebrities</span>.join(<span style="color:#067d17;">'</span><span style="color:#0037a6;">\n</span><span style="color:#067d17;">'</span>)<br></pre>
<p>And the output looks like this:<br></p>
<pre>Celebrities:
Celebrity(first:Cher, age:76)
Celebrity(first:Alex, last:Lloyd, age:37)
Celebrity(first:Alex, last:Lloyd, age:47)
Celebrity(first:Cher, last:Lloyd, age:28)
Celebrity(first:Cher, last:Wang, age:63)</pre>
<p>We'd have a tiny bit more work to do if we wanted nulls last but the defaults work well for the example at hand.</p>
<p>We can alternatively, make use of the "new in JDK8" methods mentioned earlier:</p>
<pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#000000;">celebrities</span>.sort(<span style="font-style:italic;">comparing</span>(<span style="color:#000000;">Celebrity</span>::last, <span style="font-style:italic;">nullsFirst</span>(<span style="font-style:italic;">naturalOrder</span>())).<br>        thenComparing(c -> c.first).thenComparing(c -> c.age))<br></pre>
<p>But this is where we should come back and further explain the <code>@Sortable</code> annotation. That annotation is associated with an Abstract Syntax Tree (AST) transformation, or just <i>transform</i> for short, which provides us with an automatic <code>compareTo</code> method that takes into account the record's properties (and likewise if it was a class). Since we provided an <code>includes</code> annotation attribute and provided a list of property names, the order of those names determines the priority of the properties used in the comparator. We could equally include just some of the names in that list or alternatively provide an <code>excludes</code> annotation attribute and just mention that properties we don't want included.</p>
<p>It also adds <code>Comparable<Celebrity></code> to the list of implemented interfaces for our record. So, what does all this mean? It means we can just write:<br></p>
<pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#000000;">celebrities</span>.sort()<br></pre>
<p>The transform associated with the <code>@Sortable</code> annotation also provides some additional comparators for us. To sort by age, we can use one of those comparators:<br></p>
<pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#000000;">celebrities</span>.sort(<span style="color:#000000;">Celebrity</span>.comparatorByAge())<br></pre>
<p>Which gives this output:</p>
<pre>Celebrities:
Celebrity(first:Cher, last:Lloyd, age:28)
Celebrity(first:Alex, last:Lloyd, age:37)
Celebrity(first:Alex, last:Lloyd, age:47)
Celebrity(first:Cher, last:Wang, age:63)
Celebrity(first:Cher, age:76)</pre>
<p>In addition to the <code>sort</code> method, Groovy provides a <code>toSorted</code> method which sorts a copy of the list, leaving the original unchanged. So, to create a list sorted by first name we can use this code:</p>
<pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#0033b3;">var </span><span style="color:#000000;">celebritiesByFirst </span>= <span style="color:#000000;">celebrities</span>.toSorted(<span style="color:#000000;">Celebrity</span>.comparatorByFirst())</pre>
<p>Which if output in a similar way to previous examples gives:</p>
<pre>Celebrities:
Celebrity(first:Alex, last:Lloyd, age:37)
Celebrity(first:Alex, last:Lloyd, age:47)
Celebrity(first:Cher, last:Lloyd, age:28)
Celebrity(first:Cher, last:Wang, age:63)
Celebrity(first:Cher, age:76)</pre>
<p>If you are a fan of functional style programming, you might consider using <code>List.of</code> to define the original list and then only <code>toSorted</code> method calls in further processing.</p>
<h3>Mixing in some language integrated queries</h3>
<p>Groovy also has a GQuery (aka GINQ) capability which provides a SQL inspired DSL for working with collections. We can use GQueries to examine and order our collection. Here is an example:</p>
<pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">println <span style="font-style:italic;">GQ </span><span style="font-weight:bold;">{<br></span>    from c <span style="color: rgb(0, 51, 179);">in </span><span style="color: rgb(0, 0, 0);">celebrities<br></span><span style="color: rgb(0, 0, 0);">    </span>select c.first, c.last, c.age<br><span style="font-weight:bold;">}</span></pre>
<p>Which has this output:</p>
<pre>+-------+-------+-----+
| first | last&nbsp; | age |
+-------+-------+-----+
| Cher&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;| 76&nbsp; |
| Alex&nbsp; | Lloyd | 37&nbsp; |
| Alex&nbsp; | Lloyd | 47&nbsp; |
| Cher&nbsp; | Lloyd | 28&nbsp; |
| Cher&nbsp; | Wang&nbsp; | 63&nbsp; |
+-------+-------+-----+</pre>
<p>In this case, it's using the natural ordering which <code>@Sortable</code> gives us.</p>
<p>Or we can sort by age:</p>
<pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">println <span style="font-style:italic;">GQ </span><span style="font-weight:bold;">{<br></span>    from c <span style="color: rgb(0, 51, 179);">in </span><span style="color: rgb(0, 0, 0);">celebrities<br></span><span style="color: rgb(0, 0, 0);">    </span>orderby c.age<br>    select c.first, c.last, c.age<br><span style="font-weight:bold;">}<br></span></pre>
<p>Which has this output:</p>
<pre>+-------+-------+-----+
| first | last&nbsp; | age |
+-------+-------+-----+
| Cher&nbsp; | Lloyd | 28&nbsp; |
| Alex&nbsp; | Lloyd | 37&nbsp; |
| Alex&nbsp; | Lloyd | 47&nbsp; |
| Cher&nbsp; | Wang&nbsp; | 63&nbsp; |
| Cher&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;| 76&nbsp; |
+-------+-------+-----+
</pre>
<p>Or we can sort by last name descending and then age:</p>
<pre style="background-color:#ffffff;color:#080808;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">println <span style="font-style:italic;">GQ </span><span style="font-weight:bold;">{<br></span>    from c <span style="color: rgb(0, 51, 179);">in </span><span style="color: rgb(0, 0, 0);">celebrities<br></span><span style="color: rgb(0, 0, 0);">    </span>orderby c.last <span style="color: rgb(0, 51, 179);">in </span>desc, c.age<br>    select c.first, c.last, c.age<br><span style="font-weight:bold;">}<br></span></pre>
<p>Which has this output:</p>
<pre>+-------+-------+-----+
| first | last&nbsp; | age |
+-------+-------+-----+
| Cher&nbsp; | Wang&nbsp; | 63&nbsp; |
| Cher&nbsp; | Lloyd | 28&nbsp; |
| Alex&nbsp; | Lloyd | 37&nbsp; |
| Alex&nbsp; | Lloyd | 47&nbsp; |
| Cher&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;| 76&nbsp; |
+-------+-------+-----+</pre>
<h3>Conclusion</h3>
<p>We have seen a little example of using comparators in Groovy. All the great JDK capabilities are available as well as the spaceship operator, the <code>sort</code> and <code>toSorted</code> methods, and the <code>@Sortable</code> AST transformation.</p>

  </div><a class="u-url" href="/groovy/entry/comparators-and-sorting-in-groovy" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
