<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Life on Mars: Units of Measurement systems, Groovy, and domain specific languages (DSLs) | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Life on Mars: Units of Measurement systems, Groovy, and domain specific languages (DSLs)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The Mars Climate Orbiter was launched in 1998 as part of a multi-faceted Mars exploration program. It was lost due to a trajectory calculation error when nearing Mars. An investigation attributed the failure to a measurement mismatch between two software systems: metric units were used by NASA and US customary units were used by spacecraft builder Lockheed Martin. If the system in question had been developed using a units of measurement system, perhaps the failure could have been avoided. Units of measurement systems All programming languages have types for representing numbers. As an example, we may have three integers, one representing a height, one a weight and one a temperature. We can write code to add those three integers together, but the result may have no useful meaning. We could start writing our own class hierarchies for each integer type but it can quickly become cumbersome to use the resulting classes. Units of measurement systems attempt to provide a range of commonplace units, ways to construct quantities from those units and ways to manipulate them. Manipulation might involve performing numerical calculation or conversions. Goals of such systems include the ability to provide runtime and/or compile-time type safety. So, we should fail early when trying to perform the earlier mentioned addition of three unrelated quantities. Units of measurement systems aren&#39;t new. There are existing systems in F# and Swift and Java has had several versions (and earlier attempts) around standardising such a system including: JSR 275: Units Specification (rejected earlier attempt) JSR 363: Units of Measurement API JSR 385: Units of Measurement API 2.0 There are also existing Java libraries like JScience which have been developed, and shown early promise, but now don&#39;t seem to be actively maintained. While the jury is still out about whether units of measurement systems will spread further into mainstream programming, now seems like a great time to check the status. The JSR 385 maintenance release was approved last year and the latest version of the reference implementation was released earlier this year. JSR 385: Units of Measurement API 2.0 The first thing we need to do is bring in our dependencies (shown for Gradle - other options). The main one is the reference implementation (it brings in the javax.measure API transitively): implementation &#39;tech.units:indriya:2.1.3&#39; JSR 385 is extensible. We&#39;ll also bring in some units from the Unicode CLDR units, e.g. MILE: implementation &#39;systems.uom:systems-unicode:2.1&#39;implementation &#39;systems.uom:systems-quantity:2.1&#39; Let&#39;s follow on with the theme of visiting Mars. We can create variables for the mass and diameter of Mars as follows: var massₘ = Quantities.getQuantity(6.39E23, KILO(GRAM))var diameterₘ = Quantities.getQuantity(6_779, KILOMETER)println massₘprintln diameterₘ JSR 385 has metric prefix qualifiers like MICRO, MILLI, CENTI, KILO, MEGA, GIGA and many more. The CLDR units also define some commonly used units like KILOMETER. We could choose either here. When we run this script, it has the following output: 639000000000000000000000 kg 6779 km If we try to compare or add those two values, we&#39;ll see an error. Groovy has both static and dynamic natures. Using dynamic code like this: println massₘ &gt; diameterₘ We&#39;ll see a runtime error like this: javax.measure.IncommensurableException: km is not compatible with kg Or, with TypeChecked or CompileStatic in play for a statement like this: println massₘ.add(diameterₘ) We&#39;d see a compile-time error like this: [Static type checking] - Cannot call tech.units.indriya.ComparableQuantity#add(javax.measure.Quantity&lt;javax.measure.quantity.Mass&gt;) with arguments [tech.units.indriya.ComparableQuantity&lt;javax.measure.quantity.Length&gt;] If for some strange reason we did want to compare or perform calculations between incommensurable types, we can explicitly get the value: assert massₘ.value &gt; diameterₘ.value This escape hatch takes off a layer of type safety but requires explicit work to do so. It is normally never the case that you would want to do this. JSR 385 also supports ranges and conversions. We can look at the minimum and maximum temperatures on Mars: var minTemp = Quantities.getQuantity(-128, CELSIUS)var maxTemp = Quantities.getQuantity(70, FAHRENHEIT)println minTempprintln minTemp.to(FAHRENHEIT)println maxTempprintln maxTemp.to(CELSIUS)println QuantityRange.of(minTemp, maxTemp) It&#39;s quite a bit colder than Earth! When run, this script has the following output: -128 ℃ -198.400 ((K*5)/9)+459.67 70 ((K*5)/9)+459.67 21.1111111111111111111111111111111 ℃ min= -128 ℃, max= 70 ((K*5)/9)+459.67 In case you&#39;re wondering about the strange looking unit display for Fahrenheit temperatures, the definition of that unit that we are using, defines degrees Fahrenheit using a formula calculated from the temperature in degrees Kelvin. We&#39;d see the same thing if using the MILE unit: println diameterₘ.to(MILE) Which shows us that the diameter of Mars is a little over 4200 miles: 4212.275312176886980036586335798934 (m*1609344)/1000 Adding some metaprogramming Groovy has various features which allow methods to be (apparently) added to classes. We&#39;ll use extension methods. This technique involves writing static methods in a helper class using certain conventions. The first parameter in all such methods is the target of the extension. Groovy code referencing instances of the target class have code that can call such a method as if it existed on the target class. In reality, the Groovy compiler or runtime funnels the call through the helper class. For us, it means we will have methods like getMeters() on the&nbsp;Number&nbsp;class which using Groovy&#39;s shorthand&#39;s for property notation allows for very compact quantity definitions like 5.meters. We&#39;ll also add some methods to allow Groovy&#39;s normal operator overloading syntax to apply: class UomExtensions { static Quantity getCentimeters(Number num) { Quantities.getQuantity(num, CENTI(METRE)) } static Quantity getMeters(Number num) { Quantities.getQuantity(num, METRE) } static Quantity getKilometers(Number num) { Quantities.getQuantity(num, KILO(METRE)) } static Quantity getCm(Number num) { getCentimeters(num) } static Quantity getM(Number num) { getMeters(num) } static Quantity getKm(Number num) { getKilometers(num) } static Quantity getKilograms(Number num) { Quantities.getQuantity(num, KILO(GRAM)) } static Quantity getKgs(Number num) { getKilograms(num) } static Quantity getHours(Number num) { Quantities.getQuantity(num, HOUR) } static Quantity getSeconds(Number num) { Quantities.getQuantity(num, SECOND) } static Quantity getHr(Number num) { getHours(num) } static Quantity getS(Number num) { getSeconds(num) } static Quantity div(Quantity q, Quantity divisor) { q.divide(divisor) as Quantity } static &lt;Q&gt; Quantity&lt;Q&gt; div(Quantity&lt;Q&gt; q, Number divisor) { q.divide(divisor) } static &lt;Q&gt; Quantity&lt;Q&gt; plus(Quantity&lt;Q&gt; q, Quantity&lt;Q&gt; divisor) { q.add(divisor) } static &lt;Q&gt; Quantity&lt;Q&gt; minus(Quantity&lt;Q&gt; q, Quantity&lt;Q&gt; divisor) { q.subtract(divisor) }}&lt;/pre&gt; Note that we have longer and shorter versions of many of the methods, e.g. kg and kilogram, m&nbsp;and meter. We didn&#39;t need a method for multiply since it is already using the name Groovy expects. Now we can write very short definitions to declare or compare times and lengths: def s = 1.sassert 1000.meters == 1.km &amp;&amp; 1.m == 100.cm We can also declare variables for acceleration due to gravity on Earth and Mars. Gravity is a lot less on Mars: var gₘ = 3.7.m/s/svar gₑ = 9.8.m/s/sassert gₑ.toString() == &#39;9.8 m/s&amp;sup2;&#39;assert gₑ &gt; gₘ We can also use the operator overloading in calculations (here showing that the Earth has a diameter that is between 1.8 and 2 times bigger than that of Mars): var diameterₑ = 12_742.kilometersassert diameterₘ + diameterₘ &gt; diameterₑassert diameterₑ - diameterₘ &lt; diameterₘassert diameterₘ * 1.8 &lt; diameterₑ Even though we have more compact expressions, the same data types are in play that we saw previously. They&#39;re just a little nicer to type. A dynamic DSL for controlling a Mars Rover Let&#39;s now look at how you could write a little Domain-Specific-Language (DSL) to control a Mars rover robot. First, we&#39;ll write a Direction enum as part of our robot domain model: enum Direction { left, right, forward, backward} There are many ways to write DSLs in Groovy. We&#39;ll use a little trick where the verbs are represented as keys in a map. Our DSL then looks like this: def move(Direction dir) { [by: { Quantity dist -&gt; [at: { Quantity speed -&gt; println &quot;robot moved $dir by $dist at $speed&quot; }] }]}&lt;/pre&gt; Here the implementation is just going to print out a message indicating all of the values it is processing. The real robot would send signals to the rover&#39;s robotic subsystems. Our script for controlling the rover now looks like this: move right by 2.m at 5.cm/s Which when run gives this output: robot moved right by 2 m at 5 cm/s As we saw earlier, this is backed by our JSR 385 types. We&#39;ll certainly get fail-early runtime errors if there are any calculations involving mismatched types. If we enable static typing, some additional errors will be detected at compile but because of the very dynamic style of our DSL implementation, not all runtime errors are reflected by typing information. If we want, we can change our DSL implementation to use richer types and that will support better static typing checking. We&#39;ll look at one way to do that next. A type-rich DSL for the Rover Now, instead of using our nested map style we saw previously, we create several richly-typed helper classes and define our move method in terms of those classes: class MoveHolder { Direction dir ByHolder by(Quantity dist) { new ByHolder(dist: dist, dir: dir) }}class ByHolder { Quantity dist Direction dir void at(Quantity speed) { println &quot;robot moved $dir by $dist at $speed&quot; }}static MoveHolder move(Direction dir) { new MoveHolder(dir: dir)}&lt;/pre&gt; While our DSL implementation has changed, the robot scripts remain the same: move right by 2.m at 5.cm/s Indeed, if we use Groovy dynamic nature, we can still run the same script and will notice no change. If however, we enable static checking and have a script with an error like this: move forward by 2.kgs We&#39;ll now see a compile-time error: [Static type checking] - Cannot call MoveHolder#by(javax.measure.Quantity&lt;javax.measure.quantity.Length&gt;) with arguments [javax.measure.Quantity&lt;javax.measure.quantity.Mass&gt;] It is great to get this additional earlier feedback on script errors, so you may wonder why we don&#39;t write our DSL implementations like this all of the time? Actually, both the dynamic and static flavors of our DSL can be useful at different times. When prototyping our script DSL, deciding on all the nouns and verbs that we should be using to control our robot, the dynamic flavored style can be much quicker to write especially during early iterations which might evolve and change rapidly. Once the DSL language has been locked down, we can invest in adding the richer types. In the rover scenario, it might also be the case that the rover itself has limited power and so may not want to perform additional type checking steps. We might run all scripts through a type checker back at mission control before sending them through to the rover where they may be enacted in dynamic mode. Adding custom type checking There is one additional language feature of Groovy we haven&#39;t mentioned. Groovy&#39;s type checking mechanism is extensible, so we&#39;ll have a look at using that feature here. The rover&#39;s speed is rather limited, &quot;In the case of exploring Mars, however, speed isn&#39;t the most relevant quality. It&#39;s about the journey and the destinations along the way. The slow pace is energy-efficient...&quot;. Let&#39;s look at limiting the speed to avoid unsafe or energy wasting movement. We could put early defensive checks in our DSL implementation to detect undesirable manoeuvres but we can also use type checking extensions for certain kinds of errors. Groovy in fact has its own DSL for writing such extensions. That&#39;s a topic for its own blog but here&#39;s what the code looks like: afterMethodCall { call -&gt; def method = getTargetMethod(call) if (method.name != &#39;at&#39;) return if (call.arguments.size() != 1) return def arg = call.arguments[0] if (arg !instanceof BinaryExpression) return def left = arg.leftExpression if (left !instanceof PropertyExpression) return def obj = left.objectExpression if (obj !instanceof ConstantExpression) return if (obj.value &gt; 5) { addStaticTypeError(&quot;Speed of $obj.value is too fast!&quot;,call) handled = true }} This is only a partial implementation, it&#39;s make numerous assumptions. We could remove those assumptions by adding more code but for now we&#39;ll keep this simplified version. So, now the following script (with the above type checking extension applied) compiles fine: move right by 2.m at 5.cm/s But this script fails: move right by 2.m at 6.cm/s The error message is: [Static type checking] - Speed of 6 is too fast! Further information JSR 385: Units of Measurement API 2.0 A Taste of Indriya Unit and Measurement in Swift Units of Measure in F# Types for units of measure How JSR 385 could have Saved the Mars Climate Orbiter - JFokus 2020&nbsp;(slide deck) Groovy in Action (in particular the DSL chapter) Units and Measures with JScience Unit of measurement libraries, their popularity and suitability Groovy Domain-Specific Languages techniques&nbsp;(slide deck) Domain-Specific Languages (Groovy documentation) Introduction to javax.measure https://github.com/paulk-asert/UomGroovy&nbsp;(repo) Conclusion We have looked at using the JSR 385 javax.measure API using Groovy and added some DSL examples to make using the API a little nicer." />
<meta property="og:description" content="The Mars Climate Orbiter was launched in 1998 as part of a multi-faceted Mars exploration program. It was lost due to a trajectory calculation error when nearing Mars. An investigation attributed the failure to a measurement mismatch between two software systems: metric units were used by NASA and US customary units were used by spacecraft builder Lockheed Martin. If the system in question had been developed using a units of measurement system, perhaps the failure could have been avoided. Units of measurement systems All programming languages have types for representing numbers. As an example, we may have three integers, one representing a height, one a weight and one a temperature. We can write code to add those three integers together, but the result may have no useful meaning. We could start writing our own class hierarchies for each integer type but it can quickly become cumbersome to use the resulting classes. Units of measurement systems attempt to provide a range of commonplace units, ways to construct quantities from those units and ways to manipulate them. Manipulation might involve performing numerical calculation or conversions. Goals of such systems include the ability to provide runtime and/or compile-time type safety. So, we should fail early when trying to perform the earlier mentioned addition of three unrelated quantities. Units of measurement systems aren&#39;t new. There are existing systems in F# and Swift and Java has had several versions (and earlier attempts) around standardising such a system including: JSR 275: Units Specification (rejected earlier attempt) JSR 363: Units of Measurement API JSR 385: Units of Measurement API 2.0 There are also existing Java libraries like JScience which have been developed, and shown early promise, but now don&#39;t seem to be actively maintained. While the jury is still out about whether units of measurement systems will spread further into mainstream programming, now seems like a great time to check the status. The JSR 385 maintenance release was approved last year and the latest version of the reference implementation was released earlier this year. JSR 385: Units of Measurement API 2.0 The first thing we need to do is bring in our dependencies (shown for Gradle - other options). The main one is the reference implementation (it brings in the javax.measure API transitively): implementation &#39;tech.units:indriya:2.1.3&#39; JSR 385 is extensible. We&#39;ll also bring in some units from the Unicode CLDR units, e.g. MILE: implementation &#39;systems.uom:systems-unicode:2.1&#39;implementation &#39;systems.uom:systems-quantity:2.1&#39; Let&#39;s follow on with the theme of visiting Mars. We can create variables for the mass and diameter of Mars as follows: var massₘ = Quantities.getQuantity(6.39E23, KILO(GRAM))var diameterₘ = Quantities.getQuantity(6_779, KILOMETER)println massₘprintln diameterₘ JSR 385 has metric prefix qualifiers like MICRO, MILLI, CENTI, KILO, MEGA, GIGA and many more. The CLDR units also define some commonly used units like KILOMETER. We could choose either here. When we run this script, it has the following output: 639000000000000000000000 kg 6779 km If we try to compare or add those two values, we&#39;ll see an error. Groovy has both static and dynamic natures. Using dynamic code like this: println massₘ &gt; diameterₘ We&#39;ll see a runtime error like this: javax.measure.IncommensurableException: km is not compatible with kg Or, with TypeChecked or CompileStatic in play for a statement like this: println massₘ.add(diameterₘ) We&#39;d see a compile-time error like this: [Static type checking] - Cannot call tech.units.indriya.ComparableQuantity#add(javax.measure.Quantity&lt;javax.measure.quantity.Mass&gt;) with arguments [tech.units.indriya.ComparableQuantity&lt;javax.measure.quantity.Length&gt;] If for some strange reason we did want to compare or perform calculations between incommensurable types, we can explicitly get the value: assert massₘ.value &gt; diameterₘ.value This escape hatch takes off a layer of type safety but requires explicit work to do so. It is normally never the case that you would want to do this. JSR 385 also supports ranges and conversions. We can look at the minimum and maximum temperatures on Mars: var minTemp = Quantities.getQuantity(-128, CELSIUS)var maxTemp = Quantities.getQuantity(70, FAHRENHEIT)println minTempprintln minTemp.to(FAHRENHEIT)println maxTempprintln maxTemp.to(CELSIUS)println QuantityRange.of(minTemp, maxTemp) It&#39;s quite a bit colder than Earth! When run, this script has the following output: -128 ℃ -198.400 ((K*5)/9)+459.67 70 ((K*5)/9)+459.67 21.1111111111111111111111111111111 ℃ min= -128 ℃, max= 70 ((K*5)/9)+459.67 In case you&#39;re wondering about the strange looking unit display for Fahrenheit temperatures, the definition of that unit that we are using, defines degrees Fahrenheit using a formula calculated from the temperature in degrees Kelvin. We&#39;d see the same thing if using the MILE unit: println diameterₘ.to(MILE) Which shows us that the diameter of Mars is a little over 4200 miles: 4212.275312176886980036586335798934 (m*1609344)/1000 Adding some metaprogramming Groovy has various features which allow methods to be (apparently) added to classes. We&#39;ll use extension methods. This technique involves writing static methods in a helper class using certain conventions. The first parameter in all such methods is the target of the extension. Groovy code referencing instances of the target class have code that can call such a method as if it existed on the target class. In reality, the Groovy compiler or runtime funnels the call through the helper class. For us, it means we will have methods like getMeters() on the&nbsp;Number&nbsp;class which using Groovy&#39;s shorthand&#39;s for property notation allows for very compact quantity definitions like 5.meters. We&#39;ll also add some methods to allow Groovy&#39;s normal operator overloading syntax to apply: class UomExtensions { static Quantity getCentimeters(Number num) { Quantities.getQuantity(num, CENTI(METRE)) } static Quantity getMeters(Number num) { Quantities.getQuantity(num, METRE) } static Quantity getKilometers(Number num) { Quantities.getQuantity(num, KILO(METRE)) } static Quantity getCm(Number num) { getCentimeters(num) } static Quantity getM(Number num) { getMeters(num) } static Quantity getKm(Number num) { getKilometers(num) } static Quantity getKilograms(Number num) { Quantities.getQuantity(num, KILO(GRAM)) } static Quantity getKgs(Number num) { getKilograms(num) } static Quantity getHours(Number num) { Quantities.getQuantity(num, HOUR) } static Quantity getSeconds(Number num) { Quantities.getQuantity(num, SECOND) } static Quantity getHr(Number num) { getHours(num) } static Quantity getS(Number num) { getSeconds(num) } static Quantity div(Quantity q, Quantity divisor) { q.divide(divisor) as Quantity } static &lt;Q&gt; Quantity&lt;Q&gt; div(Quantity&lt;Q&gt; q, Number divisor) { q.divide(divisor) } static &lt;Q&gt; Quantity&lt;Q&gt; plus(Quantity&lt;Q&gt; q, Quantity&lt;Q&gt; divisor) { q.add(divisor) } static &lt;Q&gt; Quantity&lt;Q&gt; minus(Quantity&lt;Q&gt; q, Quantity&lt;Q&gt; divisor) { q.subtract(divisor) }}&lt;/pre&gt; Note that we have longer and shorter versions of many of the methods, e.g. kg and kilogram, m&nbsp;and meter. We didn&#39;t need a method for multiply since it is already using the name Groovy expects. Now we can write very short definitions to declare or compare times and lengths: def s = 1.sassert 1000.meters == 1.km &amp;&amp; 1.m == 100.cm We can also declare variables for acceleration due to gravity on Earth and Mars. Gravity is a lot less on Mars: var gₘ = 3.7.m/s/svar gₑ = 9.8.m/s/sassert gₑ.toString() == &#39;9.8 m/s&amp;sup2;&#39;assert gₑ &gt; gₘ We can also use the operator overloading in calculations (here showing that the Earth has a diameter that is between 1.8 and 2 times bigger than that of Mars): var diameterₑ = 12_742.kilometersassert diameterₘ + diameterₘ &gt; diameterₑassert diameterₑ - diameterₘ &lt; diameterₘassert diameterₘ * 1.8 &lt; diameterₑ Even though we have more compact expressions, the same data types are in play that we saw previously. They&#39;re just a little nicer to type. A dynamic DSL for controlling a Mars Rover Let&#39;s now look at how you could write a little Domain-Specific-Language (DSL) to control a Mars rover robot. First, we&#39;ll write a Direction enum as part of our robot domain model: enum Direction { left, right, forward, backward} There are many ways to write DSLs in Groovy. We&#39;ll use a little trick where the verbs are represented as keys in a map. Our DSL then looks like this: def move(Direction dir) { [by: { Quantity dist -&gt; [at: { Quantity speed -&gt; println &quot;robot moved $dir by $dist at $speed&quot; }] }]}&lt;/pre&gt; Here the implementation is just going to print out a message indicating all of the values it is processing. The real robot would send signals to the rover&#39;s robotic subsystems. Our script for controlling the rover now looks like this: move right by 2.m at 5.cm/s Which when run gives this output: robot moved right by 2 m at 5 cm/s As we saw earlier, this is backed by our JSR 385 types. We&#39;ll certainly get fail-early runtime errors if there are any calculations involving mismatched types. If we enable static typing, some additional errors will be detected at compile but because of the very dynamic style of our DSL implementation, not all runtime errors are reflected by typing information. If we want, we can change our DSL implementation to use richer types and that will support better static typing checking. We&#39;ll look at one way to do that next. A type-rich DSL for the Rover Now, instead of using our nested map style we saw previously, we create several richly-typed helper classes and define our move method in terms of those classes: class MoveHolder { Direction dir ByHolder by(Quantity dist) { new ByHolder(dist: dist, dir: dir) }}class ByHolder { Quantity dist Direction dir void at(Quantity speed) { println &quot;robot moved $dir by $dist at $speed&quot; }}static MoveHolder move(Direction dir) { new MoveHolder(dir: dir)}&lt;/pre&gt; While our DSL implementation has changed, the robot scripts remain the same: move right by 2.m at 5.cm/s Indeed, if we use Groovy dynamic nature, we can still run the same script and will notice no change. If however, we enable static checking and have a script with an error like this: move forward by 2.kgs We&#39;ll now see a compile-time error: [Static type checking] - Cannot call MoveHolder#by(javax.measure.Quantity&lt;javax.measure.quantity.Length&gt;) with arguments [javax.measure.Quantity&lt;javax.measure.quantity.Mass&gt;] It is great to get this additional earlier feedback on script errors, so you may wonder why we don&#39;t write our DSL implementations like this all of the time? Actually, both the dynamic and static flavors of our DSL can be useful at different times. When prototyping our script DSL, deciding on all the nouns and verbs that we should be using to control our robot, the dynamic flavored style can be much quicker to write especially during early iterations which might evolve and change rapidly. Once the DSL language has been locked down, we can invest in adding the richer types. In the rover scenario, it might also be the case that the rover itself has limited power and so may not want to perform additional type checking steps. We might run all scripts through a type checker back at mission control before sending them through to the rover where they may be enacted in dynamic mode. Adding custom type checking There is one additional language feature of Groovy we haven&#39;t mentioned. Groovy&#39;s type checking mechanism is extensible, so we&#39;ll have a look at using that feature here. The rover&#39;s speed is rather limited, &quot;In the case of exploring Mars, however, speed isn&#39;t the most relevant quality. It&#39;s about the journey and the destinations along the way. The slow pace is energy-efficient...&quot;. Let&#39;s look at limiting the speed to avoid unsafe or energy wasting movement. We could put early defensive checks in our DSL implementation to detect undesirable manoeuvres but we can also use type checking extensions for certain kinds of errors. Groovy in fact has its own DSL for writing such extensions. That&#39;s a topic for its own blog but here&#39;s what the code looks like: afterMethodCall { call -&gt; def method = getTargetMethod(call) if (method.name != &#39;at&#39;) return if (call.arguments.size() != 1) return def arg = call.arguments[0] if (arg !instanceof BinaryExpression) return def left = arg.leftExpression if (left !instanceof PropertyExpression) return def obj = left.objectExpression if (obj !instanceof ConstantExpression) return if (obj.value &gt; 5) { addStaticTypeError(&quot;Speed of $obj.value is too fast!&quot;,call) handled = true }} This is only a partial implementation, it&#39;s make numerous assumptions. We could remove those assumptions by adding more code but for now we&#39;ll keep this simplified version. So, now the following script (with the above type checking extension applied) compiles fine: move right by 2.m at 5.cm/s But this script fails: move right by 2.m at 6.cm/s The error message is: [Static type checking] - Speed of 6 is too fast! Further information JSR 385: Units of Measurement API 2.0 A Taste of Indriya Unit and Measurement in Swift Units of Measure in F# Types for units of measure How JSR 385 could have Saved the Mars Climate Orbiter - JFokus 2020&nbsp;(slide deck) Groovy in Action (in particular the DSL chapter) Units and Measures with JScience Unit of measurement libraries, their popularity and suitability Groovy Domain-Specific Languages techniques&nbsp;(slide deck) Domain-Specific Languages (Groovy documentation) Introduction to javax.measure https://github.com/paulk-asert/UomGroovy&nbsp;(repo) Conclusion We have looked at using the JSR 385 javax.measure API using Groovy and added some DSL examples to make using the API a little nicer." />
<link rel="canonical" href="http://localhost:4000/groovy/entry/life-on-mars-units-of" />
<meta property="og:url" content="http://localhost:4000/groovy/entry/life-on-mars-units-of" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-08-13T06:31:47-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Life on Mars: Units of Measurement systems, Groovy, and domain specific languages (DSLs)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-08-13T06:31:47-04:00","datePublished":"2022-08-13T06:31:47-04:00","description":"The Mars Climate Orbiter was launched in 1998 as part of a multi-faceted Mars exploration program. It was lost due to a trajectory calculation error when nearing Mars. An investigation attributed the failure to a measurement mismatch between two software systems: metric units were used by NASA and US customary units were used by spacecraft builder Lockheed Martin. If the system in question had been developed using a units of measurement system, perhaps the failure could have been avoided. Units of measurement systems All programming languages have types for representing numbers. As an example, we may have three integers, one representing a height, one a weight and one a temperature. We can write code to add those three integers together, but the result may have no useful meaning. We could start writing our own class hierarchies for each integer type but it can quickly become cumbersome to use the resulting classes. Units of measurement systems attempt to provide a range of commonplace units, ways to construct quantities from those units and ways to manipulate them. Manipulation might involve performing numerical calculation or conversions. Goals of such systems include the ability to provide runtime and/or compile-time type safety. So, we should fail early when trying to perform the earlier mentioned addition of three unrelated quantities. Units of measurement systems aren&#39;t new. There are existing systems in F# and Swift and Java has had several versions (and earlier attempts) around standardising such a system including: JSR 275: Units Specification (rejected earlier attempt) JSR 363: Units of Measurement API JSR 385: Units of Measurement API 2.0 There are also existing Java libraries like JScience which have been developed, and shown early promise, but now don&#39;t seem to be actively maintained. While the jury is still out about whether units of measurement systems will spread further into mainstream programming, now seems like a great time to check the status. The JSR 385 maintenance release was approved last year and the latest version of the reference implementation was released earlier this year. JSR 385: Units of Measurement API 2.0 The first thing we need to do is bring in our dependencies (shown for Gradle - other options). The main one is the reference implementation (it brings in the javax.measure API transitively): implementation &#39;tech.units:indriya:2.1.3&#39; JSR 385 is extensible. We&#39;ll also bring in some units from the Unicode CLDR units, e.g. MILE: implementation &#39;systems.uom:systems-unicode:2.1&#39;implementation &#39;systems.uom:systems-quantity:2.1&#39; Let&#39;s follow on with the theme of visiting Mars. We can create variables for the mass and diameter of Mars as follows: var massₘ = Quantities.getQuantity(6.39E23, KILO(GRAM))var diameterₘ = Quantities.getQuantity(6_779, KILOMETER)println massₘprintln diameterₘ JSR 385 has metric prefix qualifiers like MICRO, MILLI, CENTI, KILO, MEGA, GIGA and many more. The CLDR units also define some commonly used units like KILOMETER. We could choose either here. When we run this script, it has the following output: 639000000000000000000000 kg 6779 km If we try to compare or add those two values, we&#39;ll see an error. Groovy has both static and dynamic natures. Using dynamic code like this: println massₘ &gt; diameterₘ We&#39;ll see a runtime error like this: javax.measure.IncommensurableException: km is not compatible with kg Or, with TypeChecked or CompileStatic in play for a statement like this: println massₘ.add(diameterₘ) We&#39;d see a compile-time error like this: [Static type checking] - Cannot call tech.units.indriya.ComparableQuantity#add(javax.measure.Quantity&lt;javax.measure.quantity.Mass&gt;) with arguments [tech.units.indriya.ComparableQuantity&lt;javax.measure.quantity.Length&gt;] If for some strange reason we did want to compare or perform calculations between incommensurable types, we can explicitly get the value: assert massₘ.value &gt; diameterₘ.value This escape hatch takes off a layer of type safety but requires explicit work to do so. It is normally never the case that you would want to do this. JSR 385 also supports ranges and conversions. We can look at the minimum and maximum temperatures on Mars: var minTemp = Quantities.getQuantity(-128, CELSIUS)var maxTemp = Quantities.getQuantity(70, FAHRENHEIT)println minTempprintln minTemp.to(FAHRENHEIT)println maxTempprintln maxTemp.to(CELSIUS)println QuantityRange.of(minTemp, maxTemp) It&#39;s quite a bit colder than Earth! When run, this script has the following output: -128 ℃ -198.400 ((K*5)/9)+459.67 70 ((K*5)/9)+459.67 21.1111111111111111111111111111111 ℃ min= -128 ℃, max= 70 ((K*5)/9)+459.67 In case you&#39;re wondering about the strange looking unit display for Fahrenheit temperatures, the definition of that unit that we are using, defines degrees Fahrenheit using a formula calculated from the temperature in degrees Kelvin. We&#39;d see the same thing if using the MILE unit: println diameterₘ.to(MILE) Which shows us that the diameter of Mars is a little over 4200 miles: 4212.275312176886980036586335798934 (m*1609344)/1000 Adding some metaprogramming Groovy has various features which allow methods to be (apparently) added to classes. We&#39;ll use extension methods. This technique involves writing static methods in a helper class using certain conventions. The first parameter in all such methods is the target of the extension. Groovy code referencing instances of the target class have code that can call such a method as if it existed on the target class. In reality, the Groovy compiler or runtime funnels the call through the helper class. For us, it means we will have methods like getMeters() on the&nbsp;Number&nbsp;class which using Groovy&#39;s shorthand&#39;s for property notation allows for very compact quantity definitions like 5.meters. We&#39;ll also add some methods to allow Groovy&#39;s normal operator overloading syntax to apply: class UomExtensions { static Quantity getCentimeters(Number num) { Quantities.getQuantity(num, CENTI(METRE)) } static Quantity getMeters(Number num) { Quantities.getQuantity(num, METRE) } static Quantity getKilometers(Number num) { Quantities.getQuantity(num, KILO(METRE)) } static Quantity getCm(Number num) { getCentimeters(num) } static Quantity getM(Number num) { getMeters(num) } static Quantity getKm(Number num) { getKilometers(num) } static Quantity getKilograms(Number num) { Quantities.getQuantity(num, KILO(GRAM)) } static Quantity getKgs(Number num) { getKilograms(num) } static Quantity getHours(Number num) { Quantities.getQuantity(num, HOUR) } static Quantity getSeconds(Number num) { Quantities.getQuantity(num, SECOND) } static Quantity getHr(Number num) { getHours(num) } static Quantity getS(Number num) { getSeconds(num) } static Quantity div(Quantity q, Quantity divisor) { q.divide(divisor) as Quantity } static &lt;Q&gt; Quantity&lt;Q&gt; div(Quantity&lt;Q&gt; q, Number divisor) { q.divide(divisor) } static &lt;Q&gt; Quantity&lt;Q&gt; plus(Quantity&lt;Q&gt; q, Quantity&lt;Q&gt; divisor) { q.add(divisor) } static &lt;Q&gt; Quantity&lt;Q&gt; minus(Quantity&lt;Q&gt; q, Quantity&lt;Q&gt; divisor) { q.subtract(divisor) }}&lt;/pre&gt; Note that we have longer and shorter versions of many of the methods, e.g. kg and kilogram, m&nbsp;and meter. We didn&#39;t need a method for multiply since it is already using the name Groovy expects. Now we can write very short definitions to declare or compare times and lengths: def s = 1.sassert 1000.meters == 1.km &amp;&amp; 1.m == 100.cm We can also declare variables for acceleration due to gravity on Earth and Mars. Gravity is a lot less on Mars: var gₘ = 3.7.m/s/svar gₑ = 9.8.m/s/sassert gₑ.toString() == &#39;9.8 m/s&amp;sup2;&#39;assert gₑ &gt; gₘ We can also use the operator overloading in calculations (here showing that the Earth has a diameter that is between 1.8 and 2 times bigger than that of Mars): var diameterₑ = 12_742.kilometersassert diameterₘ + diameterₘ &gt; diameterₑassert diameterₑ - diameterₘ &lt; diameterₘassert diameterₘ * 1.8 &lt; diameterₑ Even though we have more compact expressions, the same data types are in play that we saw previously. They&#39;re just a little nicer to type. A dynamic DSL for controlling a Mars Rover Let&#39;s now look at how you could write a little Domain-Specific-Language (DSL) to control a Mars rover robot. First, we&#39;ll write a Direction enum as part of our robot domain model: enum Direction { left, right, forward, backward} There are many ways to write DSLs in Groovy. We&#39;ll use a little trick where the verbs are represented as keys in a map. Our DSL then looks like this: def move(Direction dir) { [by: { Quantity dist -&gt; [at: { Quantity speed -&gt; println &quot;robot moved $dir by $dist at $speed&quot; }] }]}&lt;/pre&gt; Here the implementation is just going to print out a message indicating all of the values it is processing. The real robot would send signals to the rover&#39;s robotic subsystems. Our script for controlling the rover now looks like this: move right by 2.m at 5.cm/s Which when run gives this output: robot moved right by 2 m at 5 cm/s As we saw earlier, this is backed by our JSR 385 types. We&#39;ll certainly get fail-early runtime errors if there are any calculations involving mismatched types. If we enable static typing, some additional errors will be detected at compile but because of the very dynamic style of our DSL implementation, not all runtime errors are reflected by typing information. If we want, we can change our DSL implementation to use richer types and that will support better static typing checking. We&#39;ll look at one way to do that next. A type-rich DSL for the Rover Now, instead of using our nested map style we saw previously, we create several richly-typed helper classes and define our move method in terms of those classes: class MoveHolder { Direction dir ByHolder by(Quantity dist) { new ByHolder(dist: dist, dir: dir) }}class ByHolder { Quantity dist Direction dir void at(Quantity speed) { println &quot;robot moved $dir by $dist at $speed&quot; }}static MoveHolder move(Direction dir) { new MoveHolder(dir: dir)}&lt;/pre&gt; While our DSL implementation has changed, the robot scripts remain the same: move right by 2.m at 5.cm/s Indeed, if we use Groovy dynamic nature, we can still run the same script and will notice no change. If however, we enable static checking and have a script with an error like this: move forward by 2.kgs We&#39;ll now see a compile-time error: [Static type checking] - Cannot call MoveHolder#by(javax.measure.Quantity&lt;javax.measure.quantity.Length&gt;) with arguments [javax.measure.Quantity&lt;javax.measure.quantity.Mass&gt;] It is great to get this additional earlier feedback on script errors, so you may wonder why we don&#39;t write our DSL implementations like this all of the time? Actually, both the dynamic and static flavors of our DSL can be useful at different times. When prototyping our script DSL, deciding on all the nouns and verbs that we should be using to control our robot, the dynamic flavored style can be much quicker to write especially during early iterations which might evolve and change rapidly. Once the DSL language has been locked down, we can invest in adding the richer types. In the rover scenario, it might also be the case that the rover itself has limited power and so may not want to perform additional type checking steps. We might run all scripts through a type checker back at mission control before sending them through to the rover where they may be enacted in dynamic mode. Adding custom type checking There is one additional language feature of Groovy we haven&#39;t mentioned. Groovy&#39;s type checking mechanism is extensible, so we&#39;ll have a look at using that feature here. The rover&#39;s speed is rather limited, &quot;In the case of exploring Mars, however, speed isn&#39;t the most relevant quality. It&#39;s about the journey and the destinations along the way. The slow pace is energy-efficient...&quot;. Let&#39;s look at limiting the speed to avoid unsafe or energy wasting movement. We could put early defensive checks in our DSL implementation to detect undesirable manoeuvres but we can also use type checking extensions for certain kinds of errors. Groovy in fact has its own DSL for writing such extensions. That&#39;s a topic for its own blog but here&#39;s what the code looks like: afterMethodCall { call -&gt; def method = getTargetMethod(call) if (method.name != &#39;at&#39;) return if (call.arguments.size() != 1) return def arg = call.arguments[0] if (arg !instanceof BinaryExpression) return def left = arg.leftExpression if (left !instanceof PropertyExpression) return def obj = left.objectExpression if (obj !instanceof ConstantExpression) return if (obj.value &gt; 5) { addStaticTypeError(&quot;Speed of $obj.value is too fast!&quot;,call) handled = true }} This is only a partial implementation, it&#39;s make numerous assumptions. We could remove those assumptions by adding more code but for now we&#39;ll keep this simplified version. So, now the following script (with the above type checking extension applied) compiles fine: move right by 2.m at 5.cm/s But this script fails: move right by 2.m at 6.cm/s The error message is: [Static type checking] - Speed of 6 is too fast! Further information JSR 385: Units of Measurement API 2.0 A Taste of Indriya Unit and Measurement in Swift Units of Measure in F# Types for units of measure How JSR 385 could have Saved the Mars Climate Orbiter - JFokus 2020&nbsp;(slide deck) Groovy in Action (in particular the DSL chapter) Units and Measures with JScience Unit of measurement libraries, their popularity and suitability Groovy Domain-Specific Languages techniques&nbsp;(slide deck) Domain-Specific Languages (Groovy documentation) Introduction to javax.measure https://github.com/paulk-asert/UomGroovy&nbsp;(repo) Conclusion We have looked at using the JSR 385 javax.measure API using Groovy and added some DSL examples to make using the API a little nicer.","headline":"Life on Mars: Units of Measurement systems, Groovy, and domain specific languages (DSLs)","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/groovy/entry/life-on-mars-units-of"},"url":"http://localhost:4000/groovy/entry/life-on-mars-units-of"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Life on Mars: Units of Measurement systems, Groovy, and domain specific languages (DSLs)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-08-13T06:31:47-04:00" itemprop="datePublished">Aug 13, 2022
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Paul King", "login"=>"paulk", "email"=>"paulk@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><img src="https://avatars.githubusercontent.com/u/6383598?s=200&amp;v=4" align="right">The Mars Climate Orbiter was launched in 1998 as part of a multi-faceted Mars exploration program. It was lost due to a trajectory calculation error when nearing Mars. An <a href="http://scholar.google.com/scholar?hl=en&amp;q=Stephenson+A%2C+LaPiana+L%2C+Mulville+D%2C+et+al.+Mars+climate+orbiter+mishap+investigation+board+phase+1+report%3B+1999.+https%3A%2F%2Fllis.nasa.gov.+Accessed+October+14%2C+2020." target="_blank">investigation</a> attributed the failure to a measurement mismatch between two software systems: metric units were used by NASA and <a href="https://en.wikipedia.org/wiki/United_States_customary_units" target="_blank">US customary</a> units were used by spacecraft builder Lockheed Martin.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/19/Mars_Climate_Orbiter_2.jpg/1280px-Mars_Climate_Orbiter_2.jpg" alt="Mars Climate Orbiter - image credit: wikipedia" style="width:50%"></p>
<p>If the system in question had been developed using a units of measurement system, perhaps the failure could have been avoided.</p>
<h3>Units of measurement systems</h3>
<p>All programming languages have types for representing numbers. As an example, we may have three integers, one representing a height, one a weight and one a temperature. We can write code to add those three integers together, but the result may have no useful meaning. We could start writing our own class hierarchies for each integer type but it can quickly become cumbersome to use the resulting classes. Units of measurement systems attempt to provide a range of commonplace units, ways to construct quantities from those units and ways to manipulate them. Manipulation might involve performing numerical calculation or conversions. Goals of such systems include the ability to provide runtime and/or compile-time type safety. So, we should fail early when trying to perform the earlier mentioned addition of three unrelated quantities.</p>
<p>Units of measurement systems aren't new. There are existing systems in F# and Swift and Java has had several versions (and earlier attempts) around standardising such a system including:</p>
<ul>
<li><a href="https://jcp.org/en/jsr/detail?id=275" target="_blank">JSR 275</a>: Units Specification (rejected earlier attempt)<br></li>
<li><a href="https://jcp.org/en/jsr/detail?id=363" target="_blank">JSR 363</a>: Units of Measurement API</li>
<li><a href="https://jcp.org/en/jsr/detail?id=385" target="_blank">JSR 385</a>: Units of Measurement API 2.0<br></li>
</ul>
<p>There are also existing Java libraries like <a href="http://jscience.org/" target="_blank">JScience</a> which have been developed, and <a href="https://objectcomputing.com/resources/publications/sett/june-2006-units-and-measures-with-jscience" target="_blank">shown early promise</a>, but now don't seem to be actively maintained. While the <a href="https://onlinelibrary.wiley.com/doi/10.1002/spe.2926" target="_blank">jury is still out</a> about whether units of measurement systems will spread further into mainstream programming, now seems like a great time to check the status. The JSR 385 maintenance release was approved last year and the latest version of the reference implementation was released earlier this year.</p>
<h3>JSR 385: Units of Measurement API 2.0</h3>
<p>The first thing we need to do is bring in our dependencies (shown for <a href="https://gradle.org/" target="_blank">Gradle</a> - <a href="https://mvnrepository.com/artifact/tech.units/indriya/2.1.3" target="_blank">other options</a>). The main one is the reference implementation (it brings in the <code>javax.measure</code> API transitively):</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">implementation <span style="color:#6a8759;">'tech.units:indriya:2.1.3'<br></span></pre>
<p>JSR 385 is extensible. We'll also bring in some units from the <a href="https://cldr.unicode.org/translation/units" target="_blank">Unicode CLDR</a> units, e.g. <code>MILE</code>:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">implementation <span style="color:#6a8759;">'systems.uom:systems-unicode:2.1'<br></span>implementation <span style="color:#6a8759;">'systems.uom:systems-quantity:2.1'<br></span></pre>
<p>Let's follow on with the theme of visiting Mars. We can create variables for the mass and diameter of Mars as follows:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>mass<span style="font-family:'Courier New',monospace;">ₘ </span>= Quantities.<span style="color:#9876aa;font-style:italic;">getQuantity</span>(<span style="color:#6897bb;">6.39E23</span>, <span style="color:#9876aa;font-style:italic;">KILO</span>(<span style="color:#9876aa;font-style:italic;">GRAM</span>))<br><span style="color:#cc7832;">var </span>diameter<span style="font-family:'Courier New',monospace;">ₘ </span>= Quantities.<span style="color:#9876aa;font-style:italic;">getQuantity</span>(<span style="color:#6897bb;">6_779</span>, <span style="color:#9876aa;font-style:italic;">KILOMETER</span>)<br>println mass<span style="font-family:'Courier New',monospace;">ₘ<br></span>println diameter<span style="font-family:'Courier New',monospace;">ₘ</span></pre>
<p>JSR 385 has metric prefix qualifiers like <code>MICRO</code>, <code>MILLI</code>, <code>CENTI</code>, <code>KILO</code>, <code>MEGA</code>, <code>GIGA</code> and many more. The CLDR units also define some commonly used units like <code>KILOMETER</code>. We could choose either here.</p>
<p>When we run this script, it has the following output:</p>
<pre>639000000000000000000000 kg
6779 km
</pre>
<p>If we try to compare or add those two values, we'll see an error. Groovy has both static and dynamic natures. Using dynamic code like this:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">println mass<span style="font-family:'Courier New',monospace;">ₘ </span>> diameter<span style="font-family:'Courier New',monospace;">ₘ<br></span></pre>
<p>We'll see a runtime error like this:</p>
<pre><span style="color:#D03030;">javax.measure.IncommensurableException: km is not compatible with kg</span></pre>
<p>Or, with <code>TypeChecked</code> or <code>CompileStatic</code> in play for a statement like this:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">println mass<span style="font-family:'Courier New',monospace;">ₘ</span>.add(diameter<span style="font-family:'Courier New',monospace;">ₘ</span>)</pre>
<p>We'd see a compile-time error like this:</p>
<pre><span style="color:#d03030">[Static type checking] - Cannot call tech.units.indriya.ComparableQuantity#add(javax.measure.Quantity<javax.measure.quantity.<b>Mass</b>>)
with arguments [tech.units.indriya.ComparableQuantity<javax.measure.quantity.<b>Length</b>>]</span></pre>
<p>If for some strange reason we did want to compare or perform calculations between incommensurable types, we can explicitly get the value:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">assert </span>mass<span style="font-family:'Courier New',monospace;">ₘ</span>.<span style="color:#9876aa;">value </span>> diameter<span style="font-family:'Courier New',monospace;">ₘ</span>.<span style="color:#9876aa;">value<br></span></pre>
<p>This escape hatch takes off a layer of type safety but requires explicit work to do so. It is normally never the case that you would want to do this.</p>
<p>JSR 385 also supports ranges and conversions. We can look at the minimum and maximum temperatures on Mars:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>minTemp = Quantities.<span style="color:#9876aa;font-style:italic;">getQuantity</span>(-<span style="color:#6897bb;">128</span>, <span style="color:#9876aa;font-style:italic;">CELSIUS</span>)<br><span style="color:#cc7832;">var </span>maxTemp = Quantities.<span style="color:#9876aa;font-style:italic;">getQuantity</span>(<span style="color:#6897bb;">70</span>, <span style="color:#9876aa;font-style:italic;">FAHRENHEIT</span>)<br>println minTemp<br>println minTemp.to(<span style="color:#9876aa;font-style:italic;">FAHRENHEIT</span>)<br>println maxTemp<br>println maxTemp.to(<span style="color:#9876aa;font-style:italic;">CELSIUS</span>)<br>println QuantityRange.<span style="color:#9876aa;font-style:italic;">of</span>(minTemp, maxTemp)<br></pre>
<p>It's quite a bit colder than Earth! When run, this script has the following output:</p>
<pre>-128 ℃
-198.400 ((K*5)/9)+459.67
70 ((K*5)/9)+459.67
21.1111111111111111111111111111111 ℃
min= -128 ℃, max= 70 ((K*5)/9)+459.67</pre>
<p>In case you're wondering about the strange looking unit display for Fahrenheit temperatures, the definition of that unit that we are using, defines degrees Fahrenheit using a formula calculated from the temperature in degrees Kelvin.</p>
<p>We'd see the same thing if using the <code>MILE</code> unit:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">println diameter<span style="font-family:'Courier New',monospace;">ₘ</span>.to(<span style="color:#9876aa;font-style:italic;">MILE</span>)<br></pre>
<p>Which shows us that the diameter of Mars is a little over 4200 miles:</p>
<pre>4212.275312176886980036586335798934 (m*1609344)/1000</pre>
<h3>Adding some metaprogramming</h3>
<p>Groovy has various features which allow methods to be (apparently) added to classes. We'll use extension methods. This technique involves writing static methods in a helper class using certain conventions. The first parameter in all such methods is the target of the extension. Groovy code referencing instances of the target class have code that can call such a method as if it existed on the target class. In reality, the Groovy compiler or runtime funnels the call through the helper class. For us, it means we will have methods like <code>getMeters()</code> on the&nbsp;<code>Number</code>&nbsp;class which using Groovy's shorthand's for property notation allows for very compact quantity definitions like <code>5.meters</code>. We'll also add some methods to allow Groovy's normal operator overloading syntax to apply:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">class </span>UomExtensions {<br>    <span style="color:#cc7832;">static </span>Quantity<Length> getCentimeters(Number num) { Quantities.<span style="color:#9876aa;font-style:italic;">getQuantity</span>(num, <span style="color:#9876aa;font-style:italic;">CENTI</span>(<span style="color:#9876aa;font-style:italic;">METRE</span>)) }<br><br>    <span style="color:#cc7832;">static </span>Quantity<Length> getMeters(Number num) { Quantities.<span style="color:#9876aa;font-style:italic;">getQuantity</span>(num, <span style="color:#9876aa;font-style:italic;">METRE</span>) }<br><br>    <span style="color:#cc7832;">static </span>Quantity<Length> getKilometers(Number num) { Quantities.<span style="color:#9876aa;font-style:italic;">getQuantity</span>(num, <span style="color:#9876aa;font-style:italic;">KILO</span>(<span style="color:#9876aa;font-style:italic;">METRE</span>)) }<br><br>    <span style="color:#cc7832;">static </span>Quantity<Length> getCm(Number num) { <span style="color:#9876aa;font-style:italic;">getCentimeters</span>(num) }<br><br>    <span style="color:#cc7832;">static </span>Quantity<Length> getM(Number num) { <span style="color:#9876aa;font-style:italic;">getMeters</span>(num) }<br><br>    <span style="color:#cc7832;">static </span>Quantity<Length> getKm(Number num) { <span style="color:#9876aa;font-style:italic;">getKilometers</span>(num) }<br><br>    <span style="color:#cc7832;">static </span>Quantity<Mass> getKilograms(Number num) { Quantities.<span style="color:#9876aa;font-style:italic;">getQuantity</span>(num, <span style="color:#9876aa;font-style:italic;">KILO</span>(<span style="color:#9876aa;font-style:italic;">GRAM</span>)) }<br><br>    <span style="color:#cc7832;">static </span>Quantity<Mass> getKgs(Number num) { <span style="color:#9876aa;font-style:italic;">getKilograms</span>(num) }<br><br>    <span style="color:#cc7832;">static </span>Quantity<Time> getHours(Number num) { Quantities.<span style="color:#9876aa;font-style:italic;">getQuantity</span>(num, <span style="color:#9876aa;font-style:italic;">HOUR</span>) }<br><br>    <span style="color:#cc7832;">static </span>Quantity<Time> getSeconds(Number num) { Quantities.<span style="color:#9876aa;font-style:italic;">getQuantity</span>(num, <span style="color:#9876aa;font-style:italic;">SECOND</span>) }<br><br>    <span style="color:#cc7832;">static </span>Quantity<Time> getHr(Number num) { <span style="color:#9876aa;font-style:italic;">getHours</span>(num) }<br><br>    <span style="color:#cc7832;">static </span>Quantity<Time> getS(Number num) { <span style="color:#9876aa;font-style:italic;">getSeconds</span>(num) }<br><br>    <span style="color:#cc7832;">static </span>Quantity<Speed> div(Quantity<Length> q, Quantity<Time> divisor) { q.divide(divisor) <span style="color:#cc7832;">as </span>Quantity<Speed> }<br><br>    <span style="color:#cc7832;">static </span><<span style="color:#507874;">Q</span>> Quantity<<span style="color:#507874;">Q</span>> div(Quantity<<span style="color:#507874;">Q</span>> q, Number divisor) { q.divide(divisor) }<br><br>    <span style="color:#cc7832;">static </span><<span style="color:#507874;">Q</span>> Quantity<<span style="color:#507874;">Q</span>> plus(Quantity<<span style="color:#507874;">Q</span>> q, Quantity<<span style="color:#507874;">Q</span>> divisor) { q.add(divisor) }<br><br>    <span style="color:#cc7832;">static </span><<span style="color:#507874;">Q</span>> Quantity<<span style="color:#507874;">Q</span>> minus(Quantity<<span style="color:#507874;">Q</span>> q, Quantity<<span style="color:#507874;">Q</span>> divisor) { q.subtract(divisor) }<br>}</pre>
<p>Note that we have longer and shorter versions of many of the methods, e.g. <code>kg</code> and <code>kilogram</code>, <code>m</code>&nbsp;and <code>meter</code>. We didn't need a method for <code>multiply</code> since it is already using the name Groovy expects.<br></p>
<p>Now we can write very short definitions to declare or compare times and lengths:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>s = <span style="color:#6897bb;">1</span>.<span style="color:#9876aa;">s<br></span><span style="color:#cc7832;">assert </span><span style="color:#6897bb;">1000</span>.<span style="color:#9876aa;">meters </span>== <span style="color:#6897bb;">1</span>.<span style="color:#9876aa;">km </span>&amp;&amp; <span style="color:#6897bb;">1</span>.<span style="color:#9876aa;">m </span>== <span style="color:#6897bb;">100</span>.<span style="color:#9876aa;">cm</span></pre>
<p>We can also declare variables for acceleration due to gravity on Earth and Mars. Gravity is a lot less on Mars:<br></p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>g<span style="font-family:'Courier New',monospace;">ₘ </span>= <span style="color:#6897bb;">3.7</span>.<span style="color:#9876aa;">m</span>/s/s<br><span style="color:#cc7832;">var </span>g<span style="font-family:'Courier New',monospace;">ₑ </span>= <span style="color:#6897bb;">9.8</span>.<span style="color:#9876aa;">m</span>/s/s<br><span style="color:#cc7832;">assert </span>g<span style="font-family:'Courier New',monospace;">ₑ</span>.toString() == <span style="color:#6a8759;">'9.8 m/s&sup2;'<br></span><span style="color:#cc7832;">assert </span>g<span style="font-family:'Courier New',monospace;">ₑ </span>> g<span style="font-family:'Courier New',monospace;">ₘ</span></pre>
<p>We can also use the operator overloading in calculations (here showing that the Earth has a diameter that is between 1.8 and 2 times bigger than that of Mars):</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>diameter<span style="font-family:'Courier New',monospace;">ₑ </span>= <span style="color:#6897bb;">12_742</span>.<span style="color:#9876aa;">kilometers<br></span><span style="color:#cc7832;">assert </span>diameter<span style="font-family:'Courier New',monospace;">ₘ </span>+ diameter<span style="font-family:'Courier New',monospace;">ₘ </span>> diameter<span style="font-family:'Courier New',monospace;">ₑ<br></span><span style="color:#cc7832;">assert </span>diameter<span style="font-family:'Courier New',monospace;">ₑ </span>- diameter<span style="font-family:'Courier New',monospace;">ₘ </span>< diameter<span style="font-family:'Courier New',monospace;">ₘ<br></span><span style="color:#cc7832;">assert </span>diameter<span style="font-family:'Courier New',monospace;">ₘ </span>* <span style="color:#6897bb;">1.8 </span>< diameter<span style="font-family:'Courier New',monospace;">ₑ</span></pre>
<p>Even though we have more compact expressions, the same data types are in play that we saw previously. They're just a little nicer to type.</p>
<h3>A dynamic DSL for controlling a Mars Rover</h3>
<p>Let's now look at how you could write a little Domain-Specific-Language (DSL) to control a Mars rover robot.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/f/f3/Curiosity_Self-Portrait_at_%27Big_Sky%27_Drilling_Site.jpg" alt="Mars Rover Selfie - image credit: wikipedia" style="width:40%;"></p>
<p>First, we'll write a <code>Direction</code> enum as part of our robot domain model:<br></p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">enum </span>Direction {<br>    <span style="color:#9876aa;font-style:italic;">left</span>, <span style="color:#9876aa;font-style:italic;">right</span>, <span style="color:#9876aa;font-style:italic;">forward</span>, <span style="color:#9876aa;font-style:italic;">backward<br></span>}<br></pre>
<p>There are many ways to write DSLs in Groovy. We'll use a little trick where the verbs are represented as keys in a map. Our DSL then looks like this:<br></p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>move(Direction dir) {<br>    [<span style="color:#6a8759;">by</span>: <span style="font-weight:bold;">{ </span>Quantity<Length> dist <span style="font-weight:bold;">-><br></span><span style="font-weight:bold;">        </span>[<span style="color:#6a8759;">at</span>: <span style="font-weight:bold;">{ </span>Quantity<Speed> speed <span style="font-weight:bold;">-><br></span><span style="font-weight:bold;">            </span>println <span style="color:#6a8759;">"robot moved </span>$dir<span style="color:#6a8759;"> by </span>$dist<span style="color:#6a8759;"> at </span>$speed<span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">        </span><span style="font-weight:bold;">}</span>]<br>    <span style="font-weight:bold;">}</span>]<br>}<br></pre>
<p>Here the implementation is just going to print out a message indicating all of the values it is processing. The real robot would send signals to the rover's robotic subsystems.</p>
<p>Our script for controlling the rover now looks like this:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">move <span style="color:#9876aa;font-style:italic;">right </span>by <span style="color:#6897bb;">2</span>.<span style="color:#9876aa;">m </span>at <span style="color:#6897bb;">5</span>.<span style="color:#9876aa;">cm</span>/s<br></pre>
<p>Which when run gives this output:</p>
<pre>robot moved right by 2 m at 5 cm/s</pre>
<p>As we saw earlier, this is backed by our JSR 385 types. We'll certainly get fail-early runtime errors if there are any calculations involving mismatched types.</p>
<p>If we enable static typing, some additional errors will be detected at compile but because of the very dynamic style of our DSL implementation, not all runtime errors are reflected by typing information. If we want, we can change our DSL implementation to use richer types and that will support better static typing checking. We'll look at one way to do that next.</p>
<h3>A type-rich DSL for the Rover</h3>
<p>Now, instead of using our nested map style we saw previously, we create several richly-typed helper classes and define our <code>move</code> method in terms of those classes:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">class </span>MoveHolder {<br>    Direction <span style="color:#9876aa;">dir<br></span><span style="color:#9876aa;">    </span>ByHolder by(Quantity<Length> dist) {<br>        <span style="color:#cc7832;">new </span>ByHolder(<span style="color:#6a8759;">dist</span>: dist, <span style="color:#6a8759;">dir</span>: <span style="color:#9876aa;">dir</span>)<br>    }<br>}<br><br><span style="color:#cc7832;">class </span>ByHolder {<br>    Quantity<Length> <span style="color:#9876aa;">dist<br></span><span style="color:#9876aa;">    </span>Direction <span style="color:#9876aa;">dir<br></span><span style="color:#9876aa;">    </span><span style="color:#cc7832;">void </span>at(Quantity<Speed> speed) {<br>        println <span style="color:#6a8759;">"robot moved </span>$<span style="color:#9876aa;">dir</span><span style="color:#6a8759;"> by </span>$<span style="color:#9876aa;">dist</span><span style="color:#6a8759;"> at </span>$speed<span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">    </span>}<br>}<br><br><span style="color:#cc7832;">static </span>MoveHolder move(Direction dir) {<br>    <span style="color:#cc7832;">new </span>MoveHolder(<span style="color:#6a8759;">dir</span>: dir)<br>}<br></pre>
<p>While our DSL implementation has changed, the robot scripts remain the same:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#9876aa;font-style:italic;">move right </span>by <span style="color:#6897bb;">2</span>.<span style="color:#9876aa;">m </span>at <span style="color:#6897bb;">5</span>.<span style="color:#9876aa;">cm</span>/s</pre>
<p>Indeed, if we use Groovy dynamic nature, we can still run the same script and will notice no change.</p>
<p>If however, we enable static checking and have a script with an error like this:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#9876aa;font-style:italic;">move forward </span>by <span style="color:#6897bb;">2</span>.<span style="color:#9876aa;">kgs</span><br></pre>
<p>We'll now see a compile-time error:</p>
<pre><span style="color:#C03030;">[Static type checking] - Cannot call MoveHolder#by(javax.measure.Quantity<javax.measure.quantity.<b>Length</b>>) with arguments [javax.measure.Quantity<javax.measure.quantity.<b>Mass</b>>]
</span></pre>
<p>It is great to get this additional earlier feedback on script errors, so you may wonder why we don't write our DSL implementations like this all of the time? Actually, both the dynamic and static flavors of our DSL can be useful at different times. When prototyping our script DSL, deciding on all the nouns and verbs that we should be using to control our robot, the dynamic flavored style can be much quicker to write especially during early iterations which might evolve and change rapidly. Once the DSL language has been locked down, we can invest in adding the richer types. In the rover scenario, it might also be the case that the rover itself has limited power and so may not want to perform additional type checking steps. We might run all scripts through a type checker back at mission control before sending them through to the rover where they may be enacted in dynamic mode.</p>
<h3>Adding custom type checking</h3>
<p>There is one additional language feature of Groovy we haven't mentioned. Groovy's type checking mechanism is extensible, so we'll have a look at using that feature here. The rover's speed is <a href="https://mars.nasa.gov/mars2020/spacecraft/rover/wheels/" target="_blank">rather limited</a>, "<i>In the case of exploring Mars, however, speed isn't the most relevant quality. It's about the journey and the destinations along the way. The slow pace is energy-efficient...</i>". Let's look at limiting the speed to avoid unsafe or energy wasting movement.</p>
<p>We could put early defensive checks in our DSL implementation to detect undesirable manoeuvres but we can also use type checking extensions for certain kinds of errors. Groovy in fact has its own DSL for writing such extensions. That's a topic for its own blog but here's what the code looks like:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">afterMethodCall { call -><br>    <span style="color:#cc7832;">def </span>method = getTargetMethod(call)<br>    <span style="color:#cc7832;">if </span>(method.name != <span style="color:#6a8759;">'at'</span>) <span style="color:#cc7832;">return<br></span><span style="color:#cc7832;">    if </span>(call.arguments.size() != <span style="color:#6897bb;">1</span>) <span style="color:#cc7832;">return<br></span><span style="color:#cc7832;">    def </span>arg = call.arguments[<span style="color:#6897bb;">0</span>]<br>    <span style="color:#cc7832;">if </span>(arg !instanceof BinaryExpression) <span style="color:#cc7832;">return<br></span><span style="color:#cc7832;">    def </span>left = arg.leftExpression<br>    <span style="color:#cc7832;">if </span>(left !instanceof PropertyExpression) <span style="color:#cc7832;">return<br></span><span style="color:#cc7832;">    def </span>obj = left.objectExpression<br>    <span style="color:#cc7832;">if </span>(obj !instanceof ConstantExpression) <span style="color:#cc7832;">return<br></span><span style="color:#cc7832;">    if </span>(obj.value > <span style="color:#6897bb;">5</span>) {<br>        addStaticTypeError(<span style="color:#6a8759;">"Speed of </span>$obj.value<span style="color:#6a8759;"> is too fast!"</span>,call)<br>        handled = <span style="color:#cc7832;">true<br></span><span style="color:#cc7832;">    </span>}<br>}<br></pre>
<p>This is only a partial implementation, it's make numerous assumptions. We could remove those assumptions by adding more code but for now we'll keep this simplified version.</p>
<p>So, now the following script (with the above type checking extension applied) compiles fine:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#9876aa;font-style:italic;">move right </span>by <span style="color:#6897bb;">2</span>.<span style="color:#9876aa;">m </span>at <span style="color:#6897bb;">5</span>.<span style="color:#9876aa;">cm</span>/s</pre>
<p>But this script fails:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#9876aa;font-style:italic;">move right </span>by <span style="color:#6897bb;">2</span>.<span style="color:#9876aa;">m </span>at <span style="color:#6897bb;">6</span>.<span style="color:#9876aa;">cm</span>/s</pre>
<p>The error message is:</p>
<pre><span style="color:#C03030;">[Static type checking] - Speed of 6 is too fast!</span></pre>
<h3>Further information</h3>
<ul>
<li><a href="https://www.jcp.org/en/jsr/detail?id=385" target="_blank">JSR 385: Units of Measurement API 2.0</a></li>
<li><a href="https://unitsofmeasurement.github.io/2017/taste_of_indriya.html" target="_blank">A Taste of Indriya</a><br></li>
<li><a href="https://betterprogramming.pub/unit-and-measurement-in-swift-7c6be4a25586" target="_blank">Unit and Measurement in Swift</a></li>
<li><a href="https://docs.microsoft.com/en-us/archive/blogs/andrewkennedy/" target="_blank">Units of Measure in F#</a><br></li>
<li><a href="https://varkor.github.io/blog/2018/07/30/types-for-units-of-measure.html" target="_blank">Types for units of measure</a></li>
<li><a href="https://www.slideshare.net/keilw/how-jsr-385-could-have-saved-the-mars-climate-orbiter-jfokus-2020" target="_blank">How JSR 385 could have Saved the Mars Climate Orbiter - JFokus 2020</a>&nbsp;(slide deck)</li>
<li><a href="https://www.manning.com/books/groovy-in-action-second-edition" target="_blank">Groovy in Action</a> (in particular the DSL chapter)</li>
<li><a href="https://objectcomputing.com/resources/publications/sett/june-2006-units-and-measures-with-jscience" target="_blank">Units and Measures with JScience</a></li>
<li><a href="https://onlinelibrary.wiley.com/doi/10.1002/spe.2926" target="_blank">Unit of measurement libraries, their popularity and suitability</a></li>
<li><a href="https://speakerdeck.com/glaforge/groovy-domain-specific-languages-techniques" target="_blank">Groovy Domain-Specific Languages techniques</a>&nbsp;(slide deck)</li>
<li><a href="http://docs.groovy-lang.org/docs/latest/html/documentation/core-domain-specific-languages.html" target="_blank">Domain-Specific Languages</a> (Groovy documentation)</li>
<li><a href="https://www.baeldung.com/javax-measure" target="_blank">Introduction to javax.measure</a></li>
<li><a href="https://github.com/paulk-asert/UomGroovy" target="_blank">https://github.com/paulk-asert/UomGroovy</a>&nbsp;(repo)<br></li>
</ul>
<h3>Conclusion</h3>
<p>We have looked at using the JSR 385 <code>javax.measure</code> API using Groovy and added some DSL examples to make using the API a little nicer.</p>

  </div><a class="u-url" href="/groovy/entry/life-on-mars-units-of" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
