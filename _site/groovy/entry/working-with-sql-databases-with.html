<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Working with SQL databases with Groovy and GraalVM | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Working with SQL databases with Groovy and GraalVM" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="During the week, there was an interesting video and blog post on the latest GraalVM 22.2 Release. The release has numerous new features and improvements including: smaller native executables the ability to generate heap dumps in native executables experimental native image debugging within IntelliJ IDEA the ability to embed a Software Bill of Materials (SBOM) into the executable for improved security (when using GraalVM Enterprise) native metadata integration. This blog looks at the last of these. We&#39;ll use the running example of the H2 database which the video discusses. Native Metadata For anyone who has used GraalVM, they will know that frequently certain information must be given to the native compiler. Certain classes can be initialized at build time, others should be initialized at runtime. If accessing certain kinds of resources, knowledge of those resources must be given to the compiler. Parts of the application which might be invoked through reflection or involve serialization, might not be deemed reachable and won&#39;t automatically be included by the compiler. Each library that is being used within an application will have its own set of classes and resources which will commonly need to dealt with by anyone using that library. The Native Metadata repository keeps a shared copy of this information on a per library basis. Once someone has populated the metadata, other projects using the same library can get that information automatically. We&#39;ll look more at metadata integration shortly, but first, let&#39;s look at our database application. Working with SQL in Groovy The application creates and then populates a customer database with four customers. It then prints them out: import groovy.sql.Sqlimport groovy.transform.CompileStatic@CompileStaticclass H2Demo { static void main(args) { Sql.withInstance(&#39;jdbc:h2:./data/test&#39;) { sql -&gt; sql.execute &#39;DROP TABLE IF EXISTS customers&#39; sql.execute &#39;CREATE TABLE customers(id INTEGER AUTO_INCREMENT, name VARCHAR)&#39; for (cust in [&#39;Lord Archimonde&#39;, &#39;Arthur&#39;, &#39;Gilbert&#39;, &#39;Grug&#39;]) { sql.executeInsert &quot;INSERT INTO customers(name) VALUES $cust&quot; } println sql.rows(&#39;SELECT * FROM customers&#39;).join(&#39;\n&#39;) } }} Groovy&#39;s Sql class makes this relatively easy. The withInstance method will create a database connection and close it down when finished with. The executeInsert method is using a Groovy interpolated String (GString) which creates a prepared statement under the covers. Configuring our native build Here is our build file: plugins { id &#39;application&#39; id &#39;groovy&#39; id &#39;org.graalvm.buildtools.native&#39;}application { mainClass = &#39;H2Demo&#39;}repositories { mavenCentral()}dependencies { implementation &#39;com.h2database:h2:2.1.210&#39; implementation &#39;org.apache.groovy:groovy:4.0.4&#39; implementation &#39;org.apache.groovy:groovy-sql:4.0.4&#39;}graalvmNative { agent { defaultMode = &#39;standard&#39; } metadataRepository { enabled = true } binaries { main { buildArgs.addAll(// &#39;-H:IncludeSBOM=cyclonedx&#39;, &#39;--report-unsupported-elements-at-runtime&#39;, &#39;--initialize-at-run-time=groovy.grape.GrapeIvy,org.h2.store.fs.niomem.FileNioMemData&#39;, &#39;--initialize-at-build-time&#39;, &#39;--no-fallback&#39;, ) } }} We make use of the graalvm native build plugin. We define our dependencies of Groovy and H2. We can also supply any needed parameters to the native compiler. Importantly, we enable integration with the metadata repository. When we run the build, it will automatically create the native app for us: paulk@pop-os:/extra/projects/groovy-graalvm-h2$ ./gradlew clean nativeRun ... &gt; Task :nativeCompile [native-image-plugin] Using executable path: /extra/devtools/graalvm-ce-java17-22.2.0/bin/native-image ======================================================================================================================== GraalVM Native Image: Generating &#39;H2Demo&#39; (executable)... ======================================================================================================================== ... [1/7] Initializing... (5.3s @ 0.26GB) Version info: &#39;GraalVM 22.2.0 Java 17 CE&#39; Java version info: &#39;17.0.4+8-jvmci-22.2-b06&#39; C compiler: gcc (linux, x86_64, 11.2.0) Garbage collector: Serial GC 1 user-specific feature(s) - com.oracle.svm.polyglot.groovy.GroovyIndyInterfaceFeature [2/7] Performing analysis... [************] (51.7s @ 1.82GB) 10,597 (90.60%) of 11,697 classes reachable 17,002 (64.13%) of 26,510 fields reachable 58,165 (63.45%) of 91,666 methods reachable 393 classes, 100 fields, and 2,057 methods registered for reflection 65 classes, 74 fields, and 55 methods registered for JNI access 4 native libraries: dl, pthread, rt, z [3/7] Building universe... (8.0s @ 4.02GB) [4/7] Parsing methods... [**] (4.8s @ 3.85GB) [5/7] Inlining methods... [***] (3.0s @ 1.72GB) [6/7] Compiling methods... [******] (38.0s @ 3.63GB) [7/7] Creating image... (5.9s @ 1.70GB) 26.65MB (46.64%) for code area: 38,890 compilation units 28.04MB (49.05%) for image heap: 359,812 objects and 66 resources 2.46MB ( 4.31%) for other data 57.15MB in total ------------------------------------------------------------------------------------------------------------------------ Top 10 packages in code area: Top 10 object types in image heap: 1.48MB sun.security.ssl 5.85MB byte[] for code metadata 1.06MB java.util 2.82MB java.lang.String 979.43KB java.lang.invoke 2.78MB java.lang.Class 758.29KB org.apache.groovy.parser.antlr4 2.47MB byte[] for general heap data 723.92KB com.sun.crypto.provider 2.04MB byte[] for java.lang.String 588.57KB org.h2.table 910.68KB com.oracle.svm.core.hub.DynamicHubCompanion 582.06KB org.h2.command 764.95KB java.util.HashMap$Node 494.23KB org.codehaus.groovy.classgen 761.53KB java.lang.Object[] 476.03KB c.s.org.apache.xerces.internal.impl.xs.traversers 715.65KB byte[] for embedded resources 468.69KB java.lang 584.75KB java.util.HashMap$Node[] 18.87MB for 370 more packages 8.28MB for 2535 more object types ------------------------------------------------------------------------------------------------------------------------ 3.9s (3.2% of total time) in 30 GCs | Peak RSS: 6.22GB | CPU load: 6.48 ------------------------------------------------------------------------------------------------------------------------ Produced artifacts: /extra/projects/groovy-graalvm-h2/build/native/nativeCompile/H2Demo (executable) /extra/projects/groovy-graalvm-h2/build/native/nativeCompile/H2Demo.build_artifacts.txt (txt) ======================================================================================================================== Finished generating &#39;H2Demo&#39; in 2m 1s. [native-image-plugin] Native Image written to: /extra/projects/groovy-graalvm-h2/build/native/nativeCompile &gt; Task :nativeRun [ID:1, NAME:Lord Archimonde] [ID:2, NAME:Arthur] [ID:3, NAME:Gilbert] [ID:4, NAME:Grug] Checking the native image speed We can also check the speed once the native image is built: paulk@pop-os:/extra/projects/groovy-graalvm-h2$ time build/native/nativeCompile/H2Demo [ID:1, NAME:Lord Archimonde] [ID:2, NAME:Arthur] [ID:3, NAME:Gilbert] [ID:4, NAME:Grug] real 0m0.027s user 0m0.010s sys 0m0.011s More information Check out the full source code from the repo:&nbsp;https://github.com/paulk-asert/groovy-graalvm-h2. Conclusion We have looked at a simple H2 database application and the steps involved in creating a native application with Groovy and GraalVM." />
<meta property="og:description" content="During the week, there was an interesting video and blog post on the latest GraalVM 22.2 Release. The release has numerous new features and improvements including: smaller native executables the ability to generate heap dumps in native executables experimental native image debugging within IntelliJ IDEA the ability to embed a Software Bill of Materials (SBOM) into the executable for improved security (when using GraalVM Enterprise) native metadata integration. This blog looks at the last of these. We&#39;ll use the running example of the H2 database which the video discusses. Native Metadata For anyone who has used GraalVM, they will know that frequently certain information must be given to the native compiler. Certain classes can be initialized at build time, others should be initialized at runtime. If accessing certain kinds of resources, knowledge of those resources must be given to the compiler. Parts of the application which might be invoked through reflection or involve serialization, might not be deemed reachable and won&#39;t automatically be included by the compiler. Each library that is being used within an application will have its own set of classes and resources which will commonly need to dealt with by anyone using that library. The Native Metadata repository keeps a shared copy of this information on a per library basis. Once someone has populated the metadata, other projects using the same library can get that information automatically. We&#39;ll look more at metadata integration shortly, but first, let&#39;s look at our database application. Working with SQL in Groovy The application creates and then populates a customer database with four customers. It then prints them out: import groovy.sql.Sqlimport groovy.transform.CompileStatic@CompileStaticclass H2Demo { static void main(args) { Sql.withInstance(&#39;jdbc:h2:./data/test&#39;) { sql -&gt; sql.execute &#39;DROP TABLE IF EXISTS customers&#39; sql.execute &#39;CREATE TABLE customers(id INTEGER AUTO_INCREMENT, name VARCHAR)&#39; for (cust in [&#39;Lord Archimonde&#39;, &#39;Arthur&#39;, &#39;Gilbert&#39;, &#39;Grug&#39;]) { sql.executeInsert &quot;INSERT INTO customers(name) VALUES $cust&quot; } println sql.rows(&#39;SELECT * FROM customers&#39;).join(&#39;\n&#39;) } }} Groovy&#39;s Sql class makes this relatively easy. The withInstance method will create a database connection and close it down when finished with. The executeInsert method is using a Groovy interpolated String (GString) which creates a prepared statement under the covers. Configuring our native build Here is our build file: plugins { id &#39;application&#39; id &#39;groovy&#39; id &#39;org.graalvm.buildtools.native&#39;}application { mainClass = &#39;H2Demo&#39;}repositories { mavenCentral()}dependencies { implementation &#39;com.h2database:h2:2.1.210&#39; implementation &#39;org.apache.groovy:groovy:4.0.4&#39; implementation &#39;org.apache.groovy:groovy-sql:4.0.4&#39;}graalvmNative { agent { defaultMode = &#39;standard&#39; } metadataRepository { enabled = true } binaries { main { buildArgs.addAll(// &#39;-H:IncludeSBOM=cyclonedx&#39;, &#39;--report-unsupported-elements-at-runtime&#39;, &#39;--initialize-at-run-time=groovy.grape.GrapeIvy,org.h2.store.fs.niomem.FileNioMemData&#39;, &#39;--initialize-at-build-time&#39;, &#39;--no-fallback&#39;, ) } }} We make use of the graalvm native build plugin. We define our dependencies of Groovy and H2. We can also supply any needed parameters to the native compiler. Importantly, we enable integration with the metadata repository. When we run the build, it will automatically create the native app for us: paulk@pop-os:/extra/projects/groovy-graalvm-h2$ ./gradlew clean nativeRun ... &gt; Task :nativeCompile [native-image-plugin] Using executable path: /extra/devtools/graalvm-ce-java17-22.2.0/bin/native-image ======================================================================================================================== GraalVM Native Image: Generating &#39;H2Demo&#39; (executable)... ======================================================================================================================== ... [1/7] Initializing... (5.3s @ 0.26GB) Version info: &#39;GraalVM 22.2.0 Java 17 CE&#39; Java version info: &#39;17.0.4+8-jvmci-22.2-b06&#39; C compiler: gcc (linux, x86_64, 11.2.0) Garbage collector: Serial GC 1 user-specific feature(s) - com.oracle.svm.polyglot.groovy.GroovyIndyInterfaceFeature [2/7] Performing analysis... [************] (51.7s @ 1.82GB) 10,597 (90.60%) of 11,697 classes reachable 17,002 (64.13%) of 26,510 fields reachable 58,165 (63.45%) of 91,666 methods reachable 393 classes, 100 fields, and 2,057 methods registered for reflection 65 classes, 74 fields, and 55 methods registered for JNI access 4 native libraries: dl, pthread, rt, z [3/7] Building universe... (8.0s @ 4.02GB) [4/7] Parsing methods... [**] (4.8s @ 3.85GB) [5/7] Inlining methods... [***] (3.0s @ 1.72GB) [6/7] Compiling methods... [******] (38.0s @ 3.63GB) [7/7] Creating image... (5.9s @ 1.70GB) 26.65MB (46.64%) for code area: 38,890 compilation units 28.04MB (49.05%) for image heap: 359,812 objects and 66 resources 2.46MB ( 4.31%) for other data 57.15MB in total ------------------------------------------------------------------------------------------------------------------------ Top 10 packages in code area: Top 10 object types in image heap: 1.48MB sun.security.ssl 5.85MB byte[] for code metadata 1.06MB java.util 2.82MB java.lang.String 979.43KB java.lang.invoke 2.78MB java.lang.Class 758.29KB org.apache.groovy.parser.antlr4 2.47MB byte[] for general heap data 723.92KB com.sun.crypto.provider 2.04MB byte[] for java.lang.String 588.57KB org.h2.table 910.68KB com.oracle.svm.core.hub.DynamicHubCompanion 582.06KB org.h2.command 764.95KB java.util.HashMap$Node 494.23KB org.codehaus.groovy.classgen 761.53KB java.lang.Object[] 476.03KB c.s.org.apache.xerces.internal.impl.xs.traversers 715.65KB byte[] for embedded resources 468.69KB java.lang 584.75KB java.util.HashMap$Node[] 18.87MB for 370 more packages 8.28MB for 2535 more object types ------------------------------------------------------------------------------------------------------------------------ 3.9s (3.2% of total time) in 30 GCs | Peak RSS: 6.22GB | CPU load: 6.48 ------------------------------------------------------------------------------------------------------------------------ Produced artifacts: /extra/projects/groovy-graalvm-h2/build/native/nativeCompile/H2Demo (executable) /extra/projects/groovy-graalvm-h2/build/native/nativeCompile/H2Demo.build_artifacts.txt (txt) ======================================================================================================================== Finished generating &#39;H2Demo&#39; in 2m 1s. [native-image-plugin] Native Image written to: /extra/projects/groovy-graalvm-h2/build/native/nativeCompile &gt; Task :nativeRun [ID:1, NAME:Lord Archimonde] [ID:2, NAME:Arthur] [ID:3, NAME:Gilbert] [ID:4, NAME:Grug] Checking the native image speed We can also check the speed once the native image is built: paulk@pop-os:/extra/projects/groovy-graalvm-h2$ time build/native/nativeCompile/H2Demo [ID:1, NAME:Lord Archimonde] [ID:2, NAME:Arthur] [ID:3, NAME:Gilbert] [ID:4, NAME:Grug] real 0m0.027s user 0m0.010s sys 0m0.011s More information Check out the full source code from the repo:&nbsp;https://github.com/paulk-asert/groovy-graalvm-h2. Conclusion We have looked at a simple H2 database application and the steps involved in creating a native application with Groovy and GraalVM." />
<link rel="canonical" href="http://localhost:4000/groovy/entry/working-with-sql-databases-with" />
<meta property="og:url" content="http://localhost:4000/groovy/entry/working-with-sql-databases-with" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-07-30T10:55:31-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Working with SQL databases with Groovy and GraalVM" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-30T10:55:31-04:00","datePublished":"2022-07-30T10:55:31-04:00","description":"During the week, there was an interesting video and blog post on the latest GraalVM 22.2 Release. The release has numerous new features and improvements including: smaller native executables the ability to generate heap dumps in native executables experimental native image debugging within IntelliJ IDEA the ability to embed a Software Bill of Materials (SBOM) into the executable for improved security (when using GraalVM Enterprise) native metadata integration. This blog looks at the last of these. We&#39;ll use the running example of the H2 database which the video discusses. Native Metadata For anyone who has used GraalVM, they will know that frequently certain information must be given to the native compiler. Certain classes can be initialized at build time, others should be initialized at runtime. If accessing certain kinds of resources, knowledge of those resources must be given to the compiler. Parts of the application which might be invoked through reflection or involve serialization, might not be deemed reachable and won&#39;t automatically be included by the compiler. Each library that is being used within an application will have its own set of classes and resources which will commonly need to dealt with by anyone using that library. The Native Metadata repository keeps a shared copy of this information on a per library basis. Once someone has populated the metadata, other projects using the same library can get that information automatically. We&#39;ll look more at metadata integration shortly, but first, let&#39;s look at our database application. Working with SQL in Groovy The application creates and then populates a customer database with four customers. It then prints them out: import groovy.sql.Sqlimport groovy.transform.CompileStatic@CompileStaticclass H2Demo { static void main(args) { Sql.withInstance(&#39;jdbc:h2:./data/test&#39;) { sql -&gt; sql.execute &#39;DROP TABLE IF EXISTS customers&#39; sql.execute &#39;CREATE TABLE customers(id INTEGER AUTO_INCREMENT, name VARCHAR)&#39; for (cust in [&#39;Lord Archimonde&#39;, &#39;Arthur&#39;, &#39;Gilbert&#39;, &#39;Grug&#39;]) { sql.executeInsert &quot;INSERT INTO customers(name) VALUES $cust&quot; } println sql.rows(&#39;SELECT * FROM customers&#39;).join(&#39;\\n&#39;) } }} Groovy&#39;s Sql class makes this relatively easy. The withInstance method will create a database connection and close it down when finished with. The executeInsert method is using a Groovy interpolated String (GString) which creates a prepared statement under the covers. Configuring our native build Here is our build file: plugins { id &#39;application&#39; id &#39;groovy&#39; id &#39;org.graalvm.buildtools.native&#39;}application { mainClass = &#39;H2Demo&#39;}repositories { mavenCentral()}dependencies { implementation &#39;com.h2database:h2:2.1.210&#39; implementation &#39;org.apache.groovy:groovy:4.0.4&#39; implementation &#39;org.apache.groovy:groovy-sql:4.0.4&#39;}graalvmNative { agent { defaultMode = &#39;standard&#39; } metadataRepository { enabled = true } binaries { main { buildArgs.addAll(// &#39;-H:IncludeSBOM=cyclonedx&#39;, &#39;--report-unsupported-elements-at-runtime&#39;, &#39;--initialize-at-run-time=groovy.grape.GrapeIvy,org.h2.store.fs.niomem.FileNioMemData&#39;, &#39;--initialize-at-build-time&#39;, &#39;--no-fallback&#39;, ) } }} We make use of the graalvm native build plugin. We define our dependencies of Groovy and H2. We can also supply any needed parameters to the native compiler. Importantly, we enable integration with the metadata repository. When we run the build, it will automatically create the native app for us: paulk@pop-os:/extra/projects/groovy-graalvm-h2$ ./gradlew clean nativeRun ... &gt; Task :nativeCompile [native-image-plugin] Using executable path: /extra/devtools/graalvm-ce-java17-22.2.0/bin/native-image ======================================================================================================================== GraalVM Native Image: Generating &#39;H2Demo&#39; (executable)... ======================================================================================================================== ... [1/7] Initializing... (5.3s @ 0.26GB) Version info: &#39;GraalVM 22.2.0 Java 17 CE&#39; Java version info: &#39;17.0.4+8-jvmci-22.2-b06&#39; C compiler: gcc (linux, x86_64, 11.2.0) Garbage collector: Serial GC 1 user-specific feature(s) - com.oracle.svm.polyglot.groovy.GroovyIndyInterfaceFeature [2/7] Performing analysis... [************] (51.7s @ 1.82GB) 10,597 (90.60%) of 11,697 classes reachable 17,002 (64.13%) of 26,510 fields reachable 58,165 (63.45%) of 91,666 methods reachable 393 classes, 100 fields, and 2,057 methods registered for reflection 65 classes, 74 fields, and 55 methods registered for JNI access 4 native libraries: dl, pthread, rt, z [3/7] Building universe... (8.0s @ 4.02GB) [4/7] Parsing methods... [**] (4.8s @ 3.85GB) [5/7] Inlining methods... [***] (3.0s @ 1.72GB) [6/7] Compiling methods... [******] (38.0s @ 3.63GB) [7/7] Creating image... (5.9s @ 1.70GB) 26.65MB (46.64%) for code area: 38,890 compilation units 28.04MB (49.05%) for image heap: 359,812 objects and 66 resources 2.46MB ( 4.31%) for other data 57.15MB in total ------------------------------------------------------------------------------------------------------------------------ Top 10 packages in code area: Top 10 object types in image heap: 1.48MB sun.security.ssl 5.85MB byte[] for code metadata 1.06MB java.util 2.82MB java.lang.String 979.43KB java.lang.invoke 2.78MB java.lang.Class 758.29KB org.apache.groovy.parser.antlr4 2.47MB byte[] for general heap data 723.92KB com.sun.crypto.provider 2.04MB byte[] for java.lang.String 588.57KB org.h2.table 910.68KB com.oracle.svm.core.hub.DynamicHubCompanion 582.06KB org.h2.command 764.95KB java.util.HashMap$Node 494.23KB org.codehaus.groovy.classgen 761.53KB java.lang.Object[] 476.03KB c.s.org.apache.xerces.internal.impl.xs.traversers 715.65KB byte[] for embedded resources 468.69KB java.lang 584.75KB java.util.HashMap$Node[] 18.87MB for 370 more packages 8.28MB for 2535 more object types ------------------------------------------------------------------------------------------------------------------------ 3.9s (3.2% of total time) in 30 GCs | Peak RSS: 6.22GB | CPU load: 6.48 ------------------------------------------------------------------------------------------------------------------------ Produced artifacts: /extra/projects/groovy-graalvm-h2/build/native/nativeCompile/H2Demo (executable) /extra/projects/groovy-graalvm-h2/build/native/nativeCompile/H2Demo.build_artifacts.txt (txt) ======================================================================================================================== Finished generating &#39;H2Demo&#39; in 2m 1s. [native-image-plugin] Native Image written to: /extra/projects/groovy-graalvm-h2/build/native/nativeCompile &gt; Task :nativeRun [ID:1, NAME:Lord Archimonde] [ID:2, NAME:Arthur] [ID:3, NAME:Gilbert] [ID:4, NAME:Grug] Checking the native image speed We can also check the speed once the native image is built: paulk@pop-os:/extra/projects/groovy-graalvm-h2$ time build/native/nativeCompile/H2Demo [ID:1, NAME:Lord Archimonde] [ID:2, NAME:Arthur] [ID:3, NAME:Gilbert] [ID:4, NAME:Grug] real 0m0.027s user 0m0.010s sys 0m0.011s More information Check out the full source code from the repo:&nbsp;https://github.com/paulk-asert/groovy-graalvm-h2. Conclusion We have looked at a simple H2 database application and the steps involved in creating a native application with Groovy and GraalVM.","headline":"Working with SQL databases with Groovy and GraalVM","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/groovy/entry/working-with-sql-databases-with"},"url":"http://localhost:4000/groovy/entry/working-with-sql-databases-with"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Working with SQL databases with Groovy and GraalVM</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-07-30T10:55:31-04:00" itemprop="datePublished">Jul 30, 2022
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Paul King", "login"=>"paulk", "email"=>"paulk@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>During the week, there was an interesting <a href="https://www.youtube.com/watch?v=rpZJz4qbhCU" target="_blank">video</a> and <a href="https://medium.com/graalvm/graalvm-22-2-smaller-jdk-size-improved-memory-usage-better-library-support-and-more-cb34b5b68ec0" target="_blank">blog post</a> on the latest <a href="https://www.graalvm.org/" target="_blank">GraalVM</a> 22.2 Release. The release has numerous new features and improvements including:</p>
<ul>
<li>smaller native executables</li>
<li>the ability to generate heap dumps in native executables</li>
<li>experimental native image debugging within IntelliJ IDEA</li>
<li>the ability to embed a Software Bill of Materials (SBOM) into the executable for improved security (when using GraalVM Enterprise)</li>
<li>native metadata integration.</li>
</ul>
<p>This blog looks at the last of these. We'll use the running example of the <a href="https://www.h2database.com/html/main.html" target="_blank">H2 database</a> which the video discusses.<br></p>
<h3>Native Metadata</h3>
<p>For anyone who has used GraalVM, they will know that frequently certain information must be given to the native compiler. Certain classes can be initialized at build time, others should be initialized at runtime. If accessing certain kinds of resources, knowledge of those resources must be given to the compiler. Parts of the application which might be invoked through reflection or involve serialization, might not be deemed reachable and won't automatically be included by the compiler.</p>
<p>Each library that is being used within an application will have its own set of classes and resources which will commonly need to dealt with by anyone using that library. The Native Metadata repository keeps a shared copy of this information on a per library basis. Once someone has populated the metadata, other projects using the same library can get that information automatically. We'll look more at metadata integration shortly, but first, let's look at our database application.</p>
<h3>Working with SQL in Groovy</h3>
<p>The application creates and then populates a <i>customer</i> database with four customers. It then prints them out:<br></p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.8pt;"><span style="color:#cc7832;">import </span>groovy.sql.Sql<br><span style="color:#cc7832;">import </span>groovy.transform.<span style="color:#bbb529;">CompileStatic<br></span><span style="color:#bbb529;"><br></span><span style="color:#bbb529;">@CompileStatic<br></span><span style="color:#cc7832;">class </span>H2Demo {<br>    <span style="color:#cc7832;">static void </span>main(args) {<br>        Sql.<span style="color:#9876aa;font-style:italic;">withInstance</span>(<span style="color:#6a8759;">'jdbc:h2:./data/test'</span>) <span style="font-weight:bold;">{ </span>sql <span style="font-weight:bold;">-><br></span><span style="font-weight:bold;">            </span>sql.execute <span style="color:#6a8759;">'</span><span style="color:#6a8759;background-color:#364135;">DROP TABLE IF EXISTS customers</span><span style="color:#6a8759;">'<br></span><span style="color:#6a8759;">            </span>sql.execute <span style="color:#6a8759;">'</span><span style="color:#6a8759;background-color:#364135;">CREATE TABLE customers(id INTEGER AUTO_INCREMENT, name VARCHAR)</span><span style="color:#6a8759;">'<br></span><span style="color:#6a8759;">            </span><span style="color:#cc7832;">for </span>(cust <span style="color:#cc7832;">in </span>[<span style="color:#6a8759;">'Lord Archimonde'</span>, <span style="color:#6a8759;">'Arthur'</span>, <span style="color:#6a8759;">'Gilbert'</span>, <span style="color:#6a8759;">'Grug'</span>]) {<br>                sql.executeInsert <span style="color:#6a8759;">"INSERT INTO customers(name) VALUES </span>$cust<span style="color:#6a8759;">"<br></span><span style="color:#6a8759;">            </span>}<br>            println sql.rows(<span style="color:#6a8759;">'</span><span style="color:#6a8759;background-color:#364135;">SELECT * FROM customers</span><span style="color:#6a8759;">'</span>).join(<span style="color:#6a8759;">'</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">'</span>)<br>        <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span>}<br>}<br></pre>
<p>Groovy's <code>Sql</code> class makes this relatively easy. The <code>withInstance</code> method will create a database connection and close it down when finished with. The <code>executeInsert</code> method is using a Groovy interpolated String (GString) which creates a prepared statement under the covers.</p>
<h3>Configuring our native build</h3>
<p>Here is our build file:<br></p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.8pt;">plugins <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>id <span style="color:#6a8759;">'application'<br></span><span style="color:#6a8759;">    </span>id <span style="color:#6a8759;">'groovy'<br></span><span style="color:#6a8759;">    </span>id <span style="color:#6a8759;">'org.graalvm.buildtools.native'<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span>application <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#9876aa;">mainClass </span>= <span style="color:#6a8759;">'H2Demo'<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span>repositories <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>mavenCentral()<br><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span>dependencies <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">   </span>implementation <span style="color:#6a8759;">'com.h2database:h2:2.1.210'<br></span><span style="color:#6a8759;">   </span>implementation <span style="color:#6a8759;">'org.apache.groovy:groovy:4.0.4'<br></span><span style="color:#6a8759;">   </span>implementation <span style="color:#6a8759;">'org.apache.groovy:groovy-sql:4.0.4'<br></span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;"><br></span>graalvmNative <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>agent <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">        </span>defaultMode = <span style="color:#6a8759;">'standard'<br></span><span style="color:#6a8759;">    </span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><b>metadataRepository {<br>        enabled = <span style="color:#cc7832;">true<br></span><span style="color:#cc7832;">    </span>}<br></b><span style="font-weight:bold;">    </span>binaries <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">        </span>main <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">            </span><span style="color:#9876aa;">buildArgs</span>.addAll(<br><span style="color:#808080;">//                    '-H:IncludeSBOM=cyclonedx',<br></span><span style="color:#808080;">                    </span><span style="color:#6a8759;">'--report-unsupported-elements-at-runtime'</span>,<br>                    <span style="color:#6a8759;">'--initialize-at-run-time=groovy.grape.GrapeIvy,org.h2.store.fs.niomem.FileNioMemData'</span>,<br>                    <span style="color:#6a8759;">'--initialize-at-build-time'</span>,<br>                    <span style="color:#6a8759;">'--no-fallback'</span>,<br>            )<br>        <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    }<br></span><span style="font-weight:bold;">}<br></span></pre>
<p>We make use of the graalvm native build plugin. We define our dependencies of Groovy and H2. We can also supply any needed parameters to the native compiler. Importantly, we enable integration with the metadata repository.</p>
<p>When we run the build, it will automatically create the native app for us:<br></p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.8pt;"><span style="color:#4E9A06"><b>paulk@pop-os</b></span>:<span style="color:#3465A4"><b>/extra/projects/groovy-graalvm-h2</b></span>$ ./gradlew clean nativeRun
...
<b>> Task :nativeCompile</b>
[native-image-plugin] Using executable path: /extra/devtools/graalvm-ce-java17-22.2.0/bin/native-image
<span style="color:#A1A1A1">========================================================================================================================</span>
<span style="color:#3465A4"><b>GraalVM Native Image</b></span>: Generating '<b>H2Demo</b>' (executable)...
<span style="color:#A1A1A1">========================================================================================================================</span>
...
<span style="color:#3465A4">[1/7] </span><span style="color:#3465A4"><b>Initializing</b></span><span style="color:#3465A4"><b>...</b></span>                                                                                    (5.3s @ 0.26GB)
 Version info: 'GraalVM 22.2.0 Java 17 CE'
 Java version info: '17.0.4+8-jvmci-22.2-b06'
 C compiler: gcc (linux, x86_64, 11.2.0)
 Garbage collector: Serial GC
 1 user-specific feature(s)
 - com.oracle.svm.polyglot.groovy.GroovyIndyInterfaceFeature
<span style="color:#3465A4">[2/7] </span><span style="color:#3465A4"><b>Performing analysis</b></span><span style="color:#3465A4"><b>...</b></span>  [************]                                                            (51.7s @ 1.82GB)
  10,597 (90.60%) of 11,697 classes reachable
  17,002 (64.13%) of 26,510 fields reachable
  58,165 (63.45%) of 91,666 methods reachable
     393 classes,   100 fields, and 2,057 methods registered for reflection
      65 classes,    74 fields, and    55 methods registered for JNI access
       4 native libraries: dl, pthread, rt, z
<span style="color:#3465A4">[3/7] </span><span style="color:#3465A4"><b>Building universe</b></span><span style="color:#3465A4"><b>...</b></span>                                                                               (8.0s @ 4.02GB)
<span style="color:#3465A4">[4/7] </span><span style="color:#3465A4"><b>Parsing methods</b></span><span style="color:#3465A4"><b>...</b></span>      [**]                                                                       (4.8s @ 3.85GB)
<span style="color:#3465A4">[5/7] </span><span style="color:#3465A4"><b>Inlining methods</b></span><span style="color:#3465A4"><b>...</b></span>     [***]                                                                      (3.0s @ 1.72GB)
<span style="color:#3465A4">[6/7] </span><span style="color:#3465A4"><b>Compiling methods</b></span><span style="color:#3465A4"><b>...</b></span>    [******]                                                                  (38.0s @ 3.63GB)
<span style="color:#3465A4">[7/7] </span><span style="color:#3465A4"><b>Creating image</b></span><span style="color:#3465A4"><b>...</b></span>                                                                                  (5.9s @ 1.70GB)
  26.65MB (46.64%) for code area:    38,890 compilation units
  28.04MB (49.05%) for image heap:  359,812 objects and 66 resources
   2.46MB ( 4.31%) for other data
  57.15MB in total
<span style="color:#A1A1A1">------------------------------------------------------------------------------------------------------------------------</span>
<span style="color:#C4A000"><b>Top 10 packages in code area:                               Top 10 object types in image heap:</b></span>
   1.48MB sun.security.ssl                                     5.85MB byte[] for code metadata
   1.06MB java.util                                            2.82MB java.lang.String
 979.43KB java.lang.invoke                                     2.78MB java.lang.Class
 758.29KB org.apache.groovy.parser.antlr4                      2.47MB byte[] for general heap data
 723.92KB com.sun.crypto.provider                              2.04MB byte[] for java.lang.String
 588.57KB org.h2.table                                       910.68KB com.oracle.svm.core.hub.DynamicHubCompanion
 582.06KB org.h2.command                                     764.95KB java.util.HashMap$Node
 494.23KB org.codehaus.groovy.classgen                       761.53KB java.lang.Object[]
 476.03KB c.s.org.apache.xerces.internal.impl.xs.traversers  715.65KB byte[] for embedded resources
 468.69KB java.lang                                          584.75KB java.util.HashMap$Node[]
  18.87MB for 370 more packages                                8.28MB for 2535 more object types
<span style="color:#A1A1A1">------------------------------------------------------------------------------------------------------------------------</span>
                        3.9s (3.2% of total time) in 30 GCs | Peak RSS: 6.22GB | CPU load: 6.48
<span style="color:#A1A1A1">------------------------------------------------------------------------------------------------------------------------</span>
<span style="color:#C4A000"><b>Produced artifacts:</b></span>
 /extra/projects/groovy-graalvm-h2/build/native/nativeCompile/H2Demo<span style="color:#A1A1A1"> (executable)</span>
 /extra/projects/groovy-graalvm-h2/build/native/nativeCompile/H2Demo.build_artifacts.txt<span style="color:#A1A1A1"> (txt)</span>
<span style="color:#A1A1A1">========================================================================================================================</span>
Finished generating '<b>H2Demo</b>' in 2m 1s.
    [native-image-plugin] Native Image written to: /extra/projects/groovy-graalvm-h2/build/native/nativeCompile

<b>> Task :nativeRun</b>
[ID:1, NAME:Lord Archimonde]
[ID:2, NAME:Arthur]
[ID:3, NAME:Gilbert]
[ID:4, NAME:Grug]
</pre>
<h3>Checking the native image speed</h3>
<p>We can also check the speed once the native image is built:<br></p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.8pt;"><span style="color:#4E9A06"><b>paulk@pop-os</b></span>:<span style="color:#3465A4"><b>/extra/projects/groovy-graalvm-h2</b></span>$ time build/native/nativeCompile/H2Demo
[ID:1, NAME:Lord Archimonde]
[ID:2, NAME:Arthur]
[ID:3, NAME:Gilbert]
[ID:4, NAME:Grug]

real	0m0.027s
user	0m0.010s
sys	0m0.011s</pre>
<h3>More information</h3>
<p>Check out the full source code from the repo:&nbsp;<a href="https://github.com/paulk-asert/groovy-graalvm-h2" target="_blank">https://github.com/paulk-asert/groovy-graalvm-h2</a>.</p>
<h3>Conclusion</h3>
<p>We have looked at a simple H2 database application and the steps involved in creating a native application with Groovy and GraalVM.</p>

  </div><a class="u-url" href="/groovy/entry/working-with-sql-databases-with" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
