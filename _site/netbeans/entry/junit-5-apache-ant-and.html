<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Junit 5, Apache Ant, and Apache NetBeans | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Junit 5, Apache Ant, and Apache NetBeans" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Junit 5 is, architecturally, so different to previous versions, that it should really be called Jupiter, instead. However, this is not a problem when you&#39;re using Maven, since Maven resolves all transitive dependencies for you, and is supported in that way from Apache NetBeans 10 onwards. Not so with Apache Ant, of course, where you need to set each and every JAR you need on a classpath of one form or another. That is not a pretty picture in the end, when compared to JUnit 4, where you had just that JAR, plus Hamcrest. With JUnit 5, you need, in addition to junit-jupiter-api, junit-jupiter-params, and junit-jupiter-engine, to also declare the transitive dependency apiguardian-api, while in the case of Apache Ant, you need to deal with the JUnitLauncher, if you want to make use of the new junitlauncher Ant task, in addition to four other JARs, which need to be on Ant&#39;s classpath, as explained here. An alternative approach is to use org.junit.platform.console.ConsoleLauncher, as shown here, which looks like this in my build.xml, i.e., it is named test, so that it will run automatically at the end of the test run when the Test Project action is invoked: The above means that the JUnit tasks set by default in the build-impl.xml file will simply fail silently, since I don&#39;t have JUnit 4 on my classpath. At the end of the process, the above will be run, org.junit.platform.console.ConsoleLauncher will be found on my classpath, and then the JUnit 5 tests will be run. What is the advantage of the above over using JUnitLauncher? Well, JUnitLauncher has requirements relating to Ant&#39;s path, which has advantages too, of course, i.e., simply set everything up once (which can also be done inside Apache NetBeans, in the Ant tab in the Options window). But, for right now, I&#39;d prefer to work with just one path, i.e., the application&#39;s path. Another downside is that, so far, the above solution doesn&#39;t integrate with the Test Results window, though it does produce some nice reports via the junitreport task above, in the build folder. The key problem seems to me to be that the JUnit Ant task no longer exists in JUnit 5, which was for Ant-based projects the basis of the integration with the Test Results window in Apache NetBeans. If the JUnit task could continue to be used, in whatever way, that would solve a lot of the problems, though the question of the many JARs needed on the classpath would remain. Maybe library providers should reach out to tools providers when putting these kinds of new solutions together, since the only reason that JUnit 5 now works with Maven in Apache NetBeans is that Surefire is used, i.e., in the case of Maven the completely new approach JUnit has taken can simply be avoided there. Here is some relevant discussion in Apache NetBeans GitHub, and the Launcher API looks interesting. Probably the best solution for Ant users in Apache NetBeans would be to be able to continue to use JUnit 4, rather than JUnit 5, since the latter is a total nightmare to set up in the context of Ant, as described above. In the world of JUnit, &quot;vintage&quot; is the cool name they have for &quot;legacy&quot;, and if you&#39;re using Ant at all, you&#39;re probably best described as &quot;vintage&quot; and hence only having support for JUnit 4 is not a big deal for you. However, not sure at all how that would work, we&#39;d need to investigate how/if when JUnit tests are added to Maven projects, JUnit 5 tests and dependencies would be set, while when adding JUnit tests to Ant projects JUnit 4 tests and dependencies would be set." />
<meta property="og:description" content="Junit 5 is, architecturally, so different to previous versions, that it should really be called Jupiter, instead. However, this is not a problem when you&#39;re using Maven, since Maven resolves all transitive dependencies for you, and is supported in that way from Apache NetBeans 10 onwards. Not so with Apache Ant, of course, where you need to set each and every JAR you need on a classpath of one form or another. That is not a pretty picture in the end, when compared to JUnit 4, where you had just that JAR, plus Hamcrest. With JUnit 5, you need, in addition to junit-jupiter-api, junit-jupiter-params, and junit-jupiter-engine, to also declare the transitive dependency apiguardian-api, while in the case of Apache Ant, you need to deal with the JUnitLauncher, if you want to make use of the new junitlauncher Ant task, in addition to four other JARs, which need to be on Ant&#39;s classpath, as explained here. An alternative approach is to use org.junit.platform.console.ConsoleLauncher, as shown here, which looks like this in my build.xml, i.e., it is named test, so that it will run automatically at the end of the test run when the Test Project action is invoked: The above means that the JUnit tasks set by default in the build-impl.xml file will simply fail silently, since I don&#39;t have JUnit 4 on my classpath. At the end of the process, the above will be run, org.junit.platform.console.ConsoleLauncher will be found on my classpath, and then the JUnit 5 tests will be run. What is the advantage of the above over using JUnitLauncher? Well, JUnitLauncher has requirements relating to Ant&#39;s path, which has advantages too, of course, i.e., simply set everything up once (which can also be done inside Apache NetBeans, in the Ant tab in the Options window). But, for right now, I&#39;d prefer to work with just one path, i.e., the application&#39;s path. Another downside is that, so far, the above solution doesn&#39;t integrate with the Test Results window, though it does produce some nice reports via the junitreport task above, in the build folder. The key problem seems to me to be that the JUnit Ant task no longer exists in JUnit 5, which was for Ant-based projects the basis of the integration with the Test Results window in Apache NetBeans. If the JUnit task could continue to be used, in whatever way, that would solve a lot of the problems, though the question of the many JARs needed on the classpath would remain. Maybe library providers should reach out to tools providers when putting these kinds of new solutions together, since the only reason that JUnit 5 now works with Maven in Apache NetBeans is that Surefire is used, i.e., in the case of Maven the completely new approach JUnit has taken can simply be avoided there. Here is some relevant discussion in Apache NetBeans GitHub, and the Launcher API looks interesting. Probably the best solution for Ant users in Apache NetBeans would be to be able to continue to use JUnit 4, rather than JUnit 5, since the latter is a total nightmare to set up in the context of Ant, as described above. In the world of JUnit, &quot;vintage&quot; is the cool name they have for &quot;legacy&quot;, and if you&#39;re using Ant at all, you&#39;re probably best described as &quot;vintage&quot; and hence only having support for JUnit 4 is not a big deal for you. However, not sure at all how that would work, we&#39;d need to investigate how/if when JUnit tests are added to Maven projects, JUnit 5 tests and dependencies would be set, while when adding JUnit tests to Ant projects JUnit 4 tests and dependencies would be set." />
<link rel="canonical" href="http://localhost:4000/netbeans/entry/junit-5-apache-ant-and" />
<meta property="og:url" content="http://localhost:4000/netbeans/entry/junit-5-apache-ant-and" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-02-24T09:17:06-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Junit 5, Apache Ant, and Apache NetBeans" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2019-02-24T09:17:06-05:00","datePublished":"2019-02-24T09:17:06-05:00","description":"Junit 5 is, architecturally, so different to previous versions, that it should really be called Jupiter, instead. However, this is not a problem when you&#39;re using Maven, since Maven resolves all transitive dependencies for you, and is supported in that way from Apache NetBeans 10 onwards. Not so with Apache Ant, of course, where you need to set each and every JAR you need on a classpath of one form or another. That is not a pretty picture in the end, when compared to JUnit 4, where you had just that JAR, plus Hamcrest. With JUnit 5, you need, in addition to junit-jupiter-api, junit-jupiter-params, and junit-jupiter-engine, to also declare the transitive dependency apiguardian-api, while in the case of Apache Ant, you need to deal with the JUnitLauncher, if you want to make use of the new junitlauncher Ant task, in addition to four other JARs, which need to be on Ant&#39;s classpath, as explained here. An alternative approach is to use org.junit.platform.console.ConsoleLauncher, as shown here, which looks like this in my build.xml, i.e., it is named test, so that it will run automatically at the end of the test run when the Test Project action is invoked: The above means that the JUnit tasks set by default in the build-impl.xml file will simply fail silently, since I don&#39;t have JUnit 4 on my classpath. At the end of the process, the above will be run, org.junit.platform.console.ConsoleLauncher will be found on my classpath, and then the JUnit 5 tests will be run. What is the advantage of the above over using JUnitLauncher? Well, JUnitLauncher has requirements relating to Ant&#39;s path, which has advantages too, of course, i.e., simply set everything up once (which can also be done inside Apache NetBeans, in the Ant tab in the Options window). But, for right now, I&#39;d prefer to work with just one path, i.e., the application&#39;s path. Another downside is that, so far, the above solution doesn&#39;t integrate with the Test Results window, though it does produce some nice reports via the junitreport task above, in the build folder. The key problem seems to me to be that the JUnit Ant task no longer exists in JUnit 5, which was for Ant-based projects the basis of the integration with the Test Results window in Apache NetBeans. If the JUnit task could continue to be used, in whatever way, that would solve a lot of the problems, though the question of the many JARs needed on the classpath would remain. Maybe library providers should reach out to tools providers when putting these kinds of new solutions together, since the only reason that JUnit 5 now works with Maven in Apache NetBeans is that Surefire is used, i.e., in the case of Maven the completely new approach JUnit has taken can simply be avoided there. Here is some relevant discussion in Apache NetBeans GitHub, and the Launcher API looks interesting. Probably the best solution for Ant users in Apache NetBeans would be to be able to continue to use JUnit 4, rather than JUnit 5, since the latter is a total nightmare to set up in the context of Ant, as described above. In the world of JUnit, &quot;vintage&quot; is the cool name they have for &quot;legacy&quot;, and if you&#39;re using Ant at all, you&#39;re probably best described as &quot;vintage&quot; and hence only having support for JUnit 4 is not a big deal for you. However, not sure at all how that would work, we&#39;d need to investigate how/if when JUnit tests are added to Maven projects, JUnit 5 tests and dependencies would be set, while when adding JUnit tests to Ant projects JUnit 4 tests and dependencies would be set.","headline":"Junit 5, Apache Ant, and Apache NetBeans","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/netbeans/entry/junit-5-apache-ant-and"},"url":"http://localhost:4000/netbeans/entry/junit-5-apache-ant-and"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Junit 5, Apache Ant, and Apache NetBeans</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-02-24T09:17:06-05:00" itemprop="datePublished">Feb 24, 2019
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"GeertjanWielenga", "login"=>"geertjan", "email"=>"geertjan@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Junit 5 is, architecturally, so different to previous versions, that it should really be called Jupiter, instead. However, this is not a problem when you're using Maven, since Maven resolves all transitive dependencies for you, and is <a href="https://github.com/apache/incubator-netbeans/pull/892">supported in that way from Apache NetBeans 10 onwards</a>. Not so with Apache Ant, of course, where you need to set each and every JAR you need on a classpath of one form or another. </p>
<p>That is not a pretty picture in the end, when compared to JUnit 4, where you had just that JAR, plus Hamcrest. With JUnit 5, you need, in addition to <code>junit-jupiter-api</code>, <code>junit-jupiter-params</code>, and <code>junit-jupiter-engine</code>, to also declare the transitive dependency <code>apiguardian-api</code>, while in the case of Apache Ant, you need to deal with the <code><a href="https://ant.apache.org/manual/Tasks/junitlauncher.html">JUnitLauncher</a></code>, if you want to make use of the new <code> junitlauncher</code> Ant task, in addition to four other JARs, which need to be on Ant's classpath, <a href="https://ant.apache.org/manual/Tasks/junitlauncher.html">as explained here</a>.</p>
<p>An alternative approach is to use <code>org.junit.platform.console.ConsoleLauncher</code>, <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-console-launcher">as shown here</a>, which looks like this in my <code>build.xml</code>, i.e., it is named <code>test</code>, so that it will run automatically at the end of the test run when the Test Project action is invoked:</p>
<p>
<pre><target name="test" depends="compile-test,-pre-test-run">
    <java dir="${work.dir}" 
          classpath="${run.test.classpath}"  
          classname="org.junit.platform.console.ConsoleLauncher">
        <arg value="--scan-classpath"/>
        <arg line="--reports-dir build/test/results"/>
    </java>
    <junitreport todir="build/test/results">
        <fileset dir="build/test/results">
            <include name="TEST-*.xml"/>
        </fileset>
        <report format="frames" todir="build/test/results/html"/>
    </junitreport>
</target></pre>
<p>The above means that the <code>JUnit</code> tasks set by default in the <code>build-impl.xml</code> file will simply fail silently, since I don't have JUnit 4 on my classpath. At the end of the process, the above will be run, <code>org.junit.platform.console.ConsoleLauncher</code> will be found on my classpath, and then the JUnit 5 tests will be run.</p>
<p>What is the advantage of the above over using <code><a href="https://ant.apache.org/manual/Tasks/junitlauncher.html">JUnitLauncher</a></code>? Well, <code>JUnitLauncher</code> has requirements relating to Ant's path, which has advantages too, of course, i.e., simply set everything up once (which can also be done inside Apache NetBeans, in the Ant tab in the Options window). But, for right now, I'd prefer to work with just one path, i.e., the application's path.</p>
<p><img src="https://blogs.apache.org/netbeans/mediaresource/1ef1eb67-8a3f-44dc-b316-90f63c5943b6"/></p>
<p>Another downside is that, so far, the above solution doesn't integrate with the Test Results window, though it does produce some nice reports via the <code>junitreport</code> task above, in the <code>build</code> folder.</p>
<p>The key problem seems to me to be that the <code>JUnit</code> Ant task no longer exists in JUnit 5, which was for Ant-based projects the basis of the integration with the Test Results window in Apache NetBeans. If the <code>JUnit</code> task could continue to be used, in whatever way, that would solve a lot of the problems, though the question of the many JARs needed on the classpath would remain. Maybe library providers should reach out to tools providers when putting these kinds of new solutions together, since the only reason that JUnit 5 now works with Maven in Apache NetBeans is that Surefire is used, i.e., in the case of Maven the completely new approach JUnit has taken can simply be avoided there. <a href="https://github.com/apache/incubator-netbeans/pull/892#issuecomment-423243085">Here is some relevant discussion</a> in Apache NetBeans GitHub, and the <a href="https://junit.org/junit5/docs/current/user-guide/#launcher-api">Launcher API looks interesting</a>.</p>
<p>Probably the best solution for Ant users in Apache NetBeans would be to be able to continue to use JUnit 4, rather than JUnit 5, since the latter is a total nightmare to set up in the context of Ant, as described above. In the world of JUnit, "vintage" is the cool name they have for "legacy", and if you're using Ant at all, you're probably best described as "vintage" and hence only having support for JUnit 4 is not a big deal for you. However, not sure at all how that would work, we'd need to investigate how/if when JUnit tests are added to Maven projects, JUnit 5 tests and dependencies would be set, while when adding JUnit tests to Ant projects JUnit 4 tests and dependencies would be set.</p>

  </div><a class="u-url" href="/netbeans/entry/junit-5-apache-ant-and" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
