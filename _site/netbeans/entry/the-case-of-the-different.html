<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>The case of the different jsch 0.1.54 binaries | Blogs Archive</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="The case of the different jsch 0.1.54 binaries" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="As part of the Apache NetBeans IP clearance we are combing through all the code and dependencies. One interesting thing we bumped into was that the jsch 0.1.54 binary JAR we are using has a different hash (and size) than the binary JAR from Maven Central. The old hash is 0D7D8ABA0D11E8CD2F775F47CD3A6CFBF2837DA4, the new one is DA3584329A263616E277E15462B387ADDD1B208D. The binaries are 278,612 bytes vs 280,515 bytes in Maven Central. Our version is actually the same as the one found on http://www.jcraft.com/jsch/ Also, the Maven JAR is properly signed with the author&#39;s CA7FA1F0 key. This is where it becomes clear that reproducible builds are important. You do not want to have to wonder why a binary differs, especially years later when you are doing a review. And this one is a library doing SSH! So, why the different binaries? It seems the original JAR was compiled on Aug 30, 2016 with Java 1.4 (major version 48) while the Maven Central JAR was compiled Sep 3, 2016 with Java 5 (major version 49). The original JAR also concatenates strings using StringBuffer while the Maven Central JAR uses the newly introduced in 1.5 StringBuilder. Which should also be a bit faster since it&#39;s not synchronized. Next, most of the cypher classes use some reflection via a static java.lang.Class class$(java.lang.String) method. What is this? It&#39;s just the way class literals worked in Java 1.4. As explained here, in Java 5 the ldc_w instruction was introduced to load a Class object. In 1.4 the class literal was helped by the compiler by actually introducing the helper Class class$(java.lang.String className) method and replacing the Person.class with a class$(&quot;Person&quot;) call. It conclusion, it seems that excluding the Java 1.4 to Java 5 compiler changes, the two JARs are identical. With the Maven Central JAR even a bit better due to StringBuilder being used. There is no check so far that the sources do produce the specific JAR. This is an exercise left for the reader." />
<meta property="og:description" content="As part of the Apache NetBeans IP clearance we are combing through all the code and dependencies. One interesting thing we bumped into was that the jsch 0.1.54 binary JAR we are using has a different hash (and size) than the binary JAR from Maven Central. The old hash is 0D7D8ABA0D11E8CD2F775F47CD3A6CFBF2837DA4, the new one is DA3584329A263616E277E15462B387ADDD1B208D. The binaries are 278,612 bytes vs 280,515 bytes in Maven Central. Our version is actually the same as the one found on http://www.jcraft.com/jsch/ Also, the Maven JAR is properly signed with the author&#39;s CA7FA1F0 key. This is where it becomes clear that reproducible builds are important. You do not want to have to wonder why a binary differs, especially years later when you are doing a review. And this one is a library doing SSH! So, why the different binaries? It seems the original JAR was compiled on Aug 30, 2016 with Java 1.4 (major version 48) while the Maven Central JAR was compiled Sep 3, 2016 with Java 5 (major version 49). The original JAR also concatenates strings using StringBuffer while the Maven Central JAR uses the newly introduced in 1.5 StringBuilder. Which should also be a bit faster since it&#39;s not synchronized. Next, most of the cypher classes use some reflection via a static java.lang.Class class$(java.lang.String) method. What is this? It&#39;s just the way class literals worked in Java 1.4. As explained here, in Java 5 the ldc_w instruction was introduced to load a Class object. In 1.4 the class literal was helped by the compiler by actually introducing the helper Class class$(java.lang.String className) method and replacing the Person.class with a class$(&quot;Person&quot;) call. It conclusion, it seems that excluding the Java 1.4 to Java 5 compiler changes, the two JARs are identical. With the Maven Central JAR even a bit better due to StringBuilder being used. There is no check so far that the sources do produce the specific JAR. This is an exercise left for the reader." />
<link rel="canonical" href="http://localhost:4000/netbeans/entry/the-case-of-the-different" />
<meta property="og:url" content="http://localhost:4000/netbeans/entry/the-case-of-the-different" />
<meta property="og:site_name" content="Blogs Archive" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-10-05T08:10:48-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="The case of the different jsch 0.1.54 binaries" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2017-10-05T08:10:48-04:00","datePublished":"2017-10-05T08:10:48-04:00","description":"As part of the Apache NetBeans IP clearance we are combing through all the code and dependencies. One interesting thing we bumped into was that the jsch 0.1.54 binary JAR we are using has a different hash (and size) than the binary JAR from Maven Central. The old hash is 0D7D8ABA0D11E8CD2F775F47CD3A6CFBF2837DA4, the new one is DA3584329A263616E277E15462B387ADDD1B208D. The binaries are 278,612 bytes vs 280,515 bytes in Maven Central. Our version is actually the same as the one found on http://www.jcraft.com/jsch/ Also, the Maven JAR is properly signed with the author&#39;s CA7FA1F0 key. This is where it becomes clear that reproducible builds are important. You do not want to have to wonder why a binary differs, especially years later when you are doing a review. And this one is a library doing SSH! So, why the different binaries? It seems the original JAR was compiled on Aug 30, 2016 with Java 1.4 (major version 48) while the Maven Central JAR was compiled Sep 3, 2016 with Java 5 (major version 49). The original JAR also concatenates strings using StringBuffer while the Maven Central JAR uses the newly introduced in 1.5 StringBuilder. Which should also be a bit faster since it&#39;s not synchronized. Next, most of the cypher classes use some reflection via a static java.lang.Class class$(java.lang.String) method. What is this? It&#39;s just the way class literals worked in Java 1.4. As explained here, in Java 5 the ldc_w instruction was introduced to load a Class object. In 1.4 the class literal was helped by the compiler by actually introducing the helper Class class$(java.lang.String className) method and replacing the Person.class with a class$(&quot;Person&quot;) call. It conclusion, it seems that excluding the Java 1.4 to Java 5 compiler changes, the two JARs are identical. With the Maven Central JAR even a bit better due to StringBuilder being used. There is no check so far that the sources do produce the specific JAR. This is an exercise left for the reader.","headline":"The case of the different jsch 0.1.54 binaries","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/netbeans/entry/the-case-of-the-different"},"url":"http://localhost:4000/netbeans/entry/the-case-of-the-different"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blogs Archive" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Blogs Archive</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">The case of the different jsch 0.1.54 binaries</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-10-05T08:10:48-04:00" itemprop="datePublished">Oct 5, 2017
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Emilian Bold", "login"=>"emi", "email"=>"emi@apache.org"}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>
As part of the Apache NetBeans IP clearance we are combing through all the code and dependencies.</p>
<p>
One interesting thing we bumped into was that the jsch 0.1.54 binary JAR we are using has a different hash (and size) than the binary JAR from Maven Central.</p>
<p>
The old hash is 0D7D8ABA0D11E8CD2F775F47CD3A6CFBF2837DA4, the new one is DA3584329A263616E277E15462B387ADDD1B208D.</p>
<p>
The binaries are 278,612 bytes vs 280,515 bytes in Maven Central.</p>
<p>
Our version is actually the same as the one found on <a href="http://www.jcraft.com/jsch/">http://www.jcraft.com/jsch/</a></p>
<p>
Also, the Maven JAR is properly signed with the author's CA7FA1F0 key.</p>
<p>
This is where it becomes clear that <a href="https://reproducible-builds.org/">reproducible builds</a> are important. You do not want to have to wonder why a binary differs, especially years later when you are doing a review. And this one is a library doing SSH!</p>
<p>
So, why the different binaries?</p>
<p>
It seems the original JAR was compiled on Aug 30, 2016 with Java 1.4 (major version 48) while the Maven Central JAR was compiled Sep 3, 2016 with Java 5 (major version 49).</p>
<p>
The original JAR also concatenates strings using <code>StringBuffer</code> while the Maven Central JAR uses the newly introduced in 1.5 <code>StringBuilder</code>. Which should also be a bit faster since it's not synchronized.</p>
<p>
Next, most of the cypher classes use some reflection via a <code>static java.lang.Class class$(java.lang.String)</code> method.</p>
<p>
What is this? It's just the way class literals worked in Java 1.4. As explained <a href="https://blogs.oracle.com/sundararajan/class-literals-in-jdk-15">here</a>, in Java 5 the <code>ldc_w</code> instruction was introduced to load a <code>Class</code> object.</p>
<p>
In 1.4 the class literal was helped by the compiler by actually introducing the helper <code>Class class$(java.lang.String className)</code> method and replacing the <code>Person.class</code> with a <code>class$("Person")</code> call.</p>
<p>
It conclusion, it seems that excluding the Java 1.4 to Java 5 compiler changes, the two JARs are identical. With the Maven Central JAR even a bit better due to <code>StringBuilder</code> being used.</p>
<p>
There is no check so far that the sources do produce the specific JAR. This is an exercise left for the reader.</p>

  </div><a class="u-url" href="/netbeans/entry/the-case-of-the-different" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blogs Archive</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blogs Archive</li><li><a class="u-email" href="mailto:issues@infra.apache.org">issues@infra.apache.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is an archive of the Roller blogs that were previously hosted on blogs.apache.org</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
